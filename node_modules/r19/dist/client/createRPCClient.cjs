"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const msgpack = require("@msgpack/msgpack");
const isErrorLike = require("../lib/isErrorLike.cjs");
const isR19ErrorLike = require("../lib/isR19ErrorLike.cjs");
const replaceLeaves = require("../lib/replaceLeaves.cjs");
const R19Error = require("../R19Error.cjs");
const createArbitrarilyNestedFunction = (handler, path = []) => {
  return new Proxy(() => void 0, {
    apply(_target, _this, args) {
      return handler(path, args);
    },
    get(_target, property) {
      return createArbitrarilyNestedFunction(handler, [
        ...path,
        property.toString()
      ]);
    }
  });
};
const createRPCClient = (args) => {
  const resolvedFetch = args.fetch || globalThis.fetch.bind(globalThis);
  return createArbitrarilyNestedFunction(async (procedurePath, procedureArgs) => {
    const preparedProcedureArgs = await replaceLeaves.replaceLeaves(procedureArgs, async (value) => {
      if (value instanceof Blob) {
        return new Uint8Array(await value.arrayBuffer());
      }
      if (typeof value === "function") {
        throw new R19Error.R19Error("r19 does not support function arguments.", {
          procedurePath,
          procedureArgs
        });
      }
      return value;
    });
    const body = msgpack.encode({
      procedurePath,
      procedureArgs: preparedProcedureArgs
    }, { ignoreUndefined: true });
    const res = await resolvedFetch(args.serverURL, {
      method: "POST",
      body,
      headers: {
        "Content-Type": "application/msgpack"
      }
    });
    const arrayBuffer = await res.arrayBuffer();
    const resObject = msgpack.decode(new Uint8Array(arrayBuffer));
    if ("error" in resObject) {
      const resError = resObject.error;
      if (isR19ErrorLike.isR19ErrorLike(resError)) {
        const error = new R19Error.R19Error(resError.message, {
          procedurePath,
          procedureArgs
        });
        error.stack = resError.stack;
        throw error;
      } else if (isErrorLike.isErrorLike(resError)) {
        const error = new Error(resError.message);
        error.name = resError.name;
        error.stack = resError.stack;
        throw error;
      } else {
        throw new R19Error.R19Error("An unexpected response was received from the RPC server.", {
          procedurePath,
          procedureArgs,
          cause: resObject
        });
      }
    } else {
      return replaceLeaves.replaceLeaves(resObject.data, async (value) => {
        if (value instanceof Uint8Array) {
          return new Blob([value]);
        }
        return value;
      });
    }
  });
};
exports.createRPCClient = createRPCClient;
//# sourceMappingURL=createRPCClient.cjs.map
