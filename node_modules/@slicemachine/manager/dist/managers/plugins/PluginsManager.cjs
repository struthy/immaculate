"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const pluginKit = require("@slicemachine/plugin-kit");
const assertPluginsInitialized = require("../../lib/assertPluginsInitialized.cjs");
const BaseManager = require("../BaseManager.cjs");
class PluginsManager extends BaseManager.BaseManager {
  constructor(sliceMachineManager, config) {
    super(sliceMachineManager);
    __publicField(this, "_nativePlugins");
    __publicField(this, "dangerouslyCallHook", (...args) => {
      assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
      return this.sliceMachinePluginRunner.callHook(...args);
    });
    this._nativePlugins = config.nativePlugins ?? {};
  }
  async initPlugins() {
    const projectRoot = await this.project.getRoot();
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    this.sliceMachinePluginRunner = pluginKit.createSliceMachinePluginRunner({
      project: {
        root: projectRoot,
        config: sliceMachineConfig
      },
      nativePlugins: this._nativePlugins
    });
    await this.sliceMachinePluginRunner.init();
  }
}
exports.PluginsManager = PluginsManager;
//# sourceMappingURL=PluginsManager.cjs.map
