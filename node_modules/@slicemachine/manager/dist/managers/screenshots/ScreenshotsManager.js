var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as t from "io-ts";
import "readable-web-to-node-stream";
import { fileTypeFromBuffer } from './../../_node_modules/file-type/core.js';
import pLimit from './../../_node_modules/p-limit/index.js';
import fetch from "../../lib/fetch.js";
import { createContentDigest } from "../../lib/createContentDigest.js";
import { decode } from "../../lib/decode.js";
import { SLICE_MACHINE_USER_AGENT } from "../../constants/SLICE_MACHINE_USER_AGENT.js";
import { API_ENDPOINTS } from "../../constants/API_ENDPOINTS.js";
import { BaseManager } from "../BaseManager.js";
import { FormData } from './../../_node_modules/formdata-polyfill/esm.min.js';
import "node:http";
import "node:https";
import "node:zlib";
import "node:stream";
import "node:buffer";
import "node:fs";
import "node:path";
import './../../_node_modules/node-domexception/index.js';
import Blob from './../../_node_modules/fetch-blob/index.js';
function assertS3ACLInitialized(s3ACL) {
  if (s3ACL == void 0) {
    throw new Error("An S3 ACL has not been initialized. Run `SliceMachineManager.screenshots.prototype.initS3ACL()` before re-calling this method.");
  }
}
const uploadScreenshotLimit = pLimit(10);
class ScreenshotsManager extends BaseManager {
  constructor() {
    super(...arguments);
    __publicField(this, "_s3ACL");
  }
  async initS3ACL() {
    const awsACLURL = new URL("create", API_ENDPOINTS.AwsAclProvider);
    const awsACLRes = await this._fetch({ url: awsACLURL });
    const awsACLText = await awsACLRes.text();
    let awsACLJSON;
    try {
      awsACLJSON = JSON.parse(awsACLText);
    } catch (error2) {
      throw new Error(`Invalid AWS ACL response from ${awsACLURL}: ${awsACLText}`, {
        cause: error2
      });
    }
    const { value: awsACL, error } = decode(t.intersection([
      t.type({
        values: t.type({
          url: t.string,
          fields: t.record(t.string, t.string)
        }),
        imgixEndpoint: t.string
      }),
      t.partial({
        message: t.string,
        Message: t.string,
        error: t.string
      })
    ]), awsACLJSON);
    if (error) {
      throw new Error(`Invalid AWS ACL response from ${awsACLURL}`, {
        cause: error
      });
    }
    const errorMessage = awsACL.error || awsACL.message || awsACL.Message;
    if (errorMessage) {
      throw new Error(`Failed to create an AWS ACL: ${errorMessage}`, {
        cause: error
      });
    }
    this._s3ACL = {
      uploadEndpoint: awsACL.values.url,
      requiredFormDataFields: awsACL.values.fields,
      imgixEndpoint: awsACL.imgixEndpoint
    };
  }
  async uploadScreenshot(args) {
    assertS3ACLInitialized(this._s3ACL);
    const formData = new FormData();
    for (const requiredFormDataFieldKey in this._s3ACL.requiredFormDataFields) {
      formData.append(requiredFormDataFieldKey, this._s3ACL.requiredFormDataFields[requiredFormDataFieldKey]);
    }
    const contentDigest = createContentDigest(args.data);
    const fileType = await fileTypeFromBuffer(args.data);
    const fileName = fileType ? `${contentDigest}.${fileType.ext}` : contentDigest;
    const key = args.keyPrefix ? `${args.keyPrefix}/${fileName}` : fileName;
    formData.set("key", key);
    if (fileType) {
      formData.set("Content-Type", fileType.mime);
    }
    formData.set("file", new Blob([args.data], { type: fileType == null ? void 0 : fileType.mime }));
    const s3ACLEndpoint = this._s3ACL.uploadEndpoint;
    const res = await uploadScreenshotLimit(() => fetch(s3ACLEndpoint, {
      method: "POST",
      body: formData
    }));
    if (res.ok) {
      const url = new URL(key, this._s3ACL.imgixEndpoint);
      url.searchParams.set("auto", "compress,format");
      return {
        url: url.toString()
      };
    } else {
      const text = await res.text();
      throw new Error(`Unable to upload screenshot with status code: ${res.status}`, {
        cause: text
      });
    }
  }
  async deleteScreenshotFolder(args) {
    const res = await this._fetch({
      // We're sending `args.sliceID` as `sliceName` because it's inconsistently
      // named in the ACL Provider API.
      body: { sliceName: args.sliceID },
      method: "POST",
      url: new URL("delete-folder", API_ENDPOINTS.AwsAclProvider)
    });
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Unable to delete screenshot folder with status code: ${res.status}`, {
        cause: text
      });
    }
  }
  async _fetch(args) {
    const authenticationToken = await this.user.getAuthenticationToken();
    const repositoryName = await this.project.getRepositoryName();
    return await fetch(args.url, {
      body: args.body ? JSON.stringify(args.body) : void 0,
      headers: {
        Authorization: `Bearer ${authenticationToken}`,
        Repository: repositoryName,
        "User-Agent": SLICE_MACHINE_USER_AGENT,
        ...args.body ? { "Content-Type": "application/json" } : {}
      },
      method: args.method
    });
  }
}
export {
  ScreenshotsManager
};
//# sourceMappingURL=ScreenshotsManager.js.map
