"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("io-ts");
require("readable-web-to-node-stream");
const core = require('./../../_node_modules/file-type/core.cjs');
const index = require('./../../_node_modules/p-limit/index.cjs');
const fetch = require("../../lib/fetch.cjs");
const createContentDigest = require("../../lib/createContentDigest.cjs");
const decode = require("../../lib/decode.cjs");
const SLICE_MACHINE_USER_AGENT = require("../../constants/SLICE_MACHINE_USER_AGENT.cjs");
const API_ENDPOINTS = require("../../constants/API_ENDPOINTS.cjs");
const BaseManager = require("../BaseManager.cjs");
const esm_min = require('./../../_node_modules/formdata-polyfill/esm.min.cjs');
require("node:http");
require("node:https");
require("node:zlib");
require("node:stream");
require("node:buffer");
require("node:fs");
require("node:path");
require('./../../_node_modules/node-domexception/index.cjs');
const index$1 = require('./../../_node_modules/fetch-blob/index.cjs');
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
function assertS3ACLInitialized(s3ACL) {
  if (s3ACL == void 0) {
    throw new Error("An S3 ACL has not been initialized. Run `SliceMachineManager.screenshots.prototype.initS3ACL()` before re-calling this method.");
  }
}
const uploadScreenshotLimit = index(10);
class ScreenshotsManager extends BaseManager.BaseManager {
  constructor() {
    super(...arguments);
    __publicField(this, "_s3ACL");
  }
  async initS3ACL() {
    const awsACLURL = new URL("create", API_ENDPOINTS.API_ENDPOINTS.AwsAclProvider);
    const awsACLRes = await this._fetch({ url: awsACLURL });
    const awsACLText = await awsACLRes.text();
    let awsACLJSON;
    try {
      awsACLJSON = JSON.parse(awsACLText);
    } catch (error2) {
      throw new Error(`Invalid AWS ACL response from ${awsACLURL}: ${awsACLText}`, {
        cause: error2
      });
    }
    const { value: awsACL, error } = decode.decode(t__namespace.intersection([
      t__namespace.type({
        values: t__namespace.type({
          url: t__namespace.string,
          fields: t__namespace.record(t__namespace.string, t__namespace.string)
        }),
        imgixEndpoint: t__namespace.string
      }),
      t__namespace.partial({
        message: t__namespace.string,
        Message: t__namespace.string,
        error: t__namespace.string
      })
    ]), awsACLJSON);
    if (error) {
      throw new Error(`Invalid AWS ACL response from ${awsACLURL}`, {
        cause: error
      });
    }
    const errorMessage = awsACL.error || awsACL.message || awsACL.Message;
    if (errorMessage) {
      throw new Error(`Failed to create an AWS ACL: ${errorMessage}`, {
        cause: error
      });
    }
    this._s3ACL = {
      uploadEndpoint: awsACL.values.url,
      requiredFormDataFields: awsACL.values.fields,
      imgixEndpoint: awsACL.imgixEndpoint
    };
  }
  async uploadScreenshot(args) {
    assertS3ACLInitialized(this._s3ACL);
    const formData = new esm_min.FormData();
    for (const requiredFormDataFieldKey in this._s3ACL.requiredFormDataFields) {
      formData.append(requiredFormDataFieldKey, this._s3ACL.requiredFormDataFields[requiredFormDataFieldKey]);
    }
    const contentDigest = createContentDigest.createContentDigest(args.data);
    const fileType = await core.fileTypeFromBuffer(args.data);
    const fileName = fileType ? `${contentDigest}.${fileType.ext}` : contentDigest;
    const key = args.keyPrefix ? `${args.keyPrefix}/${fileName}` : fileName;
    formData.set("key", key);
    if (fileType) {
      formData.set("Content-Type", fileType.mime);
    }
    formData.set("file", new index$1.default([args.data], { type: fileType == null ? void 0 : fileType.mime }));
    const s3ACLEndpoint = this._s3ACL.uploadEndpoint;
    const res = await uploadScreenshotLimit(() => fetch.default(s3ACLEndpoint, {
      method: "POST",
      body: formData
    }));
    if (res.ok) {
      const url = new URL(key, this._s3ACL.imgixEndpoint);
      url.searchParams.set("auto", "compress,format");
      return {
        url: url.toString()
      };
    } else {
      const text = await res.text();
      throw new Error(`Unable to upload screenshot with status code: ${res.status}`, {
        cause: text
      });
    }
  }
  async deleteScreenshotFolder(args) {
    const res = await this._fetch({
      // We're sending `args.sliceID` as `sliceName` because it's inconsistently
      // named in the ACL Provider API.
      body: { sliceName: args.sliceID },
      method: "POST",
      url: new URL("delete-folder", API_ENDPOINTS.API_ENDPOINTS.AwsAclProvider)
    });
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Unable to delete screenshot folder with status code: ${res.status}`, {
        cause: text
      });
    }
  }
  async _fetch(args) {
    const authenticationToken = await this.user.getAuthenticationToken();
    const repositoryName = await this.project.getRepositoryName();
    return await fetch.default(args.url, {
      body: args.body ? JSON.stringify(args.body) : void 0,
      headers: {
        Authorization: `Bearer ${authenticationToken}`,
        Repository: repositoryName,
        "User-Agent": SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT,
        ...args.body ? { "Content-Type": "application/json" } : {}
      },
      method: args.method
    });
  }
}
exports.ScreenshotsManager = ScreenshotsManager;
//# sourceMappingURL=ScreenshotsManager.cjs.map
