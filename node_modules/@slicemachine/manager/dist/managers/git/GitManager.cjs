"use strict";
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _fetch, fetch_fn;
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("io-ts");
const tt = require("io-ts-types");
const index = require('./../../_node_modules/execa/index.cjs');
const fetch = require("../../lib/fetch.cjs");
const decode = require("../../lib/decode.cjs");
const API_ENDPOINTS = require("../../constants/API_ENDPOINTS.cjs");
const GIT_PROVIDER = require("../../constants/GIT_PROVIDER.cjs");
const errors = require("../../errors.cjs");
const BaseManager = require("../BaseManager.cjs");
const buildGitRepoSpecifier = require("./buildGitRepoSpecifier.cjs");
const GIT_PROVIDER_APP_SLUGS = require("../../constants/GIT_PROVIDER_APP_SLUGS.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const tt__namespace = /* @__PURE__ */ _interopNamespaceDefault(tt);
class GitManager extends BaseManager.BaseManager {
  constructor() {
    super(...arguments);
    __privateAdd(this, _fetch);
  }
  async createGitHubAuthState() {
    const url = new URL("./git/github/create-auth-state", API_ENDPOINTS.API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url, { method: "POST" });
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new errors.UnauthorizedError();
        default:
          throw new Error("Failed to create GitHub auth state.");
      }
    }
    const json = await res.json();
    const { value, error } = decode.decode(t__namespace.type({
      key: t__namespace.string,
      expiresAt: tt__namespace.DateFromISOString
    }), json);
    if (error) {
      throw new errors.UnexpectedDataError(`Failed to decode GitHub auth state: ${error.errors.join(", ")}`, { cause: error });
    }
    return value;
  }
  async fetchOwners() {
    const url = new URL("./git/owners", API_ENDPOINTS.API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url);
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new errors.UnauthenticatedError();
        case 403:
          throw new errors.UnauthorizedError();
        default:
          throw new Error("Failed to fetch owners.");
      }
    }
    const json = await res.json();
    const { value, error } = decode.decode(t__namespace.type({
      owners: t__namespace.array(t__namespace.type({
        provider: t__namespace.literal(GIT_PROVIDER.GIT_PROVIDER.GitHub),
        id: t__namespace.string,
        name: t__namespace.string,
        type: t__namespace.union([t__namespace.literal("user"), t__namespace.literal("team"), t__namespace.null])
      }))
    }), json);
    if (error) {
      throw new errors.UnexpectedDataError(`Failed to decode owners: ${error.errors.join(", ")}`, { cause: error });
    }
    return value.owners;
  }
  async fetchRepos(args) {
    const url = new URL("./git/repos", API_ENDPOINTS.API_ENDPOINTS.SliceMachineV1);
    url.searchParams.set("provider", args.provider);
    url.searchParams.set("owner", args.owner);
    if (args.query) {
      url.searchParams.set("q", args.query);
    }
    if (args.page && args.page > 0) {
      url.searchParams.set("page", args.page.toString());
    }
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url);
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new errors.UnauthenticatedError();
        case 403:
          throw new errors.UnauthorizedError();
        default:
          throw new Error("Failed to fetch repos.");
      }
    }
    const json = await res.json();
    const { value, error } = decode.decode(t__namespace.type({
      repos: t__namespace.array(t__namespace.type({
        provider: t__namespace.literal(GIT_PROVIDER.GIT_PROVIDER.GitHub),
        id: t__namespace.string,
        owner: t__namespace.string,
        name: t__namespace.string,
        url: t__namespace.string,
        pushedAt: tt__namespace.DateFromISOString
      }))
    }), json);
    if (error) {
      throw new errors.UnexpectedDataError(`Failed to decode repos: ${error.errors.join(", ")}`, { cause: error });
    }
    return value.repos;
  }
  async fetchLinkedRepos(args) {
    const url = new URL("./git/linked-repos", API_ENDPOINTS.API_ENDPOINTS.SliceMachineV1);
    url.searchParams.set("repository", args.prismic.domain);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url);
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new errors.UnauthenticatedError();
        case 403:
          throw new errors.UnauthorizedError();
        default:
          throw new Error("Failed to fetch linked repos.");
      }
    }
    const json = await res.json();
    const { value, error } = decode.decode(t__namespace.type({
      repos: t__namespace.array(t__namespace.type({
        provider: t__namespace.literal(GIT_PROVIDER.GIT_PROVIDER.GitHub),
        owner: t__namespace.string,
        name: t__namespace.string
      }))
    }), json);
    if (error) {
      throw new errors.UnexpectedDataError(`Failed to decode linked repos: ${error.errors.join(", ")}`, { cause: error });
    }
    return value.repos;
  }
  async linkRepo(args) {
    const url = new URL("./git/linked-repos", API_ENDPOINTS.API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url, {
      method: "PUT",
      body: {
        prismic: {
          domain: args.prismic.domain
        },
        git: {
          provider: args.git.provider,
          owner: args.git.owner,
          name: args.git.name
        }
      }
    });
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new errors.UnauthenticatedError();
        case 403:
          throw new errors.UnauthorizedError();
        default:
          throw new Error("Failed to link repos.");
      }
    }
  }
  async unlinkRepo(args) {
    const url = new URL("./git/linked-repos", API_ENDPOINTS.API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url, {
      method: "DELETE",
      body: {
        prismic: {
          domain: args.prismic.domain
        },
        git: {
          provider: args.git.provider,
          owner: args.git.owner,
          name: args.git.name
        }
      }
    });
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new errors.UnauthenticatedError();
        case 403:
          throw new errors.UnauthorizedError();
        default:
          throw new Error("Failed to unlink repos.");
      }
    }
  }
  async checkHasWriteAPIToken(args) {
    const url = new URL("./git/linked-repos/write-api-token", API_ENDPOINTS.API_ENDPOINTS.SliceMachineV1);
    url.searchParams.set("repository", args.prismic.domain);
    url.searchParams.set("git", buildGitRepoSpecifier.buildGitRepoSpecifier({
      provider: args.git.provider,
      owner: args.git.owner,
      name: args.git.name
    }));
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url);
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new errors.UnauthenticatedError();
        case 403:
          throw new errors.UnauthorizedError();
        default:
          throw new Error("Failed to check Prismic Write API token.");
      }
    }
    const json = await res.json();
    const { value, error } = decode.decode(t__namespace.type({
      hasWriteAPIToken: t__namespace.boolean
    }), json);
    if (error) {
      throw new errors.UnexpectedDataError(`Failed to decode: ${error.errors.join(", ")}`, { cause: error });
    }
    return value.hasWriteAPIToken;
  }
  async updateWriteAPIToken(args) {
    const url = new URL("./git/linked-repos/write-api-token", API_ENDPOINTS.API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url, {
      method: "PUT",
      body: {
        prismic: {
          domain: args.prismic.domain
        },
        git: {
          provider: args.git.provider,
          owner: args.git.owner,
          name: args.git.name
        },
        token: args.token
      }
    });
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new errors.UnauthenticatedError();
        case 403:
          throw new errors.UnauthorizedError();
        default:
          throw new Error("Failed to update Prismic Write API token.");
      }
    }
  }
  async deleteWriteAPIToken(args) {
    const url = new URL("./git/linked-repos/write-api-token", API_ENDPOINTS.API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url, {
      method: "DELETE",
      body: {
        prismic: {
          domain: args.prismic.domain
        },
        git: {
          provider: args.git.provider,
          owner: args.git.owner,
          name: args.git.name
        }
      }
    });
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new errors.UnauthenticatedError();
        case 403:
          throw new errors.UnauthorizedError();
        default:
          throw new Error("Failed to delete Prismic Write API token.");
      }
    }
  }
  async getProviderAppInstallURL(args) {
    const appSlug = GIT_PROVIDER_APP_SLUGS.GIT_PROVIDER_APP_SLUGS[args.provider];
    switch (args.provider) {
      case GIT_PROVIDER.GIT_PROVIDER.GitHub: {
        const state = await this.createGitHubAuthState();
        const url = new URL(`https://github.com/apps/${appSlug}/installations/new`);
        url.searchParams.set("state", state.key);
        return url.toString();
      }
      default: {
        throw new errors.UnsupportedError(`Git provider not supported: ${args.provider}.`);
      }
    }
  }
  async detectGitProvider() {
    try {
      const remoteUrl = index.execaCommandSync("git remote get-url origin");
      const domainRegex = /(?:https?:\/\/|git@)([^:/]+)[/:]/i;
      const match = remoteUrl.stdout.match(domainRegex);
      const domain = (match == null ? void 0 : match[1]) ?? "";
      return domain;
    } catch (error) {
      return "_unknown";
    }
  }
}
_fetch = new WeakSet();
fetch_fn = async function(url, config) {
  const authenticationToken = await this.user.getAuthenticationToken();
  return await fetch.default(url, {
    method: config == null ? void 0 : config.method,
    body: (config == null ? void 0 : config.body) ? JSON.stringify(config.body) : void 0,
    headers: {
      Authorization: `Bearer ${authenticationToken}`
    }
  });
};
exports.GitManager = GitManager;
//# sourceMappingURL=GitManager.cjs.map
