var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _fetch, fetch_fn;
import * as t from "io-ts";
import * as tt from "io-ts-types";
import { execaCommandSync } from './../../_node_modules/execa/index.js';
import fetch from "../../lib/fetch.js";
import { decode } from "../../lib/decode.js";
import { API_ENDPOINTS } from "../../constants/API_ENDPOINTS.js";
import { GIT_PROVIDER } from "../../constants/GIT_PROVIDER.js";
import { UnauthorizedError, UnexpectedDataError, UnauthenticatedError, UnsupportedError } from "../../errors.js";
import { BaseManager } from "../BaseManager.js";
import { buildGitRepoSpecifier } from "./buildGitRepoSpecifier.js";
import { GIT_PROVIDER_APP_SLUGS } from "../../constants/GIT_PROVIDER_APP_SLUGS.js";
class GitManager extends BaseManager {
  constructor() {
    super(...arguments);
    __privateAdd(this, _fetch);
  }
  async createGitHubAuthState() {
    const url = new URL("./git/github/create-auth-state", API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url, { method: "POST" });
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new UnauthorizedError();
        default:
          throw new Error("Failed to create GitHub auth state.");
      }
    }
    const json = await res.json();
    const { value, error } = decode(t.type({
      key: t.string,
      expiresAt: tt.DateFromISOString
    }), json);
    if (error) {
      throw new UnexpectedDataError(`Failed to decode GitHub auth state: ${error.errors.join(", ")}`, { cause: error });
    }
    return value;
  }
  async fetchOwners() {
    const url = new URL("./git/owners", API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url);
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new UnauthenticatedError();
        case 403:
          throw new UnauthorizedError();
        default:
          throw new Error("Failed to fetch owners.");
      }
    }
    const json = await res.json();
    const { value, error } = decode(t.type({
      owners: t.array(t.type({
        provider: t.literal(GIT_PROVIDER.GitHub),
        id: t.string,
        name: t.string,
        type: t.union([t.literal("user"), t.literal("team"), t.null])
      }))
    }), json);
    if (error) {
      throw new UnexpectedDataError(`Failed to decode owners: ${error.errors.join(", ")}`, { cause: error });
    }
    return value.owners;
  }
  async fetchRepos(args) {
    const url = new URL("./git/repos", API_ENDPOINTS.SliceMachineV1);
    url.searchParams.set("provider", args.provider);
    url.searchParams.set("owner", args.owner);
    if (args.query) {
      url.searchParams.set("q", args.query);
    }
    if (args.page && args.page > 0) {
      url.searchParams.set("page", args.page.toString());
    }
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url);
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new UnauthenticatedError();
        case 403:
          throw new UnauthorizedError();
        default:
          throw new Error("Failed to fetch repos.");
      }
    }
    const json = await res.json();
    const { value, error } = decode(t.type({
      repos: t.array(t.type({
        provider: t.literal(GIT_PROVIDER.GitHub),
        id: t.string,
        owner: t.string,
        name: t.string,
        url: t.string,
        pushedAt: tt.DateFromISOString
      }))
    }), json);
    if (error) {
      throw new UnexpectedDataError(`Failed to decode repos: ${error.errors.join(", ")}`, { cause: error });
    }
    return value.repos;
  }
  async fetchLinkedRepos(args) {
    const url = new URL("./git/linked-repos", API_ENDPOINTS.SliceMachineV1);
    url.searchParams.set("repository", args.prismic.domain);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url);
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new UnauthenticatedError();
        case 403:
          throw new UnauthorizedError();
        default:
          throw new Error("Failed to fetch linked repos.");
      }
    }
    const json = await res.json();
    const { value, error } = decode(t.type({
      repos: t.array(t.type({
        provider: t.literal(GIT_PROVIDER.GitHub),
        owner: t.string,
        name: t.string
      }))
    }), json);
    if (error) {
      throw new UnexpectedDataError(`Failed to decode linked repos: ${error.errors.join(", ")}`, { cause: error });
    }
    return value.repos;
  }
  async linkRepo(args) {
    const url = new URL("./git/linked-repos", API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url, {
      method: "PUT",
      body: {
        prismic: {
          domain: args.prismic.domain
        },
        git: {
          provider: args.git.provider,
          owner: args.git.owner,
          name: args.git.name
        }
      }
    });
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new UnauthenticatedError();
        case 403:
          throw new UnauthorizedError();
        default:
          throw new Error("Failed to link repos.");
      }
    }
  }
  async unlinkRepo(args) {
    const url = new URL("./git/linked-repos", API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url, {
      method: "DELETE",
      body: {
        prismic: {
          domain: args.prismic.domain
        },
        git: {
          provider: args.git.provider,
          owner: args.git.owner,
          name: args.git.name
        }
      }
    });
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new UnauthenticatedError();
        case 403:
          throw new UnauthorizedError();
        default:
          throw new Error("Failed to unlink repos.");
      }
    }
  }
  async checkHasWriteAPIToken(args) {
    const url = new URL("./git/linked-repos/write-api-token", API_ENDPOINTS.SliceMachineV1);
    url.searchParams.set("repository", args.prismic.domain);
    url.searchParams.set("git", buildGitRepoSpecifier({
      provider: args.git.provider,
      owner: args.git.owner,
      name: args.git.name
    }));
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url);
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new UnauthenticatedError();
        case 403:
          throw new UnauthorizedError();
        default:
          throw new Error("Failed to check Prismic Write API token.");
      }
    }
    const json = await res.json();
    const { value, error } = decode(t.type({
      hasWriteAPIToken: t.boolean
    }), json);
    if (error) {
      throw new UnexpectedDataError(`Failed to decode: ${error.errors.join(", ")}`, { cause: error });
    }
    return value.hasWriteAPIToken;
  }
  async updateWriteAPIToken(args) {
    const url = new URL("./git/linked-repos/write-api-token", API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url, {
      method: "PUT",
      body: {
        prismic: {
          domain: args.prismic.domain
        },
        git: {
          provider: args.git.provider,
          owner: args.git.owner,
          name: args.git.name
        },
        token: args.token
      }
    });
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new UnauthenticatedError();
        case 403:
          throw new UnauthorizedError();
        default:
          throw new Error("Failed to update Prismic Write API token.");
      }
    }
  }
  async deleteWriteAPIToken(args) {
    const url = new URL("./git/linked-repos/write-api-token", API_ENDPOINTS.SliceMachineV1);
    const res = await __privateMethod(this, _fetch, fetch_fn).call(this, url, {
      method: "DELETE",
      body: {
        prismic: {
          domain: args.prismic.domain
        },
        git: {
          provider: args.git.provider,
          owner: args.git.owner,
          name: args.git.name
        }
      }
    });
    if (!res.ok) {
      switch (res.status) {
        case 401:
          throw new UnauthenticatedError();
        case 403:
          throw new UnauthorizedError();
        default:
          throw new Error("Failed to delete Prismic Write API token.");
      }
    }
  }
  async getProviderAppInstallURL(args) {
    const appSlug = GIT_PROVIDER_APP_SLUGS[args.provider];
    switch (args.provider) {
      case GIT_PROVIDER.GitHub: {
        const state = await this.createGitHubAuthState();
        const url = new URL(`https://github.com/apps/${appSlug}/installations/new`);
        url.searchParams.set("state", state.key);
        return url.toString();
      }
      default: {
        throw new UnsupportedError(`Git provider not supported: ${args.provider}.`);
      }
    }
  }
  async detectGitProvider() {
    try {
      const remoteUrl = execaCommandSync("git remote get-url origin");
      const domainRegex = /(?:https?:\/\/|git@)([^:/]+)[/:]/i;
      const match = remoteUrl.stdout.match(domainRegex);
      const domain = (match == null ? void 0 : match[1]) ?? "";
      return domain;
    } catch (error) {
      return "_unknown";
    }
  }
}
_fetch = new WeakSet();
fetch_fn = async function(url, config) {
  const authenticationToken = await this.user.getAuthenticationToken();
  return await fetch(url, {
    method: config == null ? void 0 : config.method,
    body: (config == null ? void 0 : config.body) ? JSON.stringify(config.body) : void 0,
    headers: {
      Authorization: `Bearer ${authenticationToken}`
    }
  });
};
export {
  GitManager
};
//# sourceMappingURL=GitManager.js.map
