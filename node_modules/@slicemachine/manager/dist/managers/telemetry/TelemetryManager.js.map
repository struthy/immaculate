{"version":3,"file":"TelemetryManager.js","sources":["../../../../src/managers/telemetry/TelemetryManager.ts"],"sourcesContent":["import {\n\tExperiment,\n\tRemoteEvaluationClient,\n\tVariant,\n} from \"@amplitude/experiment-node-server\";\nimport { randomUUID } from \"node:crypto\";\nimport { Analytics, GroupParams, TrackParams } from \"@segment/analytics-node\";\n\nimport { readPrismicrc } from \"../../lib/prismicrc\";\n\nimport { API_TOKENS } from \"../../constants/API_TOKENS\";\n\nimport { BaseManager } from \"../BaseManager\";\n\nimport {\n\tHumanSegmentEventType,\n\tHumanSegmentEventTypes,\n\tSegmentEvents,\n} from \"./types\";\nimport { Environment } from \"../prismicRepository/types\";\n\ntype TelemetryManagerInitTelemetryArgs = {\n\tappName: string;\n\tappVersion: string;\n};\n\ntype TelemetryManagerTrackArgs = SegmentEvents & {\n\t_includeEnvironmentKind?: boolean;\n};\n\ntype TelemetryManagerIdentifyArgs = {\n\tuserID: string;\n\tintercomHash: string;\n};\n\ntype TelemetryManagerGroupArgs = {\n\tmanualLibsCount: number;\n\tdownloadedLibsCount: number;\n\tnpmLibsCount: number;\n\tdownloadedLibs: string[];\n};\n\ntype TelemetryManagerContext = {\n\tapp: {\n\t\tname: string;\n\t\tversion: string;\n\t};\n};\n\nfunction assertTelemetryInitialized(\n\tsegmentClient: (() => Analytics) | undefined,\n): asserts segmentClient is NonNullable<typeof segmentClient> {\n\tif (segmentClient === undefined) {\n\t\tthrow new Error(\n\t\t\t\"Telemetry has not been initialized. Run `SliceMachineManager.telemetry.prototype.initTelemetry()` before re-calling this method.\",\n\t\t);\n\t}\n}\n\nexport class TelemetryManager extends BaseManager {\n\tprivate _segmentClient: (() => Analytics) | undefined = undefined;\n\tprivate _anonymousID: string | undefined = undefined;\n\tprivate _userID: string | undefined = undefined;\n\tprivate _context: TelemetryManagerContext | undefined = undefined;\n\tprivate _experiment: RemoteEvaluationClient | undefined = undefined;\n\n\tasync initTelemetry(args: TelemetryManagerInitTelemetryArgs): Promise<void> {\n\t\tconst isTelemetryEnabled = await this.checkIsTelemetryEnabled();\n\n\t\tthis._segmentClient = () => {\n\t\t\tconst analytics = new Analytics({\n\t\t\t\twriteKey: API_TOKENS.SegmentKey,\n\t\t\t\t// Since it's a local app, we do not benefit from event batching the way a server would normally do, all tracking event will be awaited.\n\t\t\t\tmaxEventsInBatch: 1,\n\t\t\t\t// TODO: Verify that this actually does not send data to Segment when false.\n\t\t\t\tdisable: !isTelemetryEnabled,\n\t\t\t});\n\n\t\t\tanalytics.on(\"error\", (error) => {\n\t\t\t\t// noop - We don't care if the tracking event\n\t\t\t\t// failed. Some users or networks intentionally\n\t\t\t\t// block Segment, so we can't block the app if\n\t\t\t\t// a tracking event is unsuccessful.\n\t\t\t\tif (import.meta.env.DEV) {\n\t\t\t\t\tconsole.error(`An error occurred with Segment`, error);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn analytics;\n\t\t};\n\n\t\tif (isTelemetryEnabled) {\n\t\t\tthis.initExperiment();\n\t\t}\n\n\t\tthis._anonymousID = randomUUID();\n\t\tthis._context = { app: { name: args.appName, version: args.appVersion } };\n\t}\n\n\t// TODO: Should `userId` be automatically populated by the logged in\n\t// user? We already have their info via UserRepository.\n\tasync track(args: TelemetryManagerTrackArgs): Promise<void> {\n\t\tconst { event, repository, _includeEnvironmentKind, ...properties } = args;\n\t\tlet repositoryName = repository;\n\n\t\tif (repositoryName === undefined) {\n\t\t\ttry {\n\t\t\t\trepositoryName = await this.project.getRepositoryName();\n\t\t\t} catch (error) {\n\t\t\t\t// noop, happen only when the user is not in a project\n\t\t\t}\n\t\t}\n\n\t\tlet environmentKind: Environment[\"kind\"] | \"_unknown\" | undefined =\n\t\t\tundefined;\n\t\tif (_includeEnvironmentKind) {\n\t\t\tif (this.project.checkSupportsEnvironments()) {\n\t\t\t\ttry {\n\t\t\t\t\tconst { activeEnvironment } =\n\t\t\t\t\t\tawait this.project.fetchActiveEnvironment();\n\t\t\t\t\tenvironmentKind = activeEnvironment.kind;\n\t\t\t\t} catch {\n\t\t\t\t\tenvironmentKind = \"_unknown\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Assume only the production environment can be\n\t\t\t\t// used if the project's adapter does not\n\t\t\t\t// support environments.\n\t\t\t\tenvironmentKind = \"prod\";\n\t\t\t}\n\t\t}\n\n\t\tconst payload: {\n\t\t\tevent: HumanSegmentEventTypes;\n\t\t\tuserId?: string;\n\t\t\tanonymousId?: string;\n\t\t\tproperties?: Record<string, unknown>;\n\t\t\tcontext?: Partial<TelemetryManagerContext> & {\n\t\t\t\tgroupId?: {\n\t\t\t\t\tRepository?: string;\n\t\t\t\t};\n\t\t\t};\n\t\t} = {\n\t\t\tevent: HumanSegmentEventType[event],\n\t\t\tproperties: {\n\t\t\t\tnodeVersion: process.versions.node,\n\t\t\t\tenvironmentKind,\n\t\t\t\t...properties,\n\t\t\t},\n\t\t\tcontext: { ...this._context },\n\t\t};\n\n\t\tif (this._userID) {\n\t\t\tpayload.userId = this._userID;\n\t\t} else {\n\t\t\tpayload.anonymousId = this._anonymousID;\n\t\t}\n\n\t\tif (repositoryName) {\n\t\t\tpayload.context ||= {};\n\t\t\tpayload.context.groupId ||= {};\n\t\t\tpayload.context.groupId.Repository = repositoryName;\n\t\t}\n\n\t\treturn new Promise((resolve) => {\n\t\t\tassertTelemetryInitialized(this._segmentClient);\n\n\t\t\t// TODO: Make sure client fails gracefully when no internet connection\n\t\t\tthis._segmentClient().track(\n\t\t\t\tpayload as TrackParams,\n\t\t\t\t(maybeError?: unknown) => {\n\t\t\t\t\tif (maybeError && import.meta.env.DEV) {\n\t\t\t\t\t\t// TODO: Not sure how we want to deal with that\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`An error occurred during Segment tracking`,\n\t\t\t\t\t\t\tmaybeError,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t},\n\t\t\t);\n\t\t});\n\t}\n\n\t// TODO: Should `userID` and `intercomHash` be automatically populated\n\t// by the logged in user? We already have their info via\n\t// UserRepository.\n\tidentify(args: TelemetryManagerIdentifyArgs): Promise<void> {\n\t\tconst payload = {\n\t\t\tuserId: args.userID,\n\t\t\tanonymousId: this._anonymousID,\n\t\t\tintegrations: {\n\t\t\t\tIntercom: {\n\t\t\t\t\tuser_hash: args.intercomHash,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcontext: { ...this._context },\n\t\t};\n\n\t\tthis._userID = args.userID;\n\n\t\treturn new Promise((resolve) => {\n\t\t\tassertTelemetryInitialized(this._segmentClient);\n\n\t\t\t// TODO: Make sure client fails gracefully when no internet connection\n\t\t\tthis._segmentClient().identify(payload, (maybeError?: unknown) => {\n\t\t\t\tif (maybeError && import.meta.env.DEV) {\n\t\t\t\t\t// TODO: Not sure how we want to deal with that\n\t\t\t\t\tconsole.warn(`An error occurred during Segment identify`, maybeError);\n\t\t\t\t}\n\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tasync group(args: TelemetryManagerGroupArgs): Promise<void> {\n\t\tlet repositoryName;\n\n\t\ttry {\n\t\t\trepositoryName = await this.project.getRepositoryName();\n\t\t} catch (error) {\n\t\t\t// noop, happen only when the user is not in a project\n\t\t}\n\n\t\tconst payload: {\n\t\t\tgroupId?: string;\n\t\t\tuserId?: string;\n\t\t\tanonymousId?: string;\n\t\t\ttraits?: Record<string, unknown>;\n\t\t\tcontext?: Partial<TelemetryManagerContext> & {\n\t\t\t\tgroupId?: {\n\t\t\t\t\tRepository?: string;\n\t\t\t\t};\n\t\t\t};\n\t\t} = {\n\t\t\ttraits: args,\n\t\t\tcontext: { ...this._context },\n\t\t};\n\n\t\tif (this._userID) {\n\t\t\tpayload.userId = this._userID;\n\t\t} else {\n\t\t\tpayload.anonymousId = this._anonymousID;\n\t\t}\n\n\t\tif (repositoryName) {\n\t\t\tpayload.groupId = repositoryName;\n\t\t\tpayload.context ||= {};\n\t\t\tpayload.context.groupId ||= {};\n\t\t\tpayload.context.groupId.Repository = repositoryName;\n\t\t}\n\n\t\treturn new Promise((resolve) => {\n\t\t\tassertTelemetryInitialized(this._segmentClient);\n\n\t\t\tthis._segmentClient().group(\n\t\t\t\tpayload as GroupParams,\n\t\t\t\t(maybeError?: unknown) => {\n\t\t\t\t\tif (maybeError && import.meta.env.DEV) {\n\t\t\t\t\t\t// TODO: Not sure how we want to deal with that\n\t\t\t\t\t\tconsole.warn(`An error occurred during Segment group`, maybeError);\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t},\n\t\t\t);\n\t\t});\n\t}\n\n\tasync checkIsTelemetryEnabled(): Promise<boolean> {\n\t\tlet root: string;\n\t\ttry {\n\t\t\troot = await this.project\n\t\t\t\t.getRoot()\n\t\t\t\t.catch(() => this.project.suggestRoot());\n\n\t\t\treturn readPrismicrc(root).telemetry !== false;\n\t\t} catch {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate initExperiment(): void {\n\t\ttry {\n\t\t\tthis._experiment = Experiment.initializeRemote(API_TOKENS.AmplitudeKey);\n\t\t} catch (error) {\n\t\t\tif (import.meta.env.DEV) {\n\t\t\t\tconsole.error(\"Error initializing experiment\", error);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getExperimentVariant(variantKey: string): Promise<Variant | undefined> {\n\t\tif (this._experiment) {\n\t\t\ttry {\n\t\t\t\tconst repositoryName = await this.project.getRepositoryName();\n\t\t\t\tconst variants = await this._experiment.fetchV2({\n\t\t\t\t\tuser_id: this._userID,\n\t\t\t\t\tuser_properties: {\n\t\t\t\t\t\tRepository: repositoryName,\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\treturn variants[variantKey];\n\t\t\t} catch (error) {\n\t\t\t\tif (import.meta.env.DEV) {\n\t\t\t\t\tconsole.error(\"Error fetching experiment variant\", error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n"],"names":["Experiment"],"mappings":"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"}