var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import './../../_node_modules/@amplitude/experiment-node-server/dist/src/index.js';
import { randomUUID } from "node:crypto";
import { Analytics } from "@segment/analytics-node";
import { readPrismicrc } from "../../lib/prismicrc.js";
import { API_TOKENS } from "../../constants/API_TOKENS.js";
import { BaseManager } from "../BaseManager.js";
import { HumanSegmentEventType } from "./types.js";
import { __exports as src } from "../../_virtual/index.js";
function assertTelemetryInitialized(segmentClient) {
  if (segmentClient === void 0) {
    throw new Error("Telemetry has not been initialized. Run `SliceMachineManager.telemetry.prototype.initTelemetry()` before re-calling this method.");
  }
}
class TelemetryManager extends BaseManager {
  constructor() {
    super(...arguments);
    __publicField(this, "_segmentClient");
    __publicField(this, "_anonymousID");
    __publicField(this, "_userID");
    __publicField(this, "_context");
    __publicField(this, "_experiment");
  }
  async initTelemetry(args) {
    const isTelemetryEnabled = await this.checkIsTelemetryEnabled();
    this._segmentClient = () => {
      const analytics = new Analytics({
        writeKey: API_TOKENS.SegmentKey,
        // Since it's a local app, we do not benefit from event batching the way a server would normally do, all tracking event will be awaited.
        maxEventsInBatch: 1,
        // TODO: Verify that this actually does not send data to Segment when false.
        disable: !isTelemetryEnabled
      });
      analytics.on("error", (error) => {
      });
      return analytics;
    };
    if (isTelemetryEnabled) {
      this.initExperiment();
    }
    this._anonymousID = randomUUID();
    this._context = { app: { name: args.appName, version: args.appVersion } };
  }
  // TODO: Should `userId` be automatically populated by the logged in
  // user? We already have their info via UserRepository.
  async track(args) {
    var _a;
    const { event, repository, _includeEnvironmentKind, ...properties } = args;
    let repositoryName = repository;
    if (repositoryName === void 0) {
      try {
        repositoryName = await this.project.getRepositoryName();
      } catch (error) {
      }
    }
    let environmentKind = void 0;
    if (_includeEnvironmentKind) {
      if (this.project.checkSupportsEnvironments()) {
        try {
          const { activeEnvironment } = await this.project.fetchActiveEnvironment();
          environmentKind = activeEnvironment.kind;
        } catch {
          environmentKind = "_unknown";
        }
      } else {
        environmentKind = "prod";
      }
    }
    const payload = {
      event: HumanSegmentEventType[event],
      properties: {
        nodeVersion: process.versions.node,
        environmentKind,
        ...properties
      },
      context: { ...this._context }
    };
    if (this._userID) {
      payload.userId = this._userID;
    } else {
      payload.anonymousId = this._anonymousID;
    }
    if (repositoryName) {
      payload.context || (payload.context = {});
      (_a = payload.context).groupId || (_a.groupId = {});
      payload.context.groupId.Repository = repositoryName;
    }
    return new Promise((resolve) => {
      assertTelemetryInitialized(this._segmentClient);
      this._segmentClient().track(payload, (maybeError) => {
        if (maybeError && false) {
          console.warn(`An error occurred during Segment tracking`, maybeError);
        }
        resolve();
      });
    });
  }
  // TODO: Should `userID` and `intercomHash` be automatically populated
  // by the logged in user? We already have their info via
  // UserRepository.
  identify(args) {
    const payload = {
      userId: args.userID,
      anonymousId: this._anonymousID,
      integrations: {
        Intercom: {
          user_hash: args.intercomHash
        }
      },
      context: { ...this._context }
    };
    this._userID = args.userID;
    return new Promise((resolve) => {
      assertTelemetryInitialized(this._segmentClient);
      this._segmentClient().identify(payload, (maybeError) => {
        if (maybeError && false) {
          console.warn(`An error occurred during Segment identify`, maybeError);
        }
        resolve();
      });
    });
  }
  async group(args) {
    var _a;
    let repositoryName;
    try {
      repositoryName = await this.project.getRepositoryName();
    } catch (error) {
    }
    const payload = {
      traits: args,
      context: { ...this._context }
    };
    if (this._userID) {
      payload.userId = this._userID;
    } else {
      payload.anonymousId = this._anonymousID;
    }
    if (repositoryName) {
      payload.groupId = repositoryName;
      payload.context || (payload.context = {});
      (_a = payload.context).groupId || (_a.groupId = {});
      payload.context.groupId.Repository = repositoryName;
    }
    return new Promise((resolve) => {
      assertTelemetryInitialized(this._segmentClient);
      this._segmentClient().group(payload, (maybeError) => {
        if (maybeError && false) {
          console.warn(`An error occurred during Segment group`, maybeError);
        }
        resolve();
      });
    });
  }
  async checkIsTelemetryEnabled() {
    let root;
    try {
      root = await this.project.getRoot().catch(() => this.project.suggestRoot());
      return readPrismicrc(root).telemetry !== false;
    } catch {
      return true;
    }
  }
  initExperiment() {
    try {
      this._experiment = src.Experiment.initializeRemote(API_TOKENS.AmplitudeKey);
    } catch (error) {
    }
  }
  async getExperimentVariant(variantKey) {
    if (this._experiment) {
      try {
        const repositoryName = await this.project.getRepositoryName();
        const variants = await this._experiment.fetchV2({
          user_id: this._userID,
          user_properties: {
            Repository: repositoryName
          }
        });
        return variants[variantKey];
      } catch (error) {
      }
    }
    return void 0;
  }
}
export {
  TelemetryManager
};
//# sourceMappingURL=TelemetryManager.js.map
