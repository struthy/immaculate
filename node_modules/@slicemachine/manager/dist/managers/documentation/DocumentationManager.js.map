{"version":3,"file":"DocumentationManager.js","sources":["../../../../src/managers/documentation/DocumentationManager.ts"],"sourcesContent":["import * as t from \"io-ts\";\nimport {\n\tHookError,\n\tDocumentationReadHookData,\n\tDocumentation,\n} from \"@slicemachine/plugin-kit\";\nimport { BaseManager } from \"../BaseManager\";\nimport { DecodeError } from \"../../lib/DecodeError\";\nimport { assertPluginsInitialized } from \"../../lib/assertPluginsInitialized\";\nimport { decodeHookResult } from \"../../lib/decodeHookResult\";\n\ntype DocumentationManagerReadReturnType = {\n\tdocumentation: Documentation[];\n\terrors: (DecodeError | HookError)[];\n};\n\nconst documentationCodec = t.intersection([\n\tt.type({ content: t.string }),\n\tt.partial({\n\t\tlabel: t.string,\n\t}),\n]);\n\nexport class DocumentationManager extends BaseManager {\n\tasync read(\n\t\targs: DocumentationReadHookData,\n\t): Promise<DocumentationManagerReadReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"documentation:read\",\n\t\t\targs,\n\t\t);\n\n\t\tconst { data, errors } = decodeHookResult(\n\t\t\tt.array(documentationCodec),\n\t\t\thookResult,\n\t\t);\n\n\t\treturn {\n\t\t\tdocumentation: data.flat(),\n\t\t\terrors,\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;AAgBA,MAAM,qBAAqB,EAAE,aAAa;AAAA,EACzC,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,EAC5B,EAAE,QAAQ;AAAA,IACT,OAAO,EAAE;AAAA,EAAA,CACT;AACD,CAAA;AAEK,MAAO,6BAA6B,YAAW;AAAA,EACpD,MAAM,KACL,MAA+B;AAE/B,6BAAyB,KAAK,wBAAwB;AACtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,sBACA,IAAI;AAGC,UAAA,EAAE,MAAM,OAAM,IAAK,iBACxB,EAAE,MAAM,kBAAkB,GAC1B,UAAU;AAGJ,WAAA;AAAA,MACN,eAAe,KAAK,KAAM;AAAA,MAC1B;AAAA,IAAA;AAAA,EAEF;AACA;"}