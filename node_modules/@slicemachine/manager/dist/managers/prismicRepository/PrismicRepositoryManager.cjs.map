{"version":3,"file":"PrismicRepositoryManager.cjs","sources":["../../../../src/managers/prismicRepository/PrismicRepositoryManager.ts"],"sourcesContent":["import * as t from \"io-ts\";\nimport fetch, { Response } from \"../../lib/fetch\";\nimport { fold } from \"fp-ts/Either\";\n\nimport { assertPluginsInitialized } from \"../../lib/assertPluginsInitialized\";\nimport { decode } from \"../../lib/decode\";\nimport { serializeCookies } from \"../../lib/serializeCookies\";\n\nimport { SLICE_MACHINE_USER_AGENT } from \"../../constants/SLICE_MACHINE_USER_AGENT\";\nimport { API_ENDPOINTS } from \"../../constants/API_ENDPOINTS\";\nimport { REPOSITORY_NAME_VALIDATION } from \"../../constants/REPOSITORY_NAME_VALIDATION\";\n\nimport {\n\tUnauthenticatedError,\n\tUnauthorizedError,\n\tUnexpectedDataError,\n} from \"../../errors\";\n\nimport { BaseManager } from \"../BaseManager\";\n\nimport {\n\tAllChangeTypes,\n\tBulkBody,\n\tChangeTypes,\n\tClientError,\n\tPushChangesLimit,\n\tPushChangesLimitType,\n\tPrismicRepository,\n\tPrismicRepositoryRole,\n\tPrismicRepositoryUserAgent,\n\tPrismicRepositoryUserAgents,\n\tPushChangesRawLimit,\n\tTransactionalMergeArgs,\n\tTransactionalMergeReturnType,\n\tFrameworkWroomTelemetryID,\n\tStarterId,\n\tEnvironment,\n} from \"./types\";\nimport { sortEnvironments } from \"./sortEnvironments\";\n\nconst DEFAULT_REPOSITORY_SETTINGS = {\n\tplan: \"personal\",\n\tisAnnual: \"false\",\n\trole: \"developer\",\n};\n\ntype PrismicRepositoryManagerCheckExistsArgs = {\n\tdomain: string;\n};\n\ntype PrismicRepositoryManagerCreateArgs = {\n\tdomain: string;\n\tframework: FrameworkWroomTelemetryID;\n\tstarterId?: StarterId;\n};\n\ntype PrismicRepositoryManagerDeleteArgs = {\n\tdomain: string;\n\tpassword: string;\n};\n\ntype PrismicRepositoryManagerPushDocumentsArgs = {\n\tdomain: string;\n\tsignature: string;\n\tdocuments: Record<string, unknown>; // TODO: Type unknown if possible(?)\n};\n\ntype PrismicRepositoryManagerFetchEnvironmentsArgs = {\n\t/**\n\t * If set to `true`, all environments are returned regardless of the user's\n\t * permission level.\n\t *\n\t * If set to `false`, only environments the user can access are returned.\n\t *\n\t * @defaultValue `false`\n\t */\n\tincludeAll?: boolean;\n};\n\ntype PrismicRepositoryManagerFetchEnvironmentsReturnType = {\n\tenvironments?: Environment[];\n};\n\nexport class PrismicRepositoryManager extends BaseManager {\n\t// TODO: Add methods for repository-specific actions. E.g. creating a\n\t// new repository.\n\n\tasync readAll(): Promise<PrismicRepository[]> {\n\t\tconst url = new URL(\"./repositories\", API_ENDPOINTS.PrismicUser);\n\t\tconst res = await this._fetch({ url });\n\n\t\tif (res.ok) {\n\t\t\tconst json = await res.json();\n\t\t\tconst { value: repositories, error } = decode(\n\t\t\t\tt.array(PrismicRepository),\n\t\t\t\tjson,\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Failed to decode repositories: ${error.errors.join(\", \")}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn repositories;\n\t\t} else {\n\t\t\tconst text = await res.text();\n\t\t\tthrow new Error(`Failed to read repositories`, { cause: text });\n\t\t}\n\t}\n\n\t// Should this be in manager? It's one of the few sync method\n\t//\n\t// Reply from Angelo 2022-12-22: I think it should be in manager\n\t// because we shouldn't be exporting root-level utilities from this\n\t// package. If we want to make it more inline with the other methods,\n\t// we could simplify the API by changing its signature to the\n\t// following:\n\t//\n\t// ```ts\n\t// (repositoryName: string) => Promise<boolean>\n\t// ```\n\t//\n\t// This method would:\n\t//\n\t// 1. Fetch the list of repositories for the user using `readAll()`.\n\t//    The list would be cached.\n\t// 2. Determine if the user has write access to the given repository.\n\t//\n\t// This version has the following benefits:\n\t//\n\t// - Does not expect the consumer to supply a repository object; it\n\t//   only requires a repository name, which could be sourced from\n\t//   anything (incl. the project's `slicemachine.config.json`).\n\t//\n\t// - Similarly, it does not expect the consumer to call `readAll()`\n\t//   before calling this method.\n\t//\n\t// - Works for repositories that the user does not have access to. For\n\t//   example, I could use it to check if I have access to \"qwerty\",\n\t//   even if I am not added as a user. The purpose of the method is\n\t//   still valid: do I have write access to a given repository?\n\thasWriteAccess(repository: PrismicRepository): boolean {\n\t\tswitch (repository.role) {\n\t\t\tcase PrismicRepositoryRole.SuperUser:\n\t\t\tcase PrismicRepositoryRole.Owner:\n\t\t\tcase PrismicRepositoryRole.Administrator:\n\t\t\t\treturn true;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync checkExists(\n\t\targs: PrismicRepositoryManagerCheckExistsArgs,\n\t): Promise<boolean> {\n\t\tconst url = new URL(\n\t\t\t`./app/dashboard/repositories/${args.domain}/exists`,\n\t\t\tAPI_ENDPOINTS.PrismicWroom,\n\t\t);\n\t\tconst res = await this._fetch({\n\t\t\turl,\n\t\t\tskipAuthentication: true,\n\t\t});\n\n\t\tconst text = await res.text();\n\n\t\tif (res.ok) {\n\t\t\treturn text === \"false\"; // Endpoint returns `false` when repository exists\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`Failed to check repository existence for domain \\`${args.domain}\\``,\n\t\t\t\t{ cause: text },\n\t\t\t);\n\t\t}\n\t}\n\n\tasync create(args: PrismicRepositoryManagerCreateArgs): Promise<void> {\n\t\tconst url = new URL(\n\t\t\t\"./authentication/newrepository?app=slicemachine\",\n\t\t\tAPI_ENDPOINTS.PrismicWroom,\n\t\t);\n\n\t\tconst body = {\n\t\t\t...DEFAULT_REPOSITORY_SETTINGS,\n\t\t\tdomain: args.domain,\n\t\t\t// These properties are optional in the API but needed for tracking\n\t\t\tframework: args.framework,\n\t\t\tstarterId: args.starterId,\n\t\t};\n\n\t\tconst res = await this._fetch({\n\t\t\turl,\n\t\t\tmethod: \"POST\",\n\t\t\tbody,\n\t\t\tuserAgent: PrismicRepositoryUserAgent.SliceMachine, // Custom User Agent is required\n\t\t});\n\t\tconst text = await res.text();\n\n\t\t// Endpoint returns repository name on success, that should be within the validation range\n\t\t// Even when there is an error, we get a 200 success and so we have to check the name thanks to that\n\t\tif (\n\t\t\t!res.ok ||\n\t\t\ttext.length < REPOSITORY_NAME_VALIDATION.Min ||\n\t\t\ttext.length > REPOSITORY_NAME_VALIDATION.Max\n\t\t) {\n\t\t\tthrow new Error(`Failed to create repository \\`${args.domain}\\``, {\n\t\t\t\tcause: text,\n\t\t\t});\n\t\t}\n\t}\n\n\t// TODO: Delete this endpoint? It doesn't seem to be used (I might be wrong). - Angelo\n\tasync delete(args: PrismicRepositoryManagerDeleteArgs): Promise<void> {\n\t\tconst cookies = await this.user.getAuthenticationCookies();\n\n\t\tconst url = new URL(\n\t\t\t`./app/settings/delete?_=${cookies[\"X_XSRF\"]}`, // TODO: Maybe we want to throw early if the token is no available, or get the token another way\n\t\t\tAPI_ENDPOINTS.PrismicWroom,\n\t\t);\n\t\t// Update hostname to include repository domain\n\t\turl.hostname = `${args.domain}.${url.hostname}`;\n\n\t\tconst body = {\n\t\t\tconfirm: args.domain,\n\t\t\tpassword: args.password,\n\t\t};\n\n\t\tconst res = await this._fetch({\n\t\t\turl,\n\t\t\tmethod: \"POST\",\n\t\t\tbody,\n\t\t\tuserAgent: PrismicRepositoryUserAgent.LegacyZero, // Custom User Agent is required\n\t\t});\n\n\t\tif (!res.ok) {\n\t\t\tthrow new Error(`Failed to delete repository \\`${args.domain}\\``, {\n\t\t\t\tcause: res,\n\t\t\t});\n\t\t}\n\t}\n\n\tasync pushDocuments(\n\t\targs: PrismicRepositoryManagerPushDocumentsArgs,\n\t): Promise<void> {\n\t\tconst url = new URL(\"./starter/documents\", API_ENDPOINTS.PrismicWroom);\n\t\t// Update hostname to include repository domain\n\t\turl.hostname = `${args.domain}.${url.hostname}`;\n\n\t\tconst body = {\n\t\t\tsignature: args.signature,\n\t\t\tdocuments: JSON.stringify(args.documents),\n\t\t};\n\n\t\tconst res = await this._fetch({\n\t\t\turl,\n\t\t\tmethod: \"POST\",\n\t\t\tbody,\n\t\t\tuserAgent: PrismicRepositoryUserAgent.LegacyZero, // Custom User Agent is required\n\t\t});\n\n\t\tif (!res.ok) {\n\t\t\tlet reason: string | null = null;\n\t\t\ttry {\n\t\t\t\treason = await res.text();\n\t\t\t} catch {\n\t\t\t\t// Noop\n\t\t\t}\n\n\t\t\t// Ideally the API should throw a 409 or something like that...\n\t\t\tif (reason === \"Repository should not contain documents\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Failed to push documents to repository \\`${args.domain}\\`, repository is not empty`,\n\t\t\t\t\t{\n\t\t\t\t\t\tcause: reason,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Failed to push documents to repository \\`${args.domain}\\`, ${res.status} ${res.statusText}`,\n\t\t\t\t{\n\t\t\t\t\tcause: reason,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t}\n\n\tasync pushChanges(\n\t\targs: TransactionalMergeArgs,\n\t): Promise<TransactionalMergeReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tif (!(await this.user.checkIsLoggedIn())) {\n\t\t\tthrow new UnauthenticatedError();\n\t\t}\n\n\t\ttry {\n\t\t\t// Update the AWS ACL before uploading screenshots as it might have expired\n\t\t\tawait this.screenshots.initS3ACL();\n\n\t\t\tconst allChanges: AllChangeTypes[] = await Promise.all(\n\t\t\t\targs.changes.map(async (change) => {\n\t\t\t\t\tif (change.type === \"Slice\") {\n\t\t\t\t\t\tswitch (change.status) {\n\t\t\t\t\t\t\tcase \"NEW\": {\n\t\t\t\t\t\t\t\tconst { model } = await this.slices.readSlice({\n\t\t\t\t\t\t\t\t\tlibraryID: change.libraryID,\n\t\t\t\t\t\t\t\t\tsliceID: change.id,\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif (!model) {\n\t\t\t\t\t\t\t\t\tthrow Error(`Could not find model ${change.id}`);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst modelWithScreenshots =\n\t\t\t\t\t\t\t\t\tawait this.slices.updateSliceModelScreenshotsInPlace({\n\t\t\t\t\t\t\t\t\t\tlibraryID: change.libraryID,\n\t\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tid: change.id,\n\t\t\t\t\t\t\t\t\tpayload: modelWithScreenshots,\n\t\t\t\t\t\t\t\t\ttype: ChangeTypes.SLICE_INSERT,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"MODIFIED\": {\n\t\t\t\t\t\t\t\tconst { model } = await this.slices.readSlice({\n\t\t\t\t\t\t\t\t\tlibraryID: change.libraryID,\n\t\t\t\t\t\t\t\t\tsliceID: change.id,\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif (!model) {\n\t\t\t\t\t\t\t\t\tthrow Error(`Could not find model ${change.id}`);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst modelWithScreenshots =\n\t\t\t\t\t\t\t\t\tawait this.slices.updateSliceModelScreenshotsInPlace({\n\t\t\t\t\t\t\t\t\t\tlibraryID: change.libraryID,\n\t\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tid: change.id,\n\t\t\t\t\t\t\t\t\tpayload: modelWithScreenshots,\n\t\t\t\t\t\t\t\t\ttype: ChangeTypes.SLICE_UPDATE,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"DELETED\":\n\t\t\t\t\t\t\t\tawait this.screenshots.deleteScreenshotFolder({\n\t\t\t\t\t\t\t\t\tsliceID: change.id,\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tid: change.id,\n\t\t\t\t\t\t\t\t\tpayload: { id: change.id },\n\t\t\t\t\t\t\t\t\ttype: ChangeTypes.SLICE_DELETE,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch (change.status) {\n\t\t\t\t\t\t\tcase \"NEW\": {\n\t\t\t\t\t\t\t\tconst { model } = await this.customTypes.readCustomType({\n\t\t\t\t\t\t\t\t\tid: change.id,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (!model) {\n\t\t\t\t\t\t\t\t\tthrow Error(`Could not find model ${change.id}`);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\ttype: ChangeTypes.CUSTOM_TYPE_INSERT,\n\t\t\t\t\t\t\t\t\tid: change.id,\n\t\t\t\t\t\t\t\t\tpayload: model,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"MODIFIED\": {\n\t\t\t\t\t\t\t\tconst { model } = await this.customTypes.readCustomType({\n\t\t\t\t\t\t\t\t\tid: change.id,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (!model) {\n\t\t\t\t\t\t\t\t\tthrow Error(`Could not find model ${change.id}`);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\ttype: ChangeTypes.CUSTOM_TYPE_UPDATE,\n\t\t\t\t\t\t\t\t\tid: change.id,\n\t\t\t\t\t\t\t\t\tpayload: model,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"DELETED\":\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tid: change.id,\n\t\t\t\t\t\t\t\t\tpayload: { id: change.id },\n\t\t\t\t\t\t\t\t\ttype: ChangeTypes.CUSTOM_TYPE_DELETE,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\t// Compute the POST body\n\t\t\tconst requestBody: BulkBody = {\n\t\t\t\tconfirmDeleteDocuments: args.confirmDeleteDocuments,\n\t\t\t\tchanges: allChanges,\n\t\t\t};\n\n\t\t\tconst repositoryName = await this.project.getResolvedRepositoryName();\n\n\t\t\t// TODO: move to customtypes client\n\t\t\tconst response = await this._fetch({\n\t\t\t\turl: new URL(\"./bulk\", API_ENDPOINTS.PrismicModels),\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: requestBody,\n\t\t\t\trepository: repositoryName,\n\t\t\t});\n\n\t\t\tswitch (response.status) {\n\t\t\t\tcase 202:\n\t\t\t\t\treturn this._decodeLimitOrThrow(\n\t\t\t\t\t\tawait response.json(),\n\t\t\t\t\t\tresponse.status,\n\t\t\t\t\t\tPushChangesLimitType.SOFT,\n\t\t\t\t\t);\n\t\t\t\tcase 204:\n\t\t\t\t\treturn null;\n\t\t\t\tcase 401:\n\t\t\t\t\tthrow new UnauthenticatedError();\n\t\t\t\tcase 403:\n\t\t\t\t\treturn this._decodeLimitOrThrow(\n\t\t\t\t\t\tawait response.json(),\n\t\t\t\t\t\tresponse.status,\n\t\t\t\t\t\tPushChangesLimitType.HARD,\n\t\t\t\t\t);\n\t\t\t\tcase 400:\n\t\t\t\t\tconst text = await response.text();\n\t\t\t\t\tthrow new Error(text);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected status code ${response.status}`, {\n\t\t\t\t\t\tcause: await response.text(),\n\t\t\t\t\t});\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error(\"An error happened while pushing your changes\");\n\t\t\tconsole.error(err);\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tasync fetchEnvironments(\n\t\targs?: PrismicRepositoryManagerFetchEnvironmentsArgs,\n\t): Promise<PrismicRepositoryManagerFetchEnvironmentsReturnType> {\n\t\tconst repositoryName = await this.project.getRepositoryName();\n\n\t\tconst url = new URL(`./environments`, API_ENDPOINTS.SliceMachineV1);\n\t\turl.searchParams.set(\"repository\", repositoryName);\n\n\t\tconst res = await this._fetch({ url });\n\n\t\tif (res.ok) {\n\t\t\tconst json = await res.json();\n\n\t\t\tconst { value, error } = decode(\n\t\t\t\tt.union([\n\t\t\t\t\tt.type({\n\t\t\t\t\t\tresults: t.array(Environment),\n\t\t\t\t\t}),\n\t\t\t\t\tt.type({\n\t\t\t\t\t\terror: t.literal(\"invalid_token\"),\n\t\t\t\t\t}),\n\t\t\t\t]),\n\t\t\t\tjson,\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\tthrow new UnexpectedDataError(\n\t\t\t\t\t`Failed to decode environments: ${error.errors.join(\", \")}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\"results\" in value) {\n\t\t\t\tlet environments = value.results;\n\n\t\t\t\tif (!args?.includeAll) {\n\t\t\t\t\tconst profile = await this.user.getProfile();\n\n\t\t\t\t\tenvironments = environments.filter((environment) =>\n\t\t\t\t\t\tenvironment.users.some((user) => user.id === profile.shortId),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn { environments: sortEnvironments(environments) };\n\t\t\t}\n\t\t}\n\n\t\tswitch (res.status) {\n\t\t\tcase 400:\n\t\t\tcase 401:\n\t\t\t\tthrow new UnauthenticatedError();\n\t\t\tcase 403:\n\t\t\t\tthrow new UnauthorizedError();\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Failed to fetch environments.\");\n\t\t}\n\t}\n\n\tprivate _decodeLimitOrThrow(\n\t\tpotentialLimit: unknown,\n\t\tstatusCode: number,\n\t\tlimitType: PushChangesLimitType,\n\t): PushChangesLimit | null {\n\t\treturn fold<t.Errors, PushChangesRawLimit, PushChangesLimit | null>(\n\t\t\t() => {\n\t\t\t\tconst error: ClientError = {\n\t\t\t\t\tstatus: statusCode,\n\t\t\t\t\tmessage: `Unable to parse raw limit from ${JSON.stringify(\n\t\t\t\t\t\tpotentialLimit,\n\t\t\t\t\t)}`,\n\t\t\t\t};\n\t\t\t\tthrow error;\n\t\t\t},\n\t\t\t(rawLimit: PushChangesRawLimit) => {\n\t\t\t\tconst limit = { ...rawLimit, type: limitType };\n\n\t\t\t\treturn limit;\n\t\t\t},\n\t\t)(PushChangesRawLimit.decode(potentialLimit));\n\t}\n\n\tprivate async _fetch(args: {\n\t\turl: URL;\n\t\tmethod?: \"GET\" | \"POST\";\n\t\tbody?: unknown;\n\t\tuserAgent?: PrismicRepositoryUserAgents;\n\t\trepository?: string;\n\t\tskipAuthentication?: boolean;\n\t}): Promise<Response> {\n\t\tlet cookies;\n\t\ttry {\n\t\t\tcookies = await this.user.getAuthenticationCookies();\n\t\t} catch (e) {\n\t\t\tif (!args.skipAuthentication) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t\tconst extraHeaders: Record<string, string> = {};\n\n\t\tif (args.body) {\n\t\t\textraHeaders[\"Content-Type\"] = \"application/json\";\n\t\t}\n\n\t\tif (args.repository) {\n\t\t\textraHeaders.repository = args.repository;\n\t\t}\n\n\t\treturn await fetch(args.url.toString(), {\n\t\t\tmethod: args.method,\n\t\t\tbody: args.body ? JSON.stringify(args.body) : undefined,\n\t\t\theaders: {\n\t\t\t\t// Some endpoints rely on the authorization header...\n\n\t\t\t\t...(cookies !== undefined\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tAuthorization: `Bearer ${cookies[\"prismic-auth\"]}`,\n\t\t\t\t\t\t\tCookie: serializeCookies(cookies),\n\t\t\t\t\t  }\n\t\t\t\t\t: {}),\n\t\t\t\t\"User-Agent\": args.userAgent || SLICE_MACHINE_USER_AGENT,\n\t\t\t\t...extraHeaders,\n\t\t\t},\n\t\t});\n\t}\n}\n"],"names":["BaseManager","API_ENDPOINTS","decode","t","PrismicRepository","PrismicRepositoryRole","PrismicRepositoryUserAgent","REPOSITORY_NAME_VALIDATION","assertPluginsInitialized","UnauthenticatedError","ChangeTypes","PushChangesLimitType","Environment","UnexpectedDataError","sortEnvironments","UnauthorizedError","fold","PushChangesRawLimit","fetch","serializeCookies","SLICE_MACHINE_USER_AGENT"],"mappings":"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"}