"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("io-ts");
const fetch = require("../../lib/fetch.cjs");
const Either = require('./../../_node_modules/fp-ts/es6/Either.cjs');
const assertPluginsInitialized = require("../../lib/assertPluginsInitialized.cjs");
const decode = require("../../lib/decode.cjs");
const serializeCookies = require("../../lib/serializeCookies.cjs");
const SLICE_MACHINE_USER_AGENT = require("../../constants/SLICE_MACHINE_USER_AGENT.cjs");
const API_ENDPOINTS = require("../../constants/API_ENDPOINTS.cjs");
const REPOSITORY_NAME_VALIDATION = require("../../constants/REPOSITORY_NAME_VALIDATION.cjs");
const errors = require("../../errors.cjs");
const BaseManager = require("../BaseManager.cjs");
const types = require("./types.cjs");
const sortEnvironments = require("./sortEnvironments.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const DEFAULT_REPOSITORY_SETTINGS = {
  plan: "personal",
  isAnnual: "false",
  role: "developer"
};
class PrismicRepositoryManager extends BaseManager.BaseManager {
  // TODO: Add methods for repository-specific actions. E.g. creating a
  // new repository.
  async readAll() {
    const url = new URL("./repositories", API_ENDPOINTS.API_ENDPOINTS.PrismicUser);
    const res = await this._fetch({ url });
    if (res.ok) {
      const json = await res.json();
      const { value: repositories, error } = decode.decode(t__namespace.array(types.PrismicRepository), json);
      if (error) {
        throw new Error(`Failed to decode repositories: ${error.errors.join(", ")}`);
      }
      return repositories;
    } else {
      const text = await res.text();
      throw new Error(`Failed to read repositories`, { cause: text });
    }
  }
  // Should this be in manager? It's one of the few sync method
  //
  // Reply from Angelo 2022-12-22: I think it should be in manager
  // because we shouldn't be exporting root-level utilities from this
  // package. If we want to make it more inline with the other methods,
  // we could simplify the API by changing its signature to the
  // following:
  //
  // ```ts
  // (repositoryName: string) => Promise<boolean>
  // ```
  //
  // This method would:
  //
  // 1. Fetch the list of repositories for the user using `readAll()`.
  //    The list would be cached.
  // 2. Determine if the user has write access to the given repository.
  //
  // This version has the following benefits:
  //
  // - Does not expect the consumer to supply a repository object; it
  //   only requires a repository name, which could be sourced from
  //   anything (incl. the project's `slicemachine.config.json`).
  //
  // - Similarly, it does not expect the consumer to call `readAll()`
  //   before calling this method.
  //
  // - Works for repositories that the user does not have access to. For
  //   example, I could use it to check if I have access to "qwerty",
  //   even if I am not added as a user. The purpose of the method is
  //   still valid: do I have write access to a given repository?
  hasWriteAccess(repository) {
    switch (repository.role) {
      case types.PrismicRepositoryRole.SuperUser:
      case types.PrismicRepositoryRole.Owner:
      case types.PrismicRepositoryRole.Administrator:
        return true;
      default:
        return false;
    }
  }
  async checkExists(args) {
    const url = new URL(`./app/dashboard/repositories/${args.domain}/exists`, API_ENDPOINTS.API_ENDPOINTS.PrismicWroom);
    const res = await this._fetch({
      url,
      skipAuthentication: true
    });
    const text = await res.text();
    if (res.ok) {
      return text === "false";
    } else {
      throw new Error(`Failed to check repository existence for domain \`${args.domain}\``, { cause: text });
    }
  }
  async create(args) {
    const url = new URL("./authentication/newrepository?app=slicemachine", API_ENDPOINTS.API_ENDPOINTS.PrismicWroom);
    const body = {
      ...DEFAULT_REPOSITORY_SETTINGS,
      domain: args.domain,
      // These properties are optional in the API but needed for tracking
      framework: args.framework,
      starterId: args.starterId
    };
    const res = await this._fetch({
      url,
      method: "POST",
      body,
      userAgent: types.PrismicRepositoryUserAgent.SliceMachine
      // Custom User Agent is required
    });
    const text = await res.text();
    if (!res.ok || text.length < REPOSITORY_NAME_VALIDATION.REPOSITORY_NAME_VALIDATION.Min || text.length > REPOSITORY_NAME_VALIDATION.REPOSITORY_NAME_VALIDATION.Max) {
      throw new Error(`Failed to create repository \`${args.domain}\``, {
        cause: text
      });
    }
  }
  // TODO: Delete this endpoint? It doesn't seem to be used (I might be wrong). - Angelo
  async delete(args) {
    const cookies = await this.user.getAuthenticationCookies();
    const url = new URL(
      `./app/settings/delete?_=${cookies["X_XSRF"]}`,
      // TODO: Maybe we want to throw early if the token is no available, or get the token another way
      API_ENDPOINTS.API_ENDPOINTS.PrismicWroom
    );
    url.hostname = `${args.domain}.${url.hostname}`;
    const body = {
      confirm: args.domain,
      password: args.password
    };
    const res = await this._fetch({
      url,
      method: "POST",
      body,
      userAgent: types.PrismicRepositoryUserAgent.LegacyZero
      // Custom User Agent is required
    });
    if (!res.ok) {
      throw new Error(`Failed to delete repository \`${args.domain}\``, {
        cause: res
      });
    }
  }
  async pushDocuments(args) {
    const url = new URL("./starter/documents", API_ENDPOINTS.API_ENDPOINTS.PrismicWroom);
    url.hostname = `${args.domain}.${url.hostname}`;
    const body = {
      signature: args.signature,
      documents: JSON.stringify(args.documents)
    };
    const res = await this._fetch({
      url,
      method: "POST",
      body,
      userAgent: types.PrismicRepositoryUserAgent.LegacyZero
      // Custom User Agent is required
    });
    if (!res.ok) {
      let reason = null;
      try {
        reason = await res.text();
      } catch {
      }
      if (reason === "Repository should not contain documents") {
        throw new Error(`Failed to push documents to repository \`${args.domain}\`, repository is not empty`, {
          cause: reason
        });
      }
      throw new Error(`Failed to push documents to repository \`${args.domain}\`, ${res.status} ${res.statusText}`, {
        cause: reason
      });
    }
  }
  async pushChanges(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    if (!await this.user.checkIsLoggedIn()) {
      throw new errors.UnauthenticatedError();
    }
    try {
      await this.screenshots.initS3ACL();
      const allChanges = await Promise.all(args.changes.map(async (change) => {
        if (change.type === "Slice") {
          switch (change.status) {
            case "NEW": {
              const { model } = await this.slices.readSlice({
                libraryID: change.libraryID,
                sliceID: change.id
              });
              if (!model) {
                throw Error(`Could not find model ${change.id}`);
              }
              const modelWithScreenshots = await this.slices.updateSliceModelScreenshotsInPlace({
                libraryID: change.libraryID,
                model
              });
              return {
                id: change.id,
                payload: modelWithScreenshots,
                type: types.ChangeTypes.SLICE_INSERT
              };
            }
            case "MODIFIED": {
              const { model } = await this.slices.readSlice({
                libraryID: change.libraryID,
                sliceID: change.id
              });
              if (!model) {
                throw Error(`Could not find model ${change.id}`);
              }
              const modelWithScreenshots = await this.slices.updateSliceModelScreenshotsInPlace({
                libraryID: change.libraryID,
                model
              });
              return {
                id: change.id,
                payload: modelWithScreenshots,
                type: types.ChangeTypes.SLICE_UPDATE
              };
            }
            case "DELETED":
              await this.screenshots.deleteScreenshotFolder({
                sliceID: change.id
              });
              return {
                id: change.id,
                payload: { id: change.id },
                type: types.ChangeTypes.SLICE_DELETE
              };
          }
        } else {
          switch (change.status) {
            case "NEW": {
              const { model } = await this.customTypes.readCustomType({
                id: change.id
              });
              if (!model) {
                throw Error(`Could not find model ${change.id}`);
              }
              return {
                type: types.ChangeTypes.CUSTOM_TYPE_INSERT,
                id: change.id,
                payload: model
              };
            }
            case "MODIFIED": {
              const { model } = await this.customTypes.readCustomType({
                id: change.id
              });
              if (!model) {
                throw Error(`Could not find model ${change.id}`);
              }
              return {
                type: types.ChangeTypes.CUSTOM_TYPE_UPDATE,
                id: change.id,
                payload: model
              };
            }
            case "DELETED":
              return {
                id: change.id,
                payload: { id: change.id },
                type: types.ChangeTypes.CUSTOM_TYPE_DELETE
              };
          }
        }
      }));
      const requestBody = {
        confirmDeleteDocuments: args.confirmDeleteDocuments,
        changes: allChanges
      };
      const repositoryName = await this.project.getResolvedRepositoryName();
      const response = await this._fetch({
        url: new URL("./bulk", API_ENDPOINTS.API_ENDPOINTS.PrismicModels),
        method: "POST",
        body: requestBody,
        repository: repositoryName
      });
      switch (response.status) {
        case 202:
          return this._decodeLimitOrThrow(await response.json(), response.status, types.PushChangesLimitType.SOFT);
        case 204:
          return null;
        case 401:
          throw new errors.UnauthenticatedError();
        case 403:
          return this._decodeLimitOrThrow(await response.json(), response.status, types.PushChangesLimitType.HARD);
        case 400:
          const text = await response.text();
          throw new Error(text);
        default:
          throw new Error(`Unexpected status code ${response.status}`, {
            cause: await response.text()
          });
      }
    } catch (err) {
      console.error("An error happened while pushing your changes");
      console.error(err);
      throw err;
    }
  }
  async fetchEnvironments(args) {
    const repositoryName = await this.project.getRepositoryName();
    const url = new URL(`./environments`, API_ENDPOINTS.API_ENDPOINTS.SliceMachineV1);
    url.searchParams.set("repository", repositoryName);
    const res = await this._fetch({ url });
    if (res.ok) {
      const json = await res.json();
      const { value, error } = decode.decode(t__namespace.union([
        t__namespace.type({
          results: t__namespace.array(types.Environment)
        }),
        t__namespace.type({
          error: t__namespace.literal("invalid_token")
        })
      ]), json);
      if (error) {
        throw new errors.UnexpectedDataError(`Failed to decode environments: ${error.errors.join(", ")}`);
      }
      if ("results" in value) {
        let environments = value.results;
        if (!(args == null ? void 0 : args.includeAll)) {
          const profile = await this.user.getProfile();
          environments = environments.filter((environment) => environment.users.some((user) => user.id === profile.shortId));
        }
        return { environments: sortEnvironments.sortEnvironments(environments) };
      }
    }
    switch (res.status) {
      case 400:
      case 401:
        throw new errors.UnauthenticatedError();
      case 403:
        throw new errors.UnauthorizedError();
      default:
        throw new Error("Failed to fetch environments.");
    }
  }
  _decodeLimitOrThrow(potentialLimit, statusCode, limitType) {
    return Either.fold(() => {
      const error = {
        status: statusCode,
        message: `Unable to parse raw limit from ${JSON.stringify(potentialLimit)}`
      };
      throw error;
    }, (rawLimit) => {
      const limit = { ...rawLimit, type: limitType };
      return limit;
    })(types.PushChangesRawLimit.decode(potentialLimit));
  }
  async _fetch(args) {
    let cookies;
    try {
      cookies = await this.user.getAuthenticationCookies();
    } catch (e) {
      if (!args.skipAuthentication) {
        throw e;
      }
    }
    const extraHeaders = {};
    if (args.body) {
      extraHeaders["Content-Type"] = "application/json";
    }
    if (args.repository) {
      extraHeaders.repository = args.repository;
    }
    return await fetch.default(args.url.toString(), {
      method: args.method,
      body: args.body ? JSON.stringify(args.body) : void 0,
      headers: {
        // Some endpoints rely on the authorization header...
        ...cookies !== void 0 ? {
          Authorization: `Bearer ${cookies["prismic-auth"]}`,
          Cookie: serializeCookies.serializeCookies(cookies)
        } : {},
        "User-Agent": args.userAgent || SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT,
        ...extraHeaders
      }
    });
  }
}
exports.PrismicRepositoryManager = PrismicRepositoryManager;
//# sourceMappingURL=PrismicRepositoryManager.cjs.map
