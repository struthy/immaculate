var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as prismicCustomTypesClient from "@prismicio/custom-types-client";
import { createContentDigest } from "../lib/createContentDigest.js";
import { createPrismicAuthManager } from "../auth/createPrismicAuthManager.js";
import { API_ENDPOINTS } from "../constants/API_ENDPOINTS.js";
import { UserManager } from "./user/UserManager.js";
import { PrismicRepositoryManager } from "./prismicRepository/PrismicRepositoryManager.js";
import { PluginsManager } from "./plugins/PluginsManager.js";
import { ProjectManager } from "./project/ProjectManager.js";
import { CustomTypesManager } from "./customTypes/CustomTypesManager.js";
import { SlicesManager } from "./slices/SlicesManager.js";
import { SnippetsManager } from "./snippets/SnippetsManager.js";
import { ScreenshotsManager } from "./screenshots/ScreenshotsManager.js";
import { SimulatorManager } from "./simulator/SimulatorManager.js";
import { VersionsManager } from "./versions/VersionsManager.js";
import { TelemetryManager } from "./telemetry/TelemetryManager.js";
import { buildPrismicRepositoryAPIEndpoint } from "../lib/buildPrismicRepositoryAPIEndpoint.js";
import { DocumentationManager } from "./documentation/DocumentationManager.js";
import { SliceTemplateLibraryManager } from "./sliceTemplateLibrary/SliceTemplateLibraryManager.js";
import { GitManager } from "./git/GitManager.js";
class SliceMachineManager {
  constructor(args) {
    __publicField(this, "_sliceMachinePluginRunner");
    __publicField(this, "_prismicAuthManager");
    __publicField(this, "cwd");
    __publicField(this, "customTypes");
    __publicField(this, "plugins");
    __publicField(this, "prismicRepository");
    __publicField(this, "project");
    __publicField(this, "screenshots");
    __publicField(this, "simulator");
    __publicField(this, "slices");
    __publicField(this, "snippets");
    __publicField(this, "documentation");
    __publicField(this, "sliceTemplateLibrary");
    __publicField(this, "telemetry");
    __publicField(this, "user");
    __publicField(this, "versions");
    __publicField(this, "git");
    this._prismicAuthManager = createPrismicAuthManager();
    this.user = new UserManager(this);
    this.prismicRepository = new PrismicRepositoryManager(this);
    this.plugins = new PluginsManager(this, {
      nativePlugins: args == null ? void 0 : args.nativePlugins
    });
    this.project = new ProjectManager(this);
    this.customTypes = new CustomTypesManager(this);
    this.slices = new SlicesManager(this);
    this.snippets = new SnippetsManager(this);
    this.screenshots = new ScreenshotsManager(this);
    this.simulator = new SimulatorManager(this);
    this.documentation = new DocumentationManager(this);
    this.sliceTemplateLibrary = new SliceTemplateLibraryManager(this);
    this.versions = new VersionsManager(this);
    this.telemetry = new TelemetryManager(this);
    this.git = new GitManager(this);
    this.cwd = (args == null ? void 0 : args.cwd) ?? process.cwd();
  }
  // The `_sliceMachinePluginRunner` property is hidden behind a function to
  // discourage access. Using a function deliberatly breaks the pattern
  // of other child managers that are accessible as properties, like
  // `project`, `plugins`, etc. We do not treat SliceMachinePluginRunner
  // as a child manager.
  getSliceMachinePluginRunner() {
    return this._sliceMachinePluginRunner;
  }
  // The `_prismicAuthManager` property is hidden behind a function to
  // discourage access. Using a function deliberatly breaks the pattern
  // of other child managers that are accessible as properties, like
  // `project`, `plugins`, etc. We do not treat PrismicAuthManager as a
  // child manager.
  getPrismicAuthManager() {
    return this._prismicAuthManager;
  }
  getAPIEndpoints() {
    return API_ENDPOINTS;
  }
  // TODO: Remove this global-state method. It is expensive and a
  // potential source of bugs due to data inconsistency. SM UI relies on
  // it heavily, so removal will require significant effort.
  async getState() {
    const [{ sliceMachineConfig, libraries }, { profile, remoteCustomTypes, remoteSlices, authError }, customTypes, packageManager] = await Promise.all([
      this.project.getSliceMachineConfig().then(async (sliceMachineConfig2) => {
        const libraries2 = await this._getLibraries(sliceMachineConfig2);
        return { sliceMachineConfig: sliceMachineConfig2, libraries: libraries2 };
      }),
      this._getProfile().then(async (profile2) => {
        let authError2;
        if (profile2) {
          try {
            const [remoteCustomTypes2, remoteSlices2] = await Promise.all([
              this.customTypes.fetchRemoteCustomTypes(),
              this.slices.fetchRemoteSlices()
            ]);
            return {
              profile: profile2,
              remoteCustomTypes: remoteCustomTypes2,
              remoteSlices: remoteSlices2,
              authError: authError2
            };
          } catch (error) {
            if (error instanceof prismicCustomTypesClient.ForbiddenError) {
              authError2 = {
                name: "__stub__",
                message: "__stub__",
                reason: "__stub__",
                status: 401
              };
            } else if (error instanceof prismicCustomTypesClient.UnauthorizedError) {
              authError2 = {
                name: "__stub__",
                message: "__stub__",
                reason: "__stub__",
                status: 403
              };
            } else {
              throw error;
            }
          }
        }
        return {
          profile: profile2,
          remoteCustomTypes: [],
          remoteSlices: [],
          authError: authError2
        };
      }),
      this._getCustomTypes(),
      this.project.detectPackageManager()
    ]);
    const clientError = authError || (profile ? void 0 : {
      name: "__stub__",
      message: "__stub__",
      reason: "__stub__",
      status: 401
      // Needed to trigger the unauthorized flow.
    });
    return {
      env: {
        manifest: {
          apiEndpoint: sliceMachineConfig.apiEndpoint || buildPrismicRepositoryAPIEndpoint(sliceMachineConfig.repositoryName),
          localSliceSimulatorURL: sliceMachineConfig.localSliceSimulatorURL
        },
        packageManager,
        repo: sliceMachineConfig.repositoryName,
        intercomHash: profile == null ? void 0 : profile.intercomHash,
        shortId: profile == null ? void 0 : profile.shortId,
        endpoints: this.getAPIEndpoints()
      },
      libraries,
      customTypes,
      remoteCustomTypes,
      remoteSlices,
      clientError
    };
  }
  async _getProfile() {
    let profile;
    const isLoggedIn = await this.user.checkIsLoggedIn();
    if (isLoggedIn) {
      profile = await this.user.getProfile();
      await this.user.refreshAuthenticationToken();
    }
    return profile;
  }
  async _getLibraries(sliceMachineConfig) {
    const libraries = [];
    if (sliceMachineConfig.libraries) {
      await Promise.all(sliceMachineConfig.libraries.map(async (libraryID) => {
        const { sliceIDs } = await this.slices.readSliceLibrary({
          libraryID
        });
        if (sliceIDs) {
          const components = [];
          await Promise.all(sliceIDs.map(async (sliceID) => {
            const [{ model }, { mocks }] = await Promise.all([
              this.slices.readSlice({ libraryID, sliceID }),
              this.slices.readSliceMocks({ libraryID, sliceID })
            ]);
            if (model) {
              const screenshots = {};
              await Promise.all(model.variations.map(async (variation) => {
                const screenshot = await this.slices.readSliceScreenshot({
                  libraryID,
                  sliceID,
                  variationID: variation.id
                });
                if (screenshot.data) {
                  screenshots[variation.id] = {
                    hash: createContentDigest(screenshot.data),
                    data: screenshot.data
                  };
                }
              }));
              components.push({
                from: libraryID,
                href: libraryID.replace(/\//g, "--"),
                pathToSlice: "pathToSlice",
                fileName: "fileName",
                extension: "extension",
                model,
                screenshots,
                mocks
              });
            }
          }));
          libraries.push({
            name: libraryID,
            path: libraryID,
            isLocal: true,
            components,
            meta: {
              // TODO: Do we still support node_modules-based libraries?
              isNodeModule: false,
              isDownloaded: false,
              isManual: true
            }
          });
        }
      }));
    }
    return libraries.sort((library1, library2) => {
      var _a, _b;
      const libraryIndex1 = ((_a = sliceMachineConfig.libraries) == null ? void 0 : _a.indexOf(library1.name)) || 0;
      const libraryIndex2 = ((_b = sliceMachineConfig.libraries) == null ? void 0 : _b.indexOf(library2.name)) || 0;
      return Math.sign(libraryIndex1 - libraryIndex2);
    });
  }
  async _getCustomTypes() {
    const customTypes = [];
    const { ids: customTypeIDs } = await this.customTypes.readCustomTypeLibrary();
    if (customTypeIDs) {
      await Promise.all(customTypeIDs.map(async (customTypeID) => {
        const { model } = await this.customTypes.readCustomType({
          id: customTypeID
        });
        if (model) {
          customTypes.push(model);
        }
      }));
    }
    return customTypes;
  }
}
export {
  SliceMachineManager
};
//# sourceMappingURL=SliceMachineManager.js.map
