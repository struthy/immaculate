import * as t from "io-ts";
import { BaseManager } from "../BaseManager.js";
import { assertPluginsInitialized } from "../../lib/assertPluginsInitialized.js";
import { decodeHookResult } from "../../lib/decodeHookResult.js";
import { SharedSlice } from "@prismicio/types-internal/lib/customtypes";
import { SharedSliceContent } from "@prismicio/types-internal/lib/content";
const readHookCodec = t.type({
  templates: t.array(t.type({
    model: SharedSlice,
    componentContentsTemplate: t.string,
    mocks: t.array(SharedSliceContent),
    screenshots: t.record(t.string, t.any)
  }))
});
const replacePascalNameToReplace = (template, name) => template.replaceAll("PascalNameToReplace", name);
class SliceTemplateLibraryManager extends BaseManager {
  async readLibrary(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice-template-library:read", args);
    const { data, errors } = decodeHookResult(readHookCodec, hookResult);
    return {
      templates: data.flat().flatMap((item) => item.templates.map((t2) => ({
        model: t2.model,
        screenshots: t2.screenshots
      }))),
      errors
    };
  }
  async createSlices(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookReadResult = await this.sliceMachinePluginRunner.callHook("slice-template-library:read", args);
    const { data: readData, errors: readErrors } = decodeHookResult(readHookCodec, hookReadResult);
    const templates = readData.flat().flatMap((item) => item.templates);
    if (readErrors.length > 0) {
      return {
        errors: readErrors
      };
    }
    const { models: allSlices, errors: readAllSlicesErrors } = await this.slices.readAllSlices();
    if (readAllSlicesErrors.length > 0) {
      return {
        errors: readAllSlicesErrors
      };
    }
    const existingIds = allSlices.map((slice) => slice.model.id);
    const getNextAvailableSlice = (baseId) => {
      let nextId = baseId;
      let counter = 1;
      while (existingIds.includes(nextId)) {
        counter++;
        nextId = `${baseId}_${counter}`;
      }
      existingIds.push(nextId);
      return { id: nextId, counter };
    };
    const slicesToCreate = templates.map((template) => {
      const { id, counter } = getNextAvailableSlice(template.model.id);
      return {
        ...template,
        model: {
          ...template.model,
          id,
          name: counter > 1 ? template.model.name + counter : template.model.name
        }
      };
    });
    const { libraries, errors: readAllSliceLibrariesErrors } = await this.slices.readAllSliceLibraries();
    if (readAllSliceLibrariesErrors.length > 0) {
      return {
        errors: readAllSliceLibrariesErrors
      };
    }
    const targetLibrary = libraries[0];
    const creationPromises = slicesToCreate.map((slice) => {
      return this.slices.createSlice({
        libraryID: targetLibrary.libraryID,
        model: slice.model,
        componentContents: replacePascalNameToReplace(slice.componentContentsTemplate, slice.model.name)
      });
    });
    const creationResults = await Promise.all(creationPromises);
    const creationErrors = creationResults.flatMap((result) => result.errors);
    if (creationErrors.length > 0) {
      return {
        errors: creationErrors
      };
    }
    const mocksPromises = slicesToCreate.map((slice) => {
      return this.slices.updateSliceMocks({
        libraryID: targetLibrary.libraryID,
        sliceID: slice.model.id,
        mocks: slice.mocks
      });
    });
    const mocksResults = await Promise.all(mocksPromises);
    const sliceScreenshotsPromises = slicesToCreate.map((slice) => {
      const screenshotPromises = Object.entries(slice.screenshots).map(([variationID, data]) => {
        return this.slices.updateSliceScreenshot({
          libraryID: targetLibrary.libraryID,
          sliceID: slice.model.id,
          variationID,
          data
        });
      });
      return Promise.all(screenshotPromises);
    });
    const sliceScreenshotsResults = await Promise.all(sliceScreenshotsPromises);
    const mocksErrors = mocksResults.flatMap((result) => result.errors);
    const screenshotErrors = sliceScreenshotsResults.flatMap((result) => result.flat().flatMap((r) => r.errors));
    const sliceIDs = slicesToCreate.map((slice) => slice.model.id);
    return {
      errors: [...mocksErrors, ...screenshotErrors],
      data: {
        sliceIDs
      }
    };
  }
}
export {
  SliceTemplateLibraryManager
};
//# sourceMappingURL=SliceTemplateLibraryManager.js.map
