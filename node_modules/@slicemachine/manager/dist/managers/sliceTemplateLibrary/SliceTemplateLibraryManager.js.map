{"version":3,"file":"SliceTemplateLibraryManager.js","sources":["../../../../src/managers/sliceTemplateLibrary/SliceTemplateLibraryManager.ts"],"sourcesContent":["import * as t from \"io-ts\";\nimport { HookError } from \"@slicemachine/plugin-kit\";\nimport { BaseManager } from \"../BaseManager\";\nimport { DecodeError } from \"../../lib/DecodeError\";\nimport { assertPluginsInitialized } from \"../../lib/assertPluginsInitialized\";\nimport { decodeHookResult } from \"../../lib/decodeHookResult\";\nimport { SharedSlice } from \"@prismicio/types-internal/lib/customtypes\";\nimport { SharedSliceContent } from \"@prismicio/types-internal/lib/content\";\n\ntype SliceTemplateLibraryManagerReadLibraryReturnType = {\n\ttemplates: {\n\t\tmodel: SharedSlice;\n\t\tscreenshots: Record<string, Buffer>;\n\t}[];\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SliceTemplateLibraryManagerCreateSlicesReturnType = {\n\tdata?: {\n\t\tsliceIDs: string[];\n\t};\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SliceTemplateLibraryReadLibraryData = {\n\ttemplateIDs?: string[];\n};\n\ntype SliceTemplateLibraryCreateSlicesData = SliceTemplateLibraryReadLibraryData;\n\nconst readHookCodec = t.type({\n\ttemplates: t.array(\n\t\tt.type({\n\t\t\tmodel: SharedSlice,\n\t\t\tcomponentContentsTemplate: t.string,\n\t\t\tmocks: t.array(SharedSliceContent),\n\t\t\tscreenshots: t.record(t.string, t.any),\n\t\t}),\n\t),\n});\n\nconst replacePascalNameToReplace = (template: string, name: string) =>\n\ttemplate.replaceAll(\"PascalNameToReplace\", name);\n\nexport class SliceTemplateLibraryManager extends BaseManager {\n\tasync readLibrary(\n\t\targs: SliceTemplateLibraryReadLibraryData,\n\t): Promise<SliceTemplateLibraryManagerReadLibraryReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice-template-library:read\",\n\t\t\targs,\n\t\t);\n\n\t\tconst { data, errors } = decodeHookResult(readHookCodec, hookResult);\n\n\t\treturn {\n\t\t\ttemplates: data.flat().flatMap((item) =>\n\t\t\t\titem.templates.map((t) => ({\n\t\t\t\t\tmodel: t.model,\n\t\t\t\t\tscreenshots: t.screenshots,\n\t\t\t\t})),\n\t\t\t),\n\t\t\terrors,\n\t\t};\n\t}\n\tasync createSlices(\n\t\targs: SliceTemplateLibraryCreateSlicesData,\n\t): Promise<SliceTemplateLibraryManagerCreateSlicesReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\t// Reading all available slice templates\n\t\tconst hookReadResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice-template-library:read\",\n\t\t\targs,\n\t\t);\n\t\tconst { data: readData, errors: readErrors } = decodeHookResult(\n\t\t\treadHookCodec,\n\t\t\thookReadResult,\n\t\t);\n\t\tconst templates = readData.flat().flatMap((item) => item.templates);\n\t\tif (readErrors.length > 0) {\n\t\t\treturn {\n\t\t\t\terrors: readErrors,\n\t\t\t};\n\t\t}\n\n\t\t// Extract all existing slice IDs into an array\n\t\tconst { models: allSlices, errors: readAllSlicesErrors } =\n\t\t\tawait this.slices.readAllSlices();\n\t\tif (readAllSlicesErrors.length > 0) {\n\t\t\treturn {\n\t\t\t\terrors: readAllSlicesErrors,\n\t\t\t};\n\t\t}\n\t\tconst existingIds: string[] = allSlices.map((slice) => slice.model.id);\n\n\t\t// Create a function to get the next available ID based on the baseId\n\t\tconst getNextAvailableSlice = (baseId: string) => {\n\t\t\tlet nextId = baseId;\n\t\t\tlet counter = 1;\n\t\t\twhile (existingIds.includes(nextId)) {\n\t\t\t\tcounter++;\n\t\t\t\tnextId = `${baseId}_${counter}`;\n\t\t\t}\n\t\t\texistingIds.push(nextId);\n\n\t\t\treturn { id: nextId, counter };\n\t\t};\n\n\t\t// Extract the slices to create from the template ids given in args\n\t\tconst slicesToCreate = templates.map((template) => {\n\t\t\tconst { id, counter } = getNextAvailableSlice(template.model.id);\n\n\t\t\treturn {\n\t\t\t\t...template,\n\t\t\t\tmodel: {\n\t\t\t\t\t...template.model,\n\t\t\t\t\tid,\n\t\t\t\t\tname:\n\t\t\t\t\t\tcounter > 1 ? template.model.name + counter : template.model.name,\n\t\t\t\t},\n\t\t\t};\n\t\t});\n\n\t\t// Get target library\n\t\t// Note: We only support adding template to the first library at the moment\n\t\tconst { libraries, errors: readAllSliceLibrariesErrors } =\n\t\t\tawait this.slices.readAllSliceLibraries();\n\t\tif (readAllSliceLibrariesErrors.length > 0) {\n\t\t\treturn {\n\t\t\t\terrors: readAllSliceLibrariesErrors,\n\t\t\t};\n\t\t}\n\t\tconst targetLibrary = libraries[0];\n\n\t\t// Initiate the slice creation process for all slices\n\t\tconst creationPromises = slicesToCreate.map((slice) => {\n\t\t\treturn this.slices.createSlice({\n\t\t\t\tlibraryID: targetLibrary.libraryID,\n\t\t\t\tmodel: slice.model,\n\t\t\t\tcomponentContents: replacePascalNameToReplace(\n\t\t\t\t\tslice.componentContentsTemplate,\n\t\t\t\t\tslice.model.name,\n\t\t\t\t),\n\t\t\t});\n\t\t});\n\n\t\t// Wait for all slices to be created\n\t\tconst creationResults = await Promise.all(creationPromises);\n\t\t// Check for any errors in the creation results\n\t\tconst creationErrors = creationResults.flatMap((result) => result.errors);\n\t\tif (creationErrors.length > 0) {\n\t\t\treturn {\n\t\t\t\terrors: creationErrors,\n\t\t\t};\n\t\t}\n\n\t\tconst mocksPromises = slicesToCreate.map((slice) => {\n\t\t\treturn this.slices.updateSliceMocks({\n\t\t\t\tlibraryID: targetLibrary.libraryID,\n\t\t\t\tsliceID: slice.model.id,\n\t\t\t\tmocks: slice.mocks,\n\t\t\t});\n\t\t});\n\n\t\tconst mocksResults = await Promise.all(mocksPromises);\n\n\t\tconst sliceScreenshotsPromises = slicesToCreate.map((slice) => {\n\t\t\tconst screenshotPromises = Object.entries(slice.screenshots).map(\n\t\t\t\t([variationID, data]) => {\n\t\t\t\t\treturn this.slices.updateSliceScreenshot({\n\t\t\t\t\t\tlibraryID: targetLibrary.libraryID,\n\t\t\t\t\t\tsliceID: slice.model.id,\n\t\t\t\t\t\tvariationID,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t);\n\n\t\t\treturn Promise.all(screenshotPromises);\n\t\t});\n\n\t\tconst sliceScreenshotsResults = await Promise.all(sliceScreenshotsPromises);\n\t\tconst mocksErrors = mocksResults.flatMap((result) => result.errors);\n\t\tconst screenshotErrors = sliceScreenshotsResults.flatMap((result) =>\n\t\t\tresult.flat().flatMap((r) => r.errors),\n\t\t);\n\n\t\t// Extract the slice IDs from the creation results (assuming each result has an ID)\n\t\tconst sliceIDs = slicesToCreate.map((slice) => slice.model.id);\n\n\t\treturn {\n\t\t\terrors: [...mocksErrors, ...screenshotErrors],\n\t\t\tdata: {\n\t\t\t\tsliceIDs,\n\t\t\t},\n\t\t};\n\t}\n}\n"],"names":["t"],"mappings":"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"}