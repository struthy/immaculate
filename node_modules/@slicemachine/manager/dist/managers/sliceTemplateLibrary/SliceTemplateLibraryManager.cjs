"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("io-ts");
const BaseManager = require("../BaseManager.cjs");
const assertPluginsInitialized = require("../../lib/assertPluginsInitialized.cjs");
const decodeHookResult = require("../../lib/decodeHookResult.cjs");
const customtypes = require("@prismicio/types-internal/lib/customtypes");
const content = require("@prismicio/types-internal/lib/content");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const readHookCodec = t__namespace.type({
  templates: t__namespace.array(t__namespace.type({
    model: customtypes.SharedSlice,
    componentContentsTemplate: t__namespace.string,
    mocks: t__namespace.array(content.SharedSliceContent),
    screenshots: t__namespace.record(t__namespace.string, t__namespace.any)
  }))
});
const replacePascalNameToReplace = (template, name) => template.replaceAll("PascalNameToReplace", name);
class SliceTemplateLibraryManager extends BaseManager.BaseManager {
  async readLibrary(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice-template-library:read", args);
    const { data, errors } = decodeHookResult.decodeHookResult(readHookCodec, hookResult);
    return {
      templates: data.flat().flatMap((item) => item.templates.map((t2) => ({
        model: t2.model,
        screenshots: t2.screenshots
      }))),
      errors
    };
  }
  async createSlices(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookReadResult = await this.sliceMachinePluginRunner.callHook("slice-template-library:read", args);
    const { data: readData, errors: readErrors } = decodeHookResult.decodeHookResult(readHookCodec, hookReadResult);
    const templates = readData.flat().flatMap((item) => item.templates);
    if (readErrors.length > 0) {
      return {
        errors: readErrors
      };
    }
    const { models: allSlices, errors: readAllSlicesErrors } = await this.slices.readAllSlices();
    if (readAllSlicesErrors.length > 0) {
      return {
        errors: readAllSlicesErrors
      };
    }
    const existingIds = allSlices.map((slice) => slice.model.id);
    const getNextAvailableSlice = (baseId) => {
      let nextId = baseId;
      let counter = 1;
      while (existingIds.includes(nextId)) {
        counter++;
        nextId = `${baseId}_${counter}`;
      }
      existingIds.push(nextId);
      return { id: nextId, counter };
    };
    const slicesToCreate = templates.map((template) => {
      const { id, counter } = getNextAvailableSlice(template.model.id);
      return {
        ...template,
        model: {
          ...template.model,
          id,
          name: counter > 1 ? template.model.name + counter : template.model.name
        }
      };
    });
    const { libraries, errors: readAllSliceLibrariesErrors } = await this.slices.readAllSliceLibraries();
    if (readAllSliceLibrariesErrors.length > 0) {
      return {
        errors: readAllSliceLibrariesErrors
      };
    }
    const targetLibrary = libraries[0];
    const creationPromises = slicesToCreate.map((slice) => {
      return this.slices.createSlice({
        libraryID: targetLibrary.libraryID,
        model: slice.model,
        componentContents: replacePascalNameToReplace(slice.componentContentsTemplate, slice.model.name)
      });
    });
    const creationResults = await Promise.all(creationPromises);
    const creationErrors = creationResults.flatMap((result) => result.errors);
    if (creationErrors.length > 0) {
      return {
        errors: creationErrors
      };
    }
    const mocksPromises = slicesToCreate.map((slice) => {
      return this.slices.updateSliceMocks({
        libraryID: targetLibrary.libraryID,
        sliceID: slice.model.id,
        mocks: slice.mocks
      });
    });
    const mocksResults = await Promise.all(mocksPromises);
    const sliceScreenshotsPromises = slicesToCreate.map((slice) => {
      const screenshotPromises = Object.entries(slice.screenshots).map(([variationID, data]) => {
        return this.slices.updateSliceScreenshot({
          libraryID: targetLibrary.libraryID,
          sliceID: slice.model.id,
          variationID,
          data
        });
      });
      return Promise.all(screenshotPromises);
    });
    const sliceScreenshotsResults = await Promise.all(sliceScreenshotsPromises);
    const mocksErrors = mocksResults.flatMap((result) => result.errors);
    const screenshotErrors = sliceScreenshotsResults.flatMap((result) => result.flat().flatMap((r) => r.errors));
    const sliceIDs = slicesToCreate.map((slice) => slice.model.id);
    return {
      errors: [...mocksErrors, ...screenshotErrors],
      data: {
        sliceIDs
      }
    };
  }
}
exports.SliceTemplateLibraryManager = SliceTemplateLibraryManager;
//# sourceMappingURL=SliceTemplateLibraryManager.cjs.map
