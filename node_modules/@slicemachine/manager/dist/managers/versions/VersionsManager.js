var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as fs from "node:fs/promises";
import * as path from "node:path";
import semver from "semver";
import { decodePackageJSON } from "../../lib/decodePackageJSON.js";
import { fetchGitHubReleaseBodyForRelease } from "../../lib/fetchGitHubReleaseBodyForRelease.js";
import { fetchNPMPackageVersions } from "../../lib/fetchNPMPackageVersions.js";
import { SLICE_MACHINE_GITHUB_PACKAGE_NAME } from "../../constants/SLICE_MACHINE_GITHUB_PACKAGE_NAME.js";
import { SLICE_MACHINE_GITHUB_REPOSITORY_NAME } from "../../constants/SLICE_MACHINE_GITHUB_REPOSITORY_NAME.js";
import { SLICE_MACHINE_GITHUB_REPOSITORY_ORGANIZATION } from "../../constants/SLICE_MACHINE_GITHUB_REPOSITORY_ORGANIZATION.js";
import { SLICE_MACHINE_NPM_PACKAGE_NAME } from "../../constants/SLICE_MACHINE_NPM_PACKAGE_NAME.js";
import { VERSION_KIND } from "../../constants/VERSION_KIND.js";
import { BaseManager } from "../BaseManager.js";
const detectVersionBumpKind = (to, from) => {
  if (!from) {
    return VERSION_KIND.FIRST;
  }
  if (semver.eq(to, from)) {
    return void 0;
  } else if (semver.satisfies(to, `~${from}`)) {
    return VERSION_KIND.PATCH;
  } else if (semver.satisfies(to, `^${from}`)) {
    return VERSION_KIND.MINOR;
  } else {
    return VERSION_KIND.MAJOR;
  }
};
const filterStableVersions = (versions) => {
  return versions.filter((version) => {
    return /^[1-9]\d*\.\d+\.\d+$/.test(version) || /^\d+\.[1-9]\d*\.\d+$/.test(version);
  });
};
const readPackageJSON = async (packageDir) => {
  const packageJSONContents = await fs.readFile(path.join(packageDir, "package.json"), "utf8");
  let packageJSON;
  try {
    packageJSON = JSON.parse(packageJSONContents);
  } catch {
  }
  const { value, error } = decodePackageJSON(packageJSON);
  if (error) {
    throw new Error(`Invalid ${packageDir} \`package.json\` file. ${error.errors.join(", ")}`);
  }
  return value;
};
class VersionsManager extends BaseManager {
  constructor() {
    super(...arguments);
    /**
     * Record of version numbers mapped to their GitHub release metadata.
     */
    __publicField(this, "gitHubSliceMachineReleaseMetadataCache", {});
  }
  async getRunningSliceMachineVersion() {
    const sliceMachineDir = await this.project.locateSliceMachineUIDir();
    const packageJSON = await readPackageJSON(sliceMachineDir);
    return packageJSON.version;
  }
  async getAllStableSliceMachineVersions() {
    const versions = await fetchNPMPackageVersions({
      packageName: SLICE_MACHINE_NPM_PACKAGE_NAME
    });
    const filteredVersions = filterStableVersions(versions);
    return semver.rsort(filteredVersions);
  }
  async getAllStableSliceMachineVersionsWithKind() {
    const versions = await this.getAllStableSliceMachineVersions();
    return versions.map((version, i) => {
      const previousVersion = versions[i + 1];
      return {
        version,
        kind: detectVersionBumpKind(version, previousVersion)
      };
    });
  }
  async getLatestNonBreakingSliceMachineVersion() {
    const versions = await this.getAllStableSliceMachineVersions();
    const currentVersion = await this.getRunningSliceMachineVersion();
    return semver.maxSatisfying(versions, `^${currentVersion}`) ?? void 0;
  }
  async checkIsSliceMachineUpdateAvailable() {
    const versions = await this.getAllStableSliceMachineVersions();
    const currentVersion = await this.getRunningSliceMachineVersion();
    return semver.gt(versions[0], currentVersion);
  }
  async getRunningAdapterVersion() {
    const adapterDir = await this.project.locateAdapterDir();
    const value = await readPackageJSON(adapterDir);
    return value.version;
  }
  async getAllStableAdapterVersions() {
    const adapterName = await this.project.getAdapterName();
    const versions = await fetchNPMPackageVersions({
      packageName: adapterName
    });
    const filteredVersions = filterStableVersions(versions);
    return semver.rsort(filteredVersions);
  }
  async checkIsAdapterUpdateAvailable() {
    const versions = await this.getAllStableAdapterVersions();
    const currentVersion = await this.getRunningAdapterVersion();
    return semver.gt(versions[0], currentVersion);
  }
  async getSliceMachineReleaseNotesForVersion(args) {
    return await fetchGitHubReleaseBodyForRelease({
      repositoryOwner: SLICE_MACHINE_GITHUB_REPOSITORY_ORGANIZATION,
      repositoryName: SLICE_MACHINE_GITHUB_REPOSITORY_NAME,
      packageName: SLICE_MACHINE_GITHUB_PACKAGE_NAME,
      version: args.version,
      cache: this.gitHubSliceMachineReleaseMetadataCache
    });
  }
}
export {
  VersionsManager
};
//# sourceMappingURL=VersionsManager.js.map
