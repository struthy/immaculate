{"version":3,"file":"VersionsManager.js","sources":["../../../../src/managers/versions/VersionsManager.ts"],"sourcesContent":["import * as fs from \"node:fs/promises\";\nimport * as path from \"node:path\";\nimport semver from \"semver\";\n\nimport { decodePackageJSON } from \"../../lib/decodePackageJSON\";\nimport {\n\tfetchGitHubReleaseBodyForRelease,\n\tGitHubReleaseMetadata,\n} from \"../../lib/fetchGitHubReleaseBodyForRelease\";\nimport { fetchNPMPackageVersions } from \"../../lib/fetchNPMPackageVersions\";\n\nimport { SLICE_MACHINE_GITHUB_PACKAGE_NAME } from \"../../constants/SLICE_MACHINE_GITHUB_PACKAGE_NAME\";\nimport { SLICE_MACHINE_GITHUB_REPOSITORY_NAME } from \"../../constants/SLICE_MACHINE_GITHUB_REPOSITORY_NAME\";\nimport { SLICE_MACHINE_GITHUB_REPOSITORY_ORGANIZATION } from \"../../constants/SLICE_MACHINE_GITHUB_REPOSITORY_ORGANIZATION\";\nimport { SLICE_MACHINE_NPM_PACKAGE_NAME } from \"../../constants/SLICE_MACHINE_NPM_PACKAGE_NAME\";\nimport { VERSION_KIND } from \"../../constants/VERSION_KIND\";\n\nimport { BaseManager } from \"../BaseManager\";\n\nimport { Version } from \"./types\";\n\nconst detectVersionBumpKind = (\n\tto: string,\n\tfrom?: string,\n): (typeof VERSION_KIND)[keyof typeof VERSION_KIND] | undefined => {\n\tif (!from) {\n\t\treturn VERSION_KIND.FIRST;\n\t}\n\n\tif (semver.eq(to, from)) {\n\t\treturn undefined;\n\t} else if (semver.satisfies(to, `~${from}`)) {\n\t\treturn VERSION_KIND.PATCH;\n\t} else if (semver.satisfies(to, `^${from}`)) {\n\t\treturn VERSION_KIND.MINOR;\n\t} else {\n\t\treturn VERSION_KIND.MAJOR;\n\t}\n};\n\nconst filterStableVersions = (versions: string[]): string[] => {\n\treturn versions.filter((version) => {\n\t\t// Exclude tagged versions (e.g. `1.0.0-alpha.0`).\n\t\t// Exclude versions < 0.1.0 (e.g. `0.0.1`).\n\t\treturn (\n\t\t\t/^[1-9]\\d*\\.\\d+\\.\\d+$/.test(version) ||\n\t\t\t/^\\d+\\.[1-9]\\d*\\.\\d+$/.test(version)\n\t\t);\n\t});\n};\n\nconst readPackageJSON = async (packageDir: string) => {\n\tconst packageJSONContents = await fs.readFile(\n\t\tpath.join(packageDir, \"package.json\"),\n\t\t\"utf8\",\n\t);\n\n\tlet packageJSON: unknown;\n\ttry {\n\t\tpackageJSON = JSON.parse(packageJSONContents);\n\t} catch {\n\t\t// noop\n\t}\n\n\tconst { value, error } = decodePackageJSON(packageJSON);\n\n\tif (error) {\n\t\tthrow new Error(\n\t\t\t`Invalid ${packageDir} \\`package.json\\` file. ${error.errors.join(\", \")}`,\n\t\t);\n\t}\n\n\treturn value;\n};\n\ntype SliceMachineManagerGetReleaseNotesForVersionArgs = {\n\tversion: string;\n};\n\nexport class VersionsManager extends BaseManager {\n\t/**\n\t * Record of version numbers mapped to their GitHub release metadata.\n\t */\n\tgitHubSliceMachineReleaseMetadataCache: Record<\n\t\tstring,\n\t\tGitHubReleaseMetadata | undefined\n\t> = {};\n\n\tasync getRunningSliceMachineVersion(): Promise<string> {\n\t\tconst sliceMachineDir = await this.project.locateSliceMachineUIDir();\n\t\tconst packageJSON = await readPackageJSON(sliceMachineDir);\n\n\t\treturn packageJSON.version;\n\t}\n\n\tasync getAllStableSliceMachineVersions(): Promise<string[]> {\n\t\tconst versions = await fetchNPMPackageVersions({\n\t\t\tpackageName: SLICE_MACHINE_NPM_PACKAGE_NAME,\n\t\t});\n\t\tconst filteredVersions = filterStableVersions(versions);\n\n\t\treturn semver.rsort(filteredVersions);\n\t}\n\n\tasync getAllStableSliceMachineVersionsWithKind(): Promise<Version[]> {\n\t\tconst versions = await this.getAllStableSliceMachineVersions();\n\n\t\treturn versions.map((version, i) => {\n\t\t\tconst previousVersion = versions[i + 1];\n\n\t\t\treturn {\n\t\t\t\tversion,\n\t\t\t\tkind: detectVersionBumpKind(version, previousVersion),\n\t\t\t};\n\t\t});\n\t}\n\n\tasync getLatestNonBreakingSliceMachineVersion(): Promise<string | undefined> {\n\t\tconst versions = await this.getAllStableSliceMachineVersions();\n\t\tconst currentVersion = await this.getRunningSliceMachineVersion();\n\n\t\treturn semver.maxSatisfying(versions, `^${currentVersion}`) ?? undefined;\n\t}\n\n\tasync checkIsSliceMachineUpdateAvailable(): Promise<boolean> {\n\t\tconst versions = await this.getAllStableSliceMachineVersions();\n\t\tconst currentVersion = await this.getRunningSliceMachineVersion();\n\n\t\treturn semver.gt(versions[0], currentVersion);\n\t}\n\n\tasync getRunningAdapterVersion(): Promise<string> {\n\t\tconst adapterDir = await this.project.locateAdapterDir();\n\t\tconst value = await readPackageJSON(adapterDir);\n\n\t\treturn value.version;\n\t}\n\n\tasync getAllStableAdapterVersions(): Promise<string[]> {\n\t\tconst adapterName = await this.project.getAdapterName();\n\t\tconst versions = await fetchNPMPackageVersions({\n\t\t\tpackageName: adapterName,\n\t\t});\n\t\tconst filteredVersions = filterStableVersions(versions);\n\n\t\treturn semver.rsort(filteredVersions);\n\t}\n\n\tasync checkIsAdapterUpdateAvailable(): Promise<boolean> {\n\t\tconst versions = await this.getAllStableAdapterVersions();\n\t\tconst currentVersion = await this.getRunningAdapterVersion();\n\n\t\treturn semver.gt(versions[0], currentVersion);\n\t}\n\n\tasync getSliceMachineReleaseNotesForVersion(\n\t\targs: SliceMachineManagerGetReleaseNotesForVersionArgs,\n\t): Promise<string | undefined> {\n\t\treturn await fetchGitHubReleaseBodyForRelease({\n\t\t\trepositoryOwner: SLICE_MACHINE_GITHUB_REPOSITORY_ORGANIZATION,\n\t\t\trepositoryName: SLICE_MACHINE_GITHUB_REPOSITORY_NAME,\n\t\t\tpackageName: SLICE_MACHINE_GITHUB_PACKAGE_NAME,\n\t\t\tversion: args.version,\n\t\t\tcache: this.gitHubSliceMachineReleaseMetadataCache,\n\t\t});\n\t}\n}\n"],"names":[],"mappings":"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"}