"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const fs = require("node:fs/promises");
const path = require("node:path");
const semver = require("semver");
const decodePackageJSON = require("../../lib/decodePackageJSON.cjs");
const fetchGitHubReleaseBodyForRelease = require("../../lib/fetchGitHubReleaseBodyForRelease.cjs");
const fetchNPMPackageVersions = require("../../lib/fetchNPMPackageVersions.cjs");
const SLICE_MACHINE_GITHUB_PACKAGE_NAME = require("../../constants/SLICE_MACHINE_GITHUB_PACKAGE_NAME.cjs");
const SLICE_MACHINE_GITHUB_REPOSITORY_NAME = require("../../constants/SLICE_MACHINE_GITHUB_REPOSITORY_NAME.cjs");
const SLICE_MACHINE_GITHUB_REPOSITORY_ORGANIZATION = require("../../constants/SLICE_MACHINE_GITHUB_REPOSITORY_ORGANIZATION.cjs");
const SLICE_MACHINE_NPM_PACKAGE_NAME = require("../../constants/SLICE_MACHINE_NPM_PACKAGE_NAME.cjs");
const VERSION_KIND = require("../../constants/VERSION_KIND.cjs");
const BaseManager = require("../BaseManager.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs);
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
const detectVersionBumpKind = (to, from) => {
  if (!from) {
    return VERSION_KIND.VERSION_KIND.FIRST;
  }
  if (semver.eq(to, from)) {
    return void 0;
  } else if (semver.satisfies(to, `~${from}`)) {
    return VERSION_KIND.VERSION_KIND.PATCH;
  } else if (semver.satisfies(to, `^${from}`)) {
    return VERSION_KIND.VERSION_KIND.MINOR;
  } else {
    return VERSION_KIND.VERSION_KIND.MAJOR;
  }
};
const filterStableVersions = (versions) => {
  return versions.filter((version) => {
    return /^[1-9]\d*\.\d+\.\d+$/.test(version) || /^\d+\.[1-9]\d*\.\d+$/.test(version);
  });
};
const readPackageJSON = async (packageDir) => {
  const packageJSONContents = await fs__namespace.readFile(path__namespace.join(packageDir, "package.json"), "utf8");
  let packageJSON;
  try {
    packageJSON = JSON.parse(packageJSONContents);
  } catch {
  }
  const { value, error } = decodePackageJSON.decodePackageJSON(packageJSON);
  if (error) {
    throw new Error(`Invalid ${packageDir} \`package.json\` file. ${error.errors.join(", ")}`);
  }
  return value;
};
class VersionsManager extends BaseManager.BaseManager {
  constructor() {
    super(...arguments);
    /**
     * Record of version numbers mapped to their GitHub release metadata.
     */
    __publicField(this, "gitHubSliceMachineReleaseMetadataCache", {});
  }
  async getRunningSliceMachineVersion() {
    const sliceMachineDir = await this.project.locateSliceMachineUIDir();
    const packageJSON = await readPackageJSON(sliceMachineDir);
    return packageJSON.version;
  }
  async getAllStableSliceMachineVersions() {
    const versions = await fetchNPMPackageVersions.fetchNPMPackageVersions({
      packageName: SLICE_MACHINE_NPM_PACKAGE_NAME.SLICE_MACHINE_NPM_PACKAGE_NAME
    });
    const filteredVersions = filterStableVersions(versions);
    return semver.rsort(filteredVersions);
  }
  async getAllStableSliceMachineVersionsWithKind() {
    const versions = await this.getAllStableSliceMachineVersions();
    return versions.map((version, i) => {
      const previousVersion = versions[i + 1];
      return {
        version,
        kind: detectVersionBumpKind(version, previousVersion)
      };
    });
  }
  async getLatestNonBreakingSliceMachineVersion() {
    const versions = await this.getAllStableSliceMachineVersions();
    const currentVersion = await this.getRunningSliceMachineVersion();
    return semver.maxSatisfying(versions, `^${currentVersion}`) ?? void 0;
  }
  async checkIsSliceMachineUpdateAvailable() {
    const versions = await this.getAllStableSliceMachineVersions();
    const currentVersion = await this.getRunningSliceMachineVersion();
    return semver.gt(versions[0], currentVersion);
  }
  async getRunningAdapterVersion() {
    const adapterDir = await this.project.locateAdapterDir();
    const value = await readPackageJSON(adapterDir);
    return value.version;
  }
  async getAllStableAdapterVersions() {
    const adapterName = await this.project.getAdapterName();
    const versions = await fetchNPMPackageVersions.fetchNPMPackageVersions({
      packageName: adapterName
    });
    const filteredVersions = filterStableVersions(versions);
    return semver.rsort(filteredVersions);
  }
  async checkIsAdapterUpdateAvailable() {
    const versions = await this.getAllStableAdapterVersions();
    const currentVersion = await this.getRunningAdapterVersion();
    return semver.gt(versions[0], currentVersion);
  }
  async getSliceMachineReleaseNotesForVersion(args) {
    return await fetchGitHubReleaseBodyForRelease.fetchGitHubReleaseBodyForRelease({
      repositoryOwner: SLICE_MACHINE_GITHUB_REPOSITORY_ORGANIZATION.SLICE_MACHINE_GITHUB_REPOSITORY_ORGANIZATION,
      repositoryName: SLICE_MACHINE_GITHUB_REPOSITORY_NAME.SLICE_MACHINE_GITHUB_REPOSITORY_NAME,
      packageName: SLICE_MACHINE_GITHUB_PACKAGE_NAME.SLICE_MACHINE_GITHUB_PACKAGE_NAME,
      version: args.version,
      cache: this.gitHubSliceMachineReleaseMetadataCache
    });
  }
}
exports.VersionsManager = VersionsManager;
//# sourceMappingURL=VersionsManager.cjs.map
