{"version":3,"file":"SlicesManager.js","sources":["../../../../src/managers/slices/SlicesManager.ts"],"sourcesContent":["import * as t from \"io-ts\";\nimport * as prismicCustomTypesClient from \"@prismicio/custom-types-client\";\nimport { SharedSliceContent } from \"@prismicio/types-internal/lib/content\";\nimport { SliceComparator } from \"@prismicio/types-internal/lib/customtypes/diff\";\nimport {\n\tCompositeSlice,\n\tLegacySlice,\n\tSharedSlice,\n\tVariation,\n} from \"@prismicio/types-internal/lib/customtypes\";\nimport {\n\tCallHookReturnType,\n\tHookError,\n\tSliceAssetUpdateHook,\n\tSliceCreateHook,\n\tSliceCreateHookData,\n\tSliceLibraryReadHookData,\n\tSliceReadHookData,\n\tSliceRenameHook,\n\tSliceRenameHookData,\n\tSliceUpdateHook,\n} from \"@slicemachine/plugin-kit\";\n\nimport { DecodeError } from \"../../lib/DecodeError\";\nimport { assertPluginsInitialized } from \"../../lib/assertPluginsInitialized\";\nimport { bufferCodec } from \"../../lib/bufferCodec\";\nimport { decodeHookResult } from \"../../lib/decodeHookResult\";\nimport { createContentDigest } from \"../../lib/createContentDigest\";\nimport { mockSlice } from \"../../lib/mockSlice\";\nimport fetch from \"../../lib/fetch\";\n\nimport { OnlyHookErrors } from \"../../types\";\nimport { DEFAULT_SLICE_SCREENSHOT_URL } from \"../../constants/DEFAULT_SLICE_SCREENSHOT_URL\";\nimport { SLICE_MACHINE_USER_AGENT } from \"../../constants/SLICE_MACHINE_USER_AGENT\";\nimport { API_ENDPOINTS } from \"../../constants/API_ENDPOINTS\";\nimport { UnauthenticatedError, UnauthorizedError } from \"../../errors\";\n\nimport { BaseManager } from \"../BaseManager\";\n\ntype SlicesManagerReadSliceLibraryReturnType = {\n\tsliceIDs: string[];\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SlicesManagerReadAllSliceLibrariesReturnType = {\n\tlibraries: {\n\t\tlibraryID: string;\n\t\tsliceIDs: string[] | undefined;\n\t}[];\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SliceMachineManagerReadAllSlicesForLibraryArgs = {\n\tlibraryID: string;\n};\n\ntype SliceMachineManagerUpdateSliceArgs = {\n\tlibraryID: string;\n\tmodel: SharedSlice;\n\tmocks?: SharedSliceContent[];\n};\n\ntype SliceMachineManagerReadAllSlicesForLibraryReturnType = {\n\tmodels: { model: SharedSlice }[];\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SliceMachineManagerReadAllSlicesReturnType = {\n\tmodels: {\n\t\tlibraryID: string;\n\t\tmodel: SharedSlice;\n\t}[];\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SliceMachineManagerReadSliceReturnType = {\n\tmodel: SharedSlice | undefined;\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SliceMachineManagerPushSliceArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n\tuserAgent?: string;\n};\n\nexport type SliceMachineManagerPushSliceReturnType = {\n\t/**\n\t * A record of Slice variation IDs mapped to uploaded screenshot URLs.\n\t */\n\tscreenshotURLs: Record<string, string> | undefined;\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SliceMachineManagerReadSliceScreenshotArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n\tvariationID: string;\n};\n\ntype SliceMachineManagerReadSliceScreenshotReturnType = {\n\tdata: Buffer | undefined;\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SliceMachineManagerUpdateSliceScreenshotArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n\tvariationID: string;\n\tdata: Buffer;\n};\n\ntype SliceMachineManagerDeleteSliceScreenshotArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n\tvariationID: string;\n};\n\ntype SliceMachineManagerReadSliceMocksArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n};\n\ntype SliceMachineManagerReadSliceMocksReturnType = {\n\tmocks?: SharedSliceContent[];\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SliceMachineManagerReadSliceMocksConfigArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n};\n\ntype SliceMachineManagerReadSliceMocksConfigArgsReturnType = {\n\t// TODO\n\tmocksConfig?: Record<string, unknown>;\n\terrors: HookError[];\n};\n\ntype SliceMachineManagerUpdateSliceMocksArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n\tmocks: SharedSliceContent[];\n};\n\ntype SliceMachineManagerUpdateSliceMocksArgsReturnType = {\n\terrors: HookError[];\n};\n\ntype SlicesManagerUpsertHostedSliceScrenshotsArgs = {\n\tlibraryID: string;\n\tmodel: SharedSlice;\n};\n\ntype SliceMachineManagerDeleteSliceArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n};\n\ntype SliceMachineManagerDeleteSliceReturnType = {\n\terrors: (DecodeError | HookError)[];\n};\n\ntype SliceMachineManagerRenameSliceVariationArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n\t/**\n\t * Current ID of the variation to rename.\n\t */\n\tvariationID: string;\n\tmodel: Variation;\n};\n\ntype SliceMachineManagerRenameSliceVariationReturnType = {\n\terrors: (DecodeError | HookError)[];\n\tassetsErrors: (DecodeError | HookError)[];\n};\n\ntype SliceMachineManagerDeleteSliceVariationArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n\tvariationID: string;\n};\n\ntype SliceMachineManagerDeleteSliceVariationReturnType = {\n\terrors: (DecodeError | HookError)[];\n\tassetsErrors: (DecodeError | HookError)[];\n};\n\ntype SliceMachineManagerConvertLegacySliceToSharedSliceArgs = {\n\tmodel: CompositeSlice | LegacySlice;\n\tsrc: {\n\t\tcustomTypeID: string;\n\t\ttabID: string;\n\t\tsliceZoneID: string;\n\t\tsliceID: string;\n\t};\n\tdest: {\n\t\tlibraryID: string;\n\t\tsliceID: string;\n\t\tvariationName: string;\n\t\tvariationID: string;\n\t};\n};\n\ntype SliceMachineManagerConvertLegacySliceToSharedSliceReturnType = {\n\terrors: (DecodeError | HookError)[];\n};\n\nexport class SlicesManager extends BaseManager {\n\tasync readSliceLibrary(\n\t\targs: SliceLibraryReadHookData,\n\t): Promise<SlicesManagerReadSliceLibraryReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\t// TODO: Should validation happen at the `callHook` level?\n\t\t// Including validation at the hook level would ensure\n\t\t// hook-based actions are validated.\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice-library:read\",\n\t\t\targs,\n\t\t);\n\t\tconst { data, errors } = decodeHookResult(\n\t\t\tt.type({\n\t\t\t\tid: t.string,\n\t\t\t\tsliceIDs: t.array(t.string),\n\t\t\t}),\n\t\t\thookResult,\n\t\t);\n\n\t\treturn {\n\t\t\tsliceIDs: data[0]?.sliceIDs ?? [],\n\t\t\terrors: errors,\n\t\t};\n\t}\n\n\tasync readAllSliceLibraries(): Promise<SlicesManagerReadAllSliceLibrariesReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst sliceMachineConfig = await this.project.getSliceMachineConfig();\n\t\tconst libraryIDs = sliceMachineConfig.libraries || [];\n\n\t\tconst res: SlicesManagerReadAllSliceLibrariesReturnType = {\n\t\t\tlibraries: [],\n\t\t\terrors: [],\n\t\t};\n\n\t\tfor (const libraryID of libraryIDs) {\n\t\t\tconst { sliceIDs, errors } = await this.readSliceLibrary({\n\t\t\t\tlibraryID,\n\t\t\t});\n\t\t\tres.errors = [...res.errors, ...errors];\n\n\t\t\tres.libraries.push({\n\t\t\t\tlibraryID,\n\t\t\t\tsliceIDs,\n\t\t\t});\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tasync readAllSlicesForLibrary(\n\t\targs: SliceMachineManagerReadAllSlicesForLibraryArgs,\n\t): Promise<SliceMachineManagerReadAllSlicesForLibraryReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst res: SliceMachineManagerReadAllSlicesForLibraryReturnType = {\n\t\t\tmodels: [],\n\t\t\terrors: [],\n\t\t};\n\n\t\tconst { sliceIDs, errors } = await this.readSliceLibrary({\n\t\t\tlibraryID: args.libraryID,\n\t\t});\n\t\tres.errors.push(...errors);\n\n\t\tif (sliceIDs) {\n\t\t\tfor (const sliceID of sliceIDs) {\n\t\t\t\tconst { model, errors } = await this.readSlice({\n\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\tsliceID,\n\t\t\t\t});\n\t\t\t\tres.errors.push(...errors);\n\n\t\t\t\tif (model) {\n\t\t\t\t\tres.models.push({ model });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tasync readAllSlices(): Promise<SliceMachineManagerReadAllSlicesReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst sliceMachineConfig = await this.project.getSliceMachineConfig();\n\t\tconst libraryIDs = sliceMachineConfig.libraries || [];\n\n\t\tconst res: SliceMachineManagerReadAllSlicesReturnType = {\n\t\t\tmodels: [],\n\t\t\terrors: [],\n\t\t};\n\n\t\tfor (const libraryID of libraryIDs) {\n\t\t\tconst { models, errors } = await this.readAllSlicesForLibrary({\n\t\t\t\tlibraryID,\n\t\t\t});\n\t\t\tres.errors.push(...errors);\n\n\t\t\tfor (const model of models) {\n\t\t\t\tres.models.push({\n\t\t\t\t\tlibraryID,\n\t\t\t\t\tmodel: model.model,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tasync createSlice(\n\t\targs: SliceCreateHookData,\n\t): Promise<OnlyHookErrors<CallHookReturnType<SliceCreateHook>>> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice:create\",\n\t\t\targs,\n\t\t);\n\n\t\tconst updateSliceMocksArgs: SliceMachineManagerUpdateSliceMocksArgs = {\n\t\t\tlibraryID: args.libraryID,\n\t\t\tsliceID: args.model.id,\n\t\t\tmocks: mockSlice({ model: args.model }),\n\t\t};\n\n\t\tconst { errors: updateSliceHookErrors } =\n\t\t\tawait this.updateSliceMocks(updateSliceMocksArgs);\n\n\t\treturn {\n\t\t\terrors: [...hookResult.errors, ...updateSliceHookErrors],\n\t\t};\n\t}\n\n\tasync readSlice(\n\t\targs: SliceReadHookData,\n\t): Promise<SliceMachineManagerReadSliceReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice:read\",\n\t\t\targs,\n\t\t);\n\t\tconst { data, errors } = decodeHookResult(\n\t\t\tt.type({\n\t\t\t\tmodel: SharedSlice,\n\t\t\t}),\n\t\t\thookResult,\n\t\t);\n\n\t\treturn {\n\t\t\tmodel: data[0]?.model,\n\t\t\terrors: errors.map((error) => {\n\t\t\t\terror.message = `Failed to decode slice model with id '${args.sliceID}': ${error.message}`;\n\n\t\t\t\treturn error;\n\t\t\t}),\n\t\t};\n\t}\n\n\tasync updateSlice(\n\t\targs: SliceMachineManagerUpdateSliceArgs,\n\t): Promise<OnlyHookErrors<CallHookReturnType<SliceUpdateHook>>> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst { mocks: previousMocks } = await this.readSliceMocks({\n\t\t\tlibraryID: args.libraryID,\n\t\t\tsliceID: args.model.id,\n\t\t});\n\t\tconst { model: previousModel } = await this.readSlice({\n\t\t\tlibraryID: args.libraryID,\n\t\t\tsliceID: args.model.id,\n\t\t});\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice:update\",\n\t\t\targs,\n\t\t);\n\n\t\tconst updatedMocks = mockSlice({\n\t\t\tmodel: args.model,\n\t\t\tmocks: previousMocks,\n\t\t\tdiff: SliceComparator.compare(previousModel, args.model),\n\t\t});\n\t\tconst updateSliceMocksArgs: SliceMachineManagerUpdateSliceMocksArgs = {\n\t\t\tlibraryID: args.libraryID,\n\t\t\tsliceID: args.model.id,\n\t\t\tmocks: updatedMocks,\n\t\t};\n\n\t\tconst { errors: updateSliceMocksHookResult } =\n\t\t\tawait this.updateSliceMocks(updateSliceMocksArgs);\n\n\t\treturn {\n\t\t\terrors: [...hookResult.errors, ...updateSliceMocksHookResult],\n\t\t};\n\t}\n\n\tasync renameSlice(\n\t\targs: SliceRenameHookData,\n\t): Promise<OnlyHookErrors<CallHookReturnType<SliceRenameHook>>> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice:rename\",\n\t\t\targs,\n\t\t);\n\n\t\treturn {\n\t\t\terrors: hookResult.errors,\n\t\t};\n\t}\n\n\tasync deleteSlice(\n\t\targs: SliceMachineManagerDeleteSliceArgs,\n\t): Promise<SliceMachineManagerDeleteSliceReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst { model, errors: readSliceErrors } = await this.readSlice({\n\t\t\tlibraryID: args.libraryID,\n\t\t\tsliceID: args.sliceID,\n\t\t});\n\n\t\tif (model) {\n\t\t\tconst { errors: deleteSliceErrors } =\n\t\t\t\tawait this.sliceMachinePluginRunner.callHook(\"slice:delete\", {\n\t\t\t\t\tmodel,\n\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t});\n\n\t\t\t// Do not update custom types if slice deletion failed\n\t\t\tif (deleteSliceErrors.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\terrors: deleteSliceErrors,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst { errors: updateCustomTypeErrors } =\n\t\t\t\tawait this._removeSliceFromCustomTypes(args.sliceID);\n\n\t\t\treturn {\n\t\t\t\terrors: updateCustomTypeErrors,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\terrors: readSliceErrors,\n\t\t\t};\n\t\t}\n\t}\n\n\tasync renameSliceVariation(\n\t\targs: SliceMachineManagerRenameSliceVariationArgs,\n\t): Promise<SliceMachineManagerRenameSliceVariationReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\t// TODO: Remove when we support renaming variation ID, see: DT-1708\n\t\tif (args.variationID !== args.model.id) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Renaming variation ID is not supported yet by the backend, only rename its name! For more information, see: https://linear.app/prismic/issue/DT-1708\",\n\t\t\t);\n\t\t}\n\n\t\tconst { model, errors: readSliceErrors } = await this.readSlice({\n\t\t\tlibraryID: args.libraryID,\n\t\t\tsliceID: args.sliceID,\n\t\t});\n\n\t\tif (model) {\n\t\t\t// Find and rename the variation\n\t\t\tconst updatedModel = {\n\t\t\t\t...model,\n\t\t\t\tvariations: model.variations.map((variation) => {\n\t\t\t\t\tif (variation.id === args.variationID) {\n\t\t\t\t\t\t// Matches the slice we want to rename\n\t\t\t\t\t\treturn args.model;\n\t\t\t\t\t} else if (variation.id === args.model.id) {\n\t\t\t\t\t\t// Matches any other slice that has the ID of the renamed variation and throw.\n\t\t\t\t\t\t// This should be validated on the frontend first for better UX, this is only backend validation.\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Cannot rename variation \\`${args.variationID}\\` to \\`${args.model.id}\\`. A variation already exists with that ID in slice \\`${args.sliceID}\\` from library \\`${args.libraryID}\\`, try deleting it first or choose another variation ID to rename that slice.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn variation;\n\t\t\t\t}),\n\t\t\t};\n\t\t\tconst updateSliceHookResult =\n\t\t\t\tawait this.sliceMachinePluginRunner.callHook(\"slice:update\", {\n\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\tmodel: updatedModel,\n\t\t\t\t});\n\n\t\t\t// If variation ID has changed, we need to rename assets accordingly\n\t\t\tconst assetsErrors: (DecodeError<unknown> | HookError<unknown>)[] = [];\n\t\t\tif (args.variationID !== args.model.id) {\n\t\t\t\t// Renaming screenshot\n\t\t\t\tconst { data: screenshot, errors: readSliceScreenshotErrors } =\n\t\t\t\t\tawait this.readSliceScreenshot({\n\t\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\t\tsliceID: args.sliceID,\n\t\t\t\t\t\tvariationID: args.variationID,\n\t\t\t\t\t});\n\t\t\t\tassetsErrors.push(...readSliceScreenshotErrors);\n\n\t\t\t\tif (screenshot) {\n\t\t\t\t\t// Delete old ID screenshot\n\t\t\t\t\tconst { errors: deleteSliceScreenshotErrors } =\n\t\t\t\t\t\tawait this.deleteSliceScreenshot({\n\t\t\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\t\t\tsliceID: args.sliceID,\n\t\t\t\t\t\t\tvariationID: args.variationID,\n\t\t\t\t\t\t});\n\t\t\t\t\tassetsErrors.push(...deleteSliceScreenshotErrors);\n\n\t\t\t\t\t// Create new ID screenshot\n\t\t\t\t\tconst { errors: updateSliceScreenshotErrors } =\n\t\t\t\t\t\tawait this.updateSliceScreenshot({\n\t\t\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\t\t\tsliceID: args.sliceID,\n\t\t\t\t\t\t\tvariationID: args.model.id,\n\t\t\t\t\t\t\tdata: screenshot,\n\t\t\t\t\t\t});\n\t\t\t\t\tassetsErrors.push(...updateSliceScreenshotErrors);\n\t\t\t\t}\n\n\t\t\t\t// Renaming mocks\n\t\t\t\tconst { mocks, errors: readSliceMocksErrors } =\n\t\t\t\t\tawait this.readSliceMocks({\n\t\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\t\tsliceID: args.sliceID,\n\t\t\t\t\t});\n\t\t\t\tassetsErrors.push(...readSliceMocksErrors);\n\n\t\t\t\tif (mocks?.length) {\n\t\t\t\t\tconst { errors: updateSliceMocksErrors } =\n\t\t\t\t\t\tawait this.updateSliceMocks({\n\t\t\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\t\t\tsliceID: args.sliceID,\n\t\t\t\t\t\t\tmocks: mocks.map((mock) => {\n\t\t\t\t\t\t\t\tif (mock.variation === args.variationID) {\n\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t...mock,\n\t\t\t\t\t\t\t\t\t\tvariation: args.model.id,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn mock;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t});\n\t\t\t\t\tassetsErrors.push(...updateSliceMocksErrors);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\terrors: updateSliceHookResult.errors,\n\t\t\t\tassetsErrors,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\terrors: readSliceErrors,\n\t\t\t\tassetsErrors: [],\n\t\t\t};\n\t\t}\n\t}\n\n\tasync deleteSliceVariation(\n\t\targs: SliceMachineManagerDeleteSliceVariationArgs,\n\t): Promise<SliceMachineManagerDeleteSliceVariationReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst { model, errors: readSliceErrors } = await this.readSlice({\n\t\t\tlibraryID: args.libraryID,\n\t\t\tsliceID: args.sliceID,\n\t\t});\n\n\t\tif (model) {\n\t\t\t// Remove variation from model and update it\n\t\t\tconst updatedModel = {\n\t\t\t\t...model,\n\t\t\t\tvariations: model.variations.filter(\n\t\t\t\t\t(variation) => variation.id !== args.variationID,\n\t\t\t\t),\n\t\t\t};\n\t\t\tconst updateSliceHookResult =\n\t\t\t\tawait this.sliceMachinePluginRunner.callHook(\"slice:update\", {\n\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\tmodel: updatedModel,\n\t\t\t\t});\n\n\t\t\t// Cleanup deleted variation screenshot\n\t\t\tconst { errors: deleteSliceScreenshotErrors } =\n\t\t\t\tawait this.deleteSliceScreenshot(args);\n\n\t\t\t// Cleanup deleted variation mocks\n\t\t\tconst { mocks, errors: readSliceMocksErrors } = await this.readSliceMocks(\n\t\t\t\t{\n\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\tsliceID: args.sliceID,\n\t\t\t\t},\n\t\t\t);\n\t\t\tlet updateSliceMocksErrors: SliceMachineManagerUpdateSliceMocksArgsReturnType[\"errors\"] =\n\t\t\t\t[];\n\t\t\tif (mocks?.length) {\n\t\t\t\tupdateSliceMocksErrors = (\n\t\t\t\t\tawait this.updateSliceMocks({\n\t\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\t\tsliceID: args.sliceID,\n\t\t\t\t\t\tmocks: mocks.filter((mock) => mock.variation !== args.variationID),\n\t\t\t\t\t})\n\t\t\t\t).errors;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\terrors: updateSliceHookResult.errors,\n\t\t\t\tassetsErrors: [\n\t\t\t\t\t...deleteSliceScreenshotErrors,\n\t\t\t\t\t...readSliceMocksErrors,\n\t\t\t\t\t...updateSliceMocksErrors,\n\t\t\t\t],\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\terrors: readSliceErrors,\n\t\t\t\tassetsErrors: [],\n\t\t\t};\n\t\t}\n\t}\n\n\tasync convertLegacySliceToSharedSlice(\n\t\targs: SliceMachineManagerConvertLegacySliceToSharedSliceArgs,\n\t): Promise<SliceMachineManagerConvertLegacySliceToSharedSliceReturnType> {\n\t\tconst errors: (DecodeError | HookError)[] = [];\n\n\t\tconst { model: maybeExistingSlice } = await this.readSlice({\n\t\t\tlibraryID: args.dest.libraryID,\n\t\t\tsliceID: args.dest.sliceID,\n\t\t});\n\n\t\tconst legacySliceAsVariation: Variation = {\n\t\t\tid: args.dest.variationID,\n\t\t\tname: args.dest.variationName,\n\t\t\tdescription: args.dest.variationName,\n\t\t\timageUrl: \"\",\n\t\t\tdocURL: \"\",\n\t\t\tversion: \"initial\",\n\t\t\tprimary: {},\n\t\t\titems: {},\n\t\t};\n\n\t\tswitch (args.model.type) {\n\t\t\tcase \"Slice\":\n\t\t\t\tlegacySliceAsVariation.primary = args.model[\"non-repeat\"];\n\t\t\t\tlegacySliceAsVariation.items = args.model.repeat;\n\t\t\t\tbreak;\n\n\t\t\tcase \"Group\":\n\t\t\t\tlegacySliceAsVariation.items = args.model.config?.fields ?? {};\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlegacySliceAsVariation.primary = { [args.src.sliceID]: args.model };\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Convert as a slice variation, or merge against an existing slice variation\n\t\tif (maybeExistingSlice) {\n\t\t\tconst maybeVariation = maybeExistingSlice.variations.find(\n\t\t\t\t(variation) => variation.id === args.dest.variationID,\n\t\t\t);\n\n\t\t\t// If we're not merging against an existing slice variation, then we need to insert the new variation\n\t\t\tif (!maybeVariation) {\n\t\t\t\tmaybeExistingSlice.variations = [\n\t\t\t\t\t...maybeExistingSlice.variations,\n\t\t\t\t\tlegacySliceAsVariation,\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tmaybeExistingSlice.legacyPaths ||= {};\n\t\t\tmaybeExistingSlice.legacyPaths[\n\t\t\t\t`${args.src.customTypeID}::${args.src.sliceZoneID}::${args.src.sliceID}`\n\t\t\t] = args.dest.variationID;\n\n\t\t\tawait this.updateSlice({\n\t\t\t\tlibraryID: args.dest.libraryID,\n\t\t\t\tmodel: maybeExistingSlice,\n\t\t\t});\n\t\t} else {\n\t\t\t// Convert to new shared slice\n\t\t\tawait this.createSlice({\n\t\t\t\tlibraryID: args.dest.libraryID,\n\t\t\t\tmodel: {\n\t\t\t\t\tid: args.dest.sliceID,\n\t\t\t\t\ttype: \"SharedSlice\",\n\t\t\t\t\tname: args.dest.sliceID,\n\t\t\t\t\tlegacyPaths: {\n\t\t\t\t\t\t[`${args.src.customTypeID}::${args.src.sliceZoneID}::${args.src.sliceID}`]:\n\t\t\t\t\t\t\targs.dest.variationID,\n\t\t\t\t\t},\n\t\t\t\t\tvariations: [legacySliceAsVariation],\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// Update source custom type\n\t\tconst { model: customType, errors: customTypeReadErrors } =\n\t\t\tawait this.customTypes.readCustomType({\n\t\t\t\tid: args.src.customTypeID,\n\t\t\t});\n\t\terrors.push(...customTypeReadErrors);\n\n\t\tif (customType) {\n\t\t\tconst field = customType.json[args.src.tabID][args.src.sliceZoneID];\n\n\t\t\t// Convert legacy slice definition in slice zone to shared slice reference\n\t\t\tif (field.type === \"Slices\" && field.config?.choices) {\n\t\t\t\tdelete field.config.choices[args.src.sliceID];\n\t\t\t\tfield.config.choices[args.dest.sliceID] = {\n\t\t\t\t\ttype: \"SharedSlice\",\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst { errors: customTypeUpdateErrors } =\n\t\t\t\tawait this.customTypes.updateCustomType({ model: customType });\n\t\t\terrors.push(...customTypeUpdateErrors);\n\t\t}\n\n\t\treturn { errors };\n\t}\n\n\t/**\n\t * @returns Record of variation IDs mapped to uploaded screenshot URLs.\n\t */\n\tasync pushSlice(\n\t\targs: SliceMachineManagerPushSliceArgs,\n\t): Promise<SliceMachineManagerPushSliceReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tif (!(await this.user.checkIsLoggedIn())) {\n\t\t\tthrow new UnauthenticatedError();\n\t\t}\n\n\t\tconst { model, errors: readSliceErrors } = await this.readSlice({\n\t\t\tlibraryID: args.libraryID,\n\t\t\tsliceID: args.sliceID,\n\t\t});\n\n\t\tif (model) {\n\t\t\tconst modelWithScreenshots =\n\t\t\t\tawait this.updateSliceModelScreenshotsInPlace({\n\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\tmodel,\n\t\t\t\t});\n\n\t\t\tconst authenticationToken = await this.user.getAuthenticationToken();\n\t\t\tconst repositoryName = await this.project.getResolvedRepositoryName();\n\n\t\t\t// TODO: Create a single shared client.\n\t\t\tconst client = prismicCustomTypesClient.createClient({\n\t\t\t\tendpoint: API_ENDPOINTS.PrismicModels,\n\t\t\t\trepositoryName,\n\t\t\t\ttoken: authenticationToken,\n\t\t\t\tfetch,\n\t\t\t\tfetchOptions: {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"User-Agent\": args.userAgent || SLICE_MACHINE_USER_AGENT,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\t// Check if Slice already exists on the repository.\n\t\t\t\tawait client.getSharedSliceByID(args.sliceID);\n\n\t\t\t\t// If it exists on the repository, update it.\n\t\t\t\tawait client.updateSharedSlice(modelWithScreenshots);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof prismicCustomTypesClient.NotFoundError) {\n\t\t\t\t\t// If the Slice doesn't exist on the repository, insert it.\n\t\t\t\t\tawait client.insertSharedSlice(modelWithScreenshots);\n\t\t\t\t} else if (error instanceof prismicCustomTypesClient.ForbiddenError) {\n\t\t\t\t\tthrow new UnauthorizedError(\n\t\t\t\t\t\t\"You do not have access to push Slices to this Prismic repository.\",\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Pass the error through if it isn't the one we were expecting.\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst screenshotURLs: Record<string, string> = {};\n\t\t\tfor (const variation of modelWithScreenshots.variations) {\n\t\t\t\tscreenshotURLs[variation.id] = variation.imageUrl;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tscreenshotURLs,\n\t\t\t\terrors: readSliceErrors,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tscreenshotURLs: undefined,\n\t\t\t\terrors: readSliceErrors,\n\t\t\t};\n\t\t}\n\t}\n\n\tasync readSliceScreenshot(\n\t\targs: SliceMachineManagerReadSliceScreenshotArgs,\n\t): Promise<SliceMachineManagerReadSliceScreenshotReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice:asset:read\",\n\t\t\t{\n\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\tsliceID: args.sliceID,\n\t\t\t\tassetID: `screenshot-${args.variationID}.png`,\n\t\t\t},\n\t\t);\n\t\tconst { data, errors } = decodeHookResult(\n\t\t\tt.type({\n\t\t\t\tdata: bufferCodec,\n\t\t\t}),\n\t\t\thookResult,\n\t\t);\n\n\t\treturn {\n\t\t\tdata: data[0]?.data,\n\t\t\terrors: errors,\n\t\t};\n\t}\n\n\tasync updateSliceScreenshot(\n\t\targs: SliceMachineManagerUpdateSliceScreenshotArgs,\n\t): Promise<OnlyHookErrors<CallHookReturnType<SliceAssetUpdateHook>>> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice:asset:update\",\n\t\t\t{\n\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\tsliceID: args.sliceID,\n\t\t\t\tasset: {\n\t\t\t\t\tid: `screenshot-${args.variationID}.png`,\n\t\t\t\t\tdata: args.data,\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\treturn {\n\t\t\terrors: hookResult.errors,\n\t\t};\n\t}\n\n\tasync deleteSliceScreenshot(\n\t\targs: SliceMachineManagerDeleteSliceScreenshotArgs,\n\t): Promise<OnlyHookErrors<CallHookReturnType<SliceAssetUpdateHook>>> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice:asset:delete\",\n\t\t\t{\n\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\tsliceID: args.sliceID,\n\t\t\t\tassetID: `screenshot-${args.variationID}.png`,\n\t\t\t},\n\t\t);\n\n\t\treturn {\n\t\t\terrors: hookResult.errors,\n\t\t};\n\t}\n\n\tasync readSliceMocks(\n\t\targs: SliceMachineManagerReadSliceMocksArgs,\n\t): Promise<SliceMachineManagerReadSliceMocksReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice:asset:read\",\n\t\t\t{\n\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\tsliceID: args.sliceID,\n\t\t\t\tassetID: `mocks.json`,\n\t\t\t},\n\t\t);\n\t\tconst { data, errors } = decodeHookResult(\n\t\t\tt.type({\n\t\t\t\tdata: t.array(SharedSliceContent),\n\t\t\t}),\n\t\t\t{\n\t\t\t\t...hookResult,\n\t\t\t\t// Convert the asset data from a Buffer to JSON\n\t\t\t\t// to prepare it for validation.\n\t\t\t\tdata: hookResult.data.map((result) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t\tdata: JSON.parse(result.data.toString()),\n\t\t\t\t\t\t};\n\t\t\t\t\t} catch {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t},\n\t\t);\n\n\t\tif (data) {\n\t\t\treturn {\n\t\t\t\tmocks: data[0]?.data,\n\t\t\t\terrors,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tmocks: [],\n\t\t\t\terrors,\n\t\t\t};\n\t\t}\n\t}\n\n\tasync updateSliceMocks(\n\t\targs: SliceMachineManagerUpdateSliceMocksArgs,\n\t): Promise<SliceMachineManagerUpdateSliceMocksArgsReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice:asset:update\",\n\t\t\t{\n\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\tsliceID: args.sliceID,\n\t\t\t\tasset: {\n\t\t\t\t\tid: \"mocks.json\",\n\t\t\t\t\tdata: Buffer.from(JSON.stringify(args.mocks, null, \"\\t\")),\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\treturn {\n\t\t\terrors: hookResult.errors,\n\t\t};\n\t}\n\n\t// TODO: Remove\n\tasync readSliceMocksConfig(\n\t\targs: SliceMachineManagerReadSliceMocksConfigArgs,\n\t): Promise<SliceMachineManagerReadSliceMocksConfigArgsReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"slice:asset:read\",\n\t\t\t{\n\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\tsliceID: args.sliceID,\n\t\t\t\tassetID: \"mocks.config.json\",\n\t\t\t},\n\t\t);\n\t\tconst data = hookResult.data[0]?.data;\n\n\t\t// TODO: Validate the returned data.\n\n\t\tif (data) {\n\t\t\treturn {\n\t\t\t\tmocksConfig: JSON.parse(data.toString()),\n\t\t\t\terrors: hookResult.errors,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tmocksConfig: undefined,\n\t\t\t\terrors: hookResult.errors,\n\t\t\t};\n\t\t}\n\t}\n\n\tasync fetchRemoteSlices(): Promise<SharedSlice[]> {\n\t\tconst authenticationToken = await this.user.getAuthenticationToken();\n\t\tconst repositoryName = await this.project.getResolvedRepositoryName();\n\n\t\tconst client = prismicCustomTypesClient.createClient({\n\t\t\tendpoint: API_ENDPOINTS.PrismicModels,\n\t\t\trepositoryName,\n\t\t\ttoken: authenticationToken,\n\t\t\tfetch,\n\t\t\tfetchOptions: {\n\t\t\t\theaders: {\n\t\t\t\t\t\"User-Agent\": SLICE_MACHINE_USER_AGENT,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\treturn await client.getAllSharedSlices();\n\t}\n\n\tasync updateSliceModelScreenshotsInPlace(\n\t\targs: SlicesManagerUpsertHostedSliceScrenshotsArgs,\n\t): Promise<SharedSlice> {\n\t\tconst sliceMachineConfig = await this.project.getSliceMachineConfig();\n\n\t\tconst variations = await Promise.all(\n\t\t\targs.model.variations.map(async (variation) => {\n\t\t\t\tconst screenshot = await this.readSliceScreenshot({\n\t\t\t\t\tlibraryID: args.libraryID,\n\t\t\t\t\tsliceID: args.model.id,\n\t\t\t\t\tvariationID: variation.id,\n\t\t\t\t});\n\n\t\t\t\t// If there's no screenshot, delete it by replacing it with the default screenshot\n\t\t\t\tif (!screenshot.data) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...variation,\n\t\t\t\t\t\timageUrl: DEFAULT_SLICE_SCREENSHOT_URL,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tconst hasScreenshotChanged = !variation.imageUrl?.includes(\n\t\t\t\t\tcreateContentDigest(screenshot.data),\n\t\t\t\t);\n\n\t\t\t\t// If screenshot hasn't changed, do nothing\n\t\t\t\tif (!hasScreenshotChanged) {\n\t\t\t\t\treturn variation;\n\t\t\t\t}\n\n\t\t\t\tconst keyPrefix = [\n\t\t\t\t\tsliceMachineConfig.repositoryName,\n\t\t\t\t\t\"shared-slices\",\n\t\t\t\t\targs.model.id,\n\t\t\t\t\tvariation.id,\n\t\t\t\t].join(\"/\");\n\n\t\t\t\tconst uploadedScreenshot = await this.screenshots.uploadScreenshot({\n\t\t\t\t\tdata: screenshot.data,\n\t\t\t\t\tkeyPrefix,\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\t...variation,\n\t\t\t\t\timageUrl: uploadedScreenshot.url,\n\t\t\t\t};\n\t\t\t}),\n\t\t);\n\n\t\treturn {\n\t\t\t...args.model,\n\t\t\tvariations,\n\t\t};\n\t}\n\n\tprivate async _removeSliceFromCustomTypes(sliceID: string) {\n\t\tconst { models, errors: customTypeReadErrors } =\n\t\t\tawait this.customTypes.readAllCustomTypes();\n\n\t\t// Successfully update all custom types or throw\n\t\tawait Promise.all(\n\t\t\tmodels.map(async (customType) => {\n\t\t\t\tconst updatedJsonModel = Object.entries(customType.model.json).reduce(\n\t\t\t\t\t(tabAccumulator, [tabKey, tab]) => {\n\t\t\t\t\t\tconst updatedTabFields = Object.entries(tab).reduce(\n\t\t\t\t\t\t\t(fieldAccumulator, [fieldKey, field]) => {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tfield.config === undefined ||\n\t\t\t\t\t\t\t\t\tfield.type !== \"Slices\" ||\n\t\t\t\t\t\t\t\t\tfield.config.choices === undefined\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn { ...fieldAccumulator, [fieldKey]: field };\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst filteredChoices = Object.entries(\n\t\t\t\t\t\t\t\t\tfield.config.choices,\n\t\t\t\t\t\t\t\t).reduce((choiceAccumulator, [choiceKey, choice]) => {\n\t\t\t\t\t\t\t\t\tif (choiceKey === sliceID) {\n\t\t\t\t\t\t\t\t\t\treturn choiceAccumulator;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn { ...choiceAccumulator, [choiceKey]: choice };\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t...fieldAccumulator,\n\t\t\t\t\t\t\t\t\t[fieldKey]: {\n\t\t\t\t\t\t\t\t\t\t...field,\n\t\t\t\t\t\t\t\t\t\tconfig: { ...field.config, choices: filteredChoices },\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn { ...tabAccumulator, [tabKey]: updatedTabFields };\n\t\t\t\t\t},\n\t\t\t\t\t{},\n\t\t\t\t);\n\n\t\t\t\tawait this.customTypes.updateCustomType({\n\t\t\t\t\tmodel: { ...customType.model, json: updatedJsonModel },\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\n\t\treturn { errors: customTypeReadErrors };\n\t}\n}\n"],"names":["errors"],"mappings":";;;;;;;;;;;;;;;;AAiNM,MAAO,sBAAsB,YAAW;AAAA,EAC7C,MAAM,iBACL,MAA8B;;AAE9B,6BAAyB,KAAK,wBAAwB;AAKtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,sBACA,IAAI;AAEL,UAAM,EAAE,MAAM,OAAA,IAAW,iBACxB,EAAE,KAAK;AAAA,MACN,IAAI,EAAE;AAAA,MACN,UAAU,EAAE,MAAM,EAAE,MAAM;AAAA,IAAA,CAC1B,GACD,UAAU;AAGJ,WAAA;AAAA,MACN,YAAU,UAAK,CAAC,MAAN,mBAAS,aAAY,CAAE;AAAA,MACjC;AAAA,IAAA;AAAA,EAEF;AAAA,EAEA,MAAM,wBAAqB;AAC1B,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,qBAAqB,MAAM,KAAK,QAAQ,sBAAqB;AAC7D,UAAA,aAAa,mBAAmB,aAAa;AAEnD,UAAM,MAAoD;AAAA,MACzD,WAAW,CAAE;AAAA,MACb,QAAQ,CAAE;AAAA,IAAA;AAGX,eAAW,aAAa,YAAY;AACnC,YAAM,EAAE,UAAU,OAAW,IAAA,MAAM,KAAK,iBAAiB;AAAA,QACxD;AAAA,MAAA,CACA;AACD,UAAI,SAAS,CAAC,GAAG,IAAI,QAAQ,GAAG,MAAM;AAEtC,UAAI,UAAU,KAAK;AAAA,QAClB;AAAA,QACA;AAAA,MAAA,CACA;AAAA,IACD;AAEM,WAAA;AAAA,EACR;AAAA,EAEA,MAAM,wBACL,MAAoD;AAEpD,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,MAA4D;AAAA,MACjE,QAAQ,CAAE;AAAA,MACV,QAAQ,CAAE;AAAA,IAAA;AAGX,UAAM,EAAE,UAAU,OAAW,IAAA,MAAM,KAAK,iBAAiB;AAAA,MACxD,WAAW,KAAK;AAAA,IAAA,CAChB;AACG,QAAA,OAAO,KAAK,GAAG,MAAM;AAEzB,QAAI,UAAU;AACb,iBAAW,WAAW,UAAU;AAC/B,cAAM,EAAE,OAAO,QAAAA,YAAW,MAAM,KAAK,UAAU;AAAA,UAC9C,WAAW,KAAK;AAAA,UAChB;AAAA,QAAA,CACA;AACG,YAAA,OAAO,KAAK,GAAGA,OAAM;AAEzB,YAAI,OAAO;AACV,cAAI,OAAO,KAAK,EAAE,MAAO,CAAA;AAAA,QACzB;AAAA,MACD;AAAA,IACD;AAEM,WAAA;AAAA,EACR;AAAA,EAEA,MAAM,gBAAa;AAClB,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,qBAAqB,MAAM,KAAK,QAAQ,sBAAqB;AAC7D,UAAA,aAAa,mBAAmB,aAAa;AAEnD,UAAM,MAAkD;AAAA,MACvD,QAAQ,CAAE;AAAA,MACV,QAAQ,CAAE;AAAA,IAAA;AAGX,eAAW,aAAa,YAAY;AACnC,YAAM,EAAE,QAAQ,OAAW,IAAA,MAAM,KAAK,wBAAwB;AAAA,QAC7D;AAAA,MAAA,CACA;AACG,UAAA,OAAO,KAAK,GAAG,MAAM;AAEzB,iBAAW,SAAS,QAAQ;AAC3B,YAAI,OAAO,KAAK;AAAA,UACf;AAAA,UACA,OAAO,MAAM;AAAA,QAAA,CACb;AAAA,MACD;AAAA,IACD;AAEM,WAAA;AAAA,EACR;AAAA,EAEA,MAAM,YACL,MAAyB;AAEzB,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,gBACA,IAAI;AAGL,UAAM,uBAAgE;AAAA,MACrE,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK,MAAM;AAAA,MACpB,OAAO,UAAU,EAAE,OAAO,KAAK,OAAO;AAAA,IAAA;AAGvC,UAAM,EAAE,QAAQ,0BACf,MAAM,KAAK,iBAAiB,oBAAoB;AAE1C,WAAA;AAAA,MACN,QAAQ,CAAC,GAAG,WAAW,QAAQ,GAAG,qBAAqB;AAAA,IAAA;AAAA,EAEzD;AAAA,EAEA,MAAM,UACL,MAAuB;;AAEvB,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,cACA,IAAI;AAEL,UAAM,EAAE,MAAM,OAAA,IAAW,iBACxB,EAAE,KAAK;AAAA,MACN,OAAO;AAAA,IAAA,CACP,GACD,UAAU;AAGJ,WAAA;AAAA,MACN,QAAO,UAAK,CAAC,MAAN,mBAAS;AAAA,MAChB,QAAQ,OAAO,IAAI,CAAC,UAAS;AAC5B,cAAM,UAAU,yCAAyC,KAAK,aAAa,MAAM;AAE1E,eAAA;AAAA,MAAA,CACP;AAAA,IAAA;AAAA,EAEH;AAAA,EAEA,MAAM,YACL,MAAwC;AAExC,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,EAAE,OAAO,cAAkB,IAAA,MAAM,KAAK,eAAe;AAAA,MAC1D,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK,MAAM;AAAA,IAAA,CACpB;AACD,UAAM,EAAE,OAAO,cAAkB,IAAA,MAAM,KAAK,UAAU;AAAA,MACrD,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK,MAAM;AAAA,IAAA,CACpB;AACD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,gBACA,IAAI;AAGL,UAAM,eAAe,UAAU;AAAA,MAC9B,OAAO,KAAK;AAAA,MACZ,OAAO;AAAA,MACP,MAAM,gBAAgB,QAAQ,eAAe,KAAK,KAAK;AAAA,IAAA,CACvD;AACD,UAAM,uBAAgE;AAAA,MACrE,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK,MAAM;AAAA,MACpB,OAAO;AAAA,IAAA;AAGR,UAAM,EAAE,QAAQ,+BACf,MAAM,KAAK,iBAAiB,oBAAoB;AAE1C,WAAA;AAAA,MACN,QAAQ,CAAC,GAAG,WAAW,QAAQ,GAAG,0BAA0B;AAAA,IAAA;AAAA,EAE9D;AAAA,EAEA,MAAM,YACL,MAAyB;AAEzB,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,gBACA,IAAI;AAGE,WAAA;AAAA,MACN,QAAQ,WAAW;AAAA,IAAA;AAAA,EAErB;AAAA,EAEA,MAAM,YACL,MAAwC;AAExC,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,EAAE,OAAO,QAAQ,oBAAoB,MAAM,KAAK,UAAU;AAAA,MAC/D,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,IAAA,CACd;AAED,QAAI,OAAO;AACJ,YAAA,EAAE,QAAQ,sBACf,MAAM,KAAK,yBAAyB,SAAS,gBAAgB;AAAA,QAC5D;AAAA,QACA,WAAW,KAAK;AAAA,MAAA,CAChB;AAGE,UAAA,kBAAkB,SAAS,GAAG;AAC1B,eAAA;AAAA,UACN,QAAQ;AAAA,QAAA;AAAA,MAET;AAEK,YAAA,EAAE,QAAQ,2BACf,MAAM,KAAK,4BAA4B,KAAK,OAAO;AAE7C,aAAA;AAAA,QACN,QAAQ;AAAA,MAAA;AAAA,WAEH;AACC,aAAA;AAAA,QACN,QAAQ;AAAA,MAAA;AAAA,IAET;AAAA,EACF;AAAA,EAEA,MAAM,qBACL,MAAiD;AAEjD,6BAAyB,KAAK,wBAAwB;AAGtD,QAAI,KAAK,gBAAgB,KAAK,MAAM,IAAI;AACjC,YAAA,IAAI,MACT,sJAAsJ;AAAA,IAEvJ;AAED,UAAM,EAAE,OAAO,QAAQ,oBAAoB,MAAM,KAAK,UAAU;AAAA,MAC/D,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,IAAA,CACd;AAED,QAAI,OAAO;AAEV,YAAM,eAAe;AAAA,QACpB,GAAG;AAAA,QACH,YAAY,MAAM,WAAW,IAAI,CAAC,cAAa;AAC1C,cAAA,UAAU,OAAO,KAAK,aAAa;AAEtC,mBAAO,KAAK;AAAA,UACF,WAAA,UAAU,OAAO,KAAK,MAAM,IAAI;AAGpC,kBAAA,IAAI,MACT,6BAA6B,KAAK,sBAAsB,KAAK,MAAM,4DAA4D,KAAK,4BAA4B,KAAK,yFAAyF;AAAA,UAE/P;AAEM,iBAAA;AAAA,QAAA,CACP;AAAA,MAAA;AAEF,YAAM,wBACL,MAAM,KAAK,yBAAyB,SAAS,gBAAgB;AAAA,QAC5D,WAAW,KAAK;AAAA,QAChB,OAAO;AAAA,MAAA,CACP;AAGF,YAAM,eAA8D,CAAA;AACpE,UAAI,KAAK,gBAAgB,KAAK,MAAM,IAAI;AAEjC,cAAA,EAAE,MAAM,YAAY,QAAQ,8BACjC,MAAM,KAAK,oBAAoB;AAAA,UAC9B,WAAW,KAAK;AAAA,UAChB,SAAS,KAAK;AAAA,UACd,aAAa,KAAK;AAAA,QAAA,CAClB;AACW,qBAAA,KAAK,GAAG,yBAAyB;AAE9C,YAAI,YAAY;AAEf,gBAAM,EAAE,QAAQ,4BACf,IAAA,MAAM,KAAK,sBAAsB;AAAA,YAChC,WAAW,KAAK;AAAA,YAChB,SAAS,KAAK;AAAA,YACd,aAAa,KAAK;AAAA,UAAA,CAClB;AACW,uBAAA,KAAK,GAAG,2BAA2B;AAGhD,gBAAM,EAAE,QAAQ,4BACf,IAAA,MAAM,KAAK,sBAAsB;AAAA,YAChC,WAAW,KAAK;AAAA,YAChB,SAAS,KAAK;AAAA,YACd,aAAa,KAAK,MAAM;AAAA,YACxB,MAAM;AAAA,UAAA,CACN;AACW,uBAAA,KAAK,GAAG,2BAA2B;AAAA,QAChD;AAGD,cAAM,EAAE,OAAO,QAAQ,yBACtB,MAAM,KAAK,eAAe;AAAA,UACzB,WAAW,KAAK;AAAA,UAChB,SAAS,KAAK;AAAA,QAAA,CACd;AACW,qBAAA,KAAK,GAAG,oBAAoB;AAEzC,YAAI,+BAAO,QAAQ;AAClB,gBAAM,EAAE,QAAQ,uBACf,IAAA,MAAM,KAAK,iBAAiB;AAAA,YAC3B,WAAW,KAAK;AAAA,YAChB,SAAS,KAAK;AAAA,YACd,OAAO,MAAM,IAAI,CAAC,SAAQ;AACrB,kBAAA,KAAK,cAAc,KAAK,aAAa;AACjC,uBAAA;AAAA,kBACN,GAAG;AAAA,kBACH,WAAW,KAAK,MAAM;AAAA,gBAAA;AAAA,cAEvB;AAEM,qBAAA;AAAA,YAAA,CACP;AAAA,UAAA,CACD;AACW,uBAAA,KAAK,GAAG,sBAAsB;AAAA,QAC3C;AAAA,MACD;AAEM,aAAA;AAAA,QACN,QAAQ,sBAAsB;AAAA,QAC9B;AAAA,MAAA;AAAA,WAEK;AACC,aAAA;AAAA,QACN,QAAQ;AAAA,QACR,cAAc,CAAE;AAAA,MAAA;AAAA,IAEjB;AAAA,EACF;AAAA,EAEA,MAAM,qBACL,MAAiD;AAEjD,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,EAAE,OAAO,QAAQ,oBAAoB,MAAM,KAAK,UAAU;AAAA,MAC/D,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,IAAA,CACd;AAED,QAAI,OAAO;AAEV,YAAM,eAAe;AAAA,QACpB,GAAG;AAAA,QACH,YAAY,MAAM,WAAW,OAC5B,CAAC,cAAc,UAAU,OAAO,KAAK,WAAW;AAAA,MAAA;AAGlD,YAAM,wBACL,MAAM,KAAK,yBAAyB,SAAS,gBAAgB;AAAA,QAC5D,WAAW,KAAK;AAAA,QAChB,OAAO;AAAA,MAAA,CACP;AAGF,YAAM,EAAE,QAAQ,gCACf,MAAM,KAAK,sBAAsB,IAAI;AAGtC,YAAM,EAAE,OAAO,QAAQ,yBAAyB,MAAM,KAAK,eAC1D;AAAA,QACC,WAAW,KAAK;AAAA,QAChB,SAAS,KAAK;AAAA,MAAA,CACd;AAEF,UAAI,yBACH,CAAA;AACD,UAAI,+BAAO,QAAQ;AAEjB,kCAAA,MAAM,KAAK,iBAAiB;AAAA,UAC3B,WAAW,KAAK;AAAA,UAChB,SAAS,KAAK;AAAA,UACd,OAAO,MAAM,OAAO,CAAC,SAAS,KAAK,cAAc,KAAK,WAAW;AAAA,QACjE,CAAA,GACA;AAAA,MACF;AAEM,aAAA;AAAA,QACN,QAAQ,sBAAsB;AAAA,QAC9B,cAAc;AAAA,UACb,GAAG;AAAA,UACH,GAAG;AAAA,UACH,GAAG;AAAA,QACH;AAAA,MAAA;AAAA,WAEI;AACC,aAAA;AAAA,QACN,QAAQ;AAAA,QACR,cAAc,CAAE;AAAA,MAAA;AAAA,IAEjB;AAAA,EACF;AAAA,EAEA,MAAM,gCACL,MAA4D;;AAE5D,UAAM,SAAsC,CAAA;AAE5C,UAAM,EAAE,OAAO,mBAAuB,IAAA,MAAM,KAAK,UAAU;AAAA,MAC1D,WAAW,KAAK,KAAK;AAAA,MACrB,SAAS,KAAK,KAAK;AAAA,IAAA,CACnB;AAED,UAAM,yBAAoC;AAAA,MACzC,IAAI,KAAK,KAAK;AAAA,MACd,MAAM,KAAK,KAAK;AAAA,MAChB,aAAa,KAAK,KAAK;AAAA,MACvB,UAAU;AAAA,MACV,QAAQ;AAAA,MACR,SAAS;AAAA,MACT,SAAS,CAAE;AAAA,MACX,OAAO,CAAE;AAAA,IAAA;AAGF,YAAA,KAAK,MAAM,MAAM;AAAA,MACxB,KAAK;AACmB,+BAAA,UAAU,KAAK,MAAM,YAAY;AACjC,+BAAA,QAAQ,KAAK,MAAM;AAC1C;AAAA,MAED,KAAK;AACJ,+BAAuB,UAAQ,UAAK,MAAM,WAAX,mBAAmB,WAAU;AAC5D;AAAA,MAED;AACwB,+BAAA,UAAU,EAAE,CAAC,KAAK,IAAI,OAAO,GAAG,KAAK;AAC5D;AAAA,IACD;AAGD,QAAI,oBAAoB;AACjB,YAAA,iBAAiB,mBAAmB,WAAW,KACpD,CAAC,cAAc,UAAU,OAAO,KAAK,KAAK,WAAW;AAItD,UAAI,CAAC,gBAAgB;AACpB,2BAAmB,aAAa;AAAA,UAC/B,GAAG,mBAAmB;AAAA,UACtB;AAAA,QAAA;AAAA,MAED;AAED,yBAAmB,gBAAnB,mBAAmB,cAAgB;AACnC,yBAAmB,YAClB,GAAG,KAAK,IAAI,iBAAiB,KAAK,IAAI,gBAAgB,KAAK,IAAI,SAAS,IACrE,KAAK,KAAK;AAEd,YAAM,KAAK,YAAY;AAAA,QACtB,WAAW,KAAK,KAAK;AAAA,QACrB,OAAO;AAAA,MAAA,CACP;AAAA,IAAA,OACK;AAEN,YAAM,KAAK,YAAY;AAAA,QACtB,WAAW,KAAK,KAAK;AAAA,QACrB,OAAO;AAAA,UACN,IAAI,KAAK,KAAK;AAAA,UACd,MAAM;AAAA,UACN,MAAM,KAAK,KAAK;AAAA,UAChB,aAAa;AAAA,YACZ,CAAC,GAAG,KAAK,IAAI,iBAAiB,KAAK,IAAI,gBAAgB,KAAK,IAAI,SAAS,GACxE,KAAK,KAAK;AAAA,UACX;AAAA,UACD,YAAY,CAAC,sBAAsB;AAAA,QACnC;AAAA,MAAA,CACD;AAAA,IACD;AAGK,UAAA,EAAE,OAAO,YAAY,QAAQ,yBAClC,MAAM,KAAK,YAAY,eAAe;AAAA,MACrC,IAAI,KAAK,IAAI;AAAA,IAAA,CACb;AACK,WAAA,KAAK,GAAG,oBAAoB;AAEnC,QAAI,YAAY;AACT,YAAA,QAAQ,WAAW,KAAK,KAAK,IAAI,KAAK,EAAE,KAAK,IAAI,WAAW;AAGlE,UAAI,MAAM,SAAS,cAAY,WAAM,WAAN,mBAAc,UAAS;AACrD,eAAO,MAAM,OAAO,QAAQ,KAAK,IAAI,OAAO;AAC5C,cAAM,OAAO,QAAQ,KAAK,KAAK,OAAO,IAAI;AAAA,UACzC,MAAM;AAAA,QAAA;AAAA,MAEP;AAEK,YAAA,EAAE,QAAQ,uBACf,IAAA,MAAM,KAAK,YAAY,iBAAiB,EAAE,OAAO,WAAA,CAAY;AACvD,aAAA,KAAK,GAAG,sBAAsB;AAAA,IACrC;AAED,WAAO,EAAE,OAAM;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UACL,MAAsC;AAEtC,6BAAyB,KAAK,wBAAwB;AAEtD,QAAI,CAAE,MAAM,KAAK,KAAK,mBAAoB;AACzC,YAAM,IAAI,qBAAoB;AAAA,IAC9B;AAED,UAAM,EAAE,OAAO,QAAQ,oBAAoB,MAAM,KAAK,UAAU;AAAA,MAC/D,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,IAAA,CACd;AAED,QAAI,OAAO;AACJ,YAAA,uBACL,MAAM,KAAK,mCAAmC;AAAA,QAC7C,WAAW,KAAK;AAAA,QAChB;AAAA,MAAA,CACA;AAEF,YAAM,sBAAsB,MAAM,KAAK,KAAK,uBAAsB;AAClE,YAAM,iBAAiB,MAAM,KAAK,QAAQ,0BAAyB;AAG7D,YAAA,SAAS,yBAAyB,aAAa;AAAA,QACpD,UAAU,cAAc;AAAA,QACxB;AAAA,QACA,OAAO;AAAA,QACP;AAAA,QACA,cAAc;AAAA,UACb,SAAS;AAAA,YACR,cAAc,KAAK,aAAa;AAAA,UAChC;AAAA,QACD;AAAA,MAAA,CACD;AAEG,UAAA;AAEG,cAAA,OAAO,mBAAmB,KAAK,OAAO;AAGtC,cAAA,OAAO,kBAAkB,oBAAoB;AAAA,eAC3C;AACJ,YAAA,iBAAiB,yBAAyB,eAAe;AAEtD,gBAAA,OAAO,kBAAkB,oBAAoB;AAAA,QAAA,WACzC,iBAAiB,yBAAyB,gBAAgB;AAC9D,gBAAA,IAAI,kBACT,mEAAmE;AAAA,QAAA,OAE9D;AAEA,gBAAA;AAAA,QACN;AAAA,MACD;AAED,YAAM,iBAAyC,CAAA;AACpC,iBAAA,aAAa,qBAAqB,YAAY;AACzC,uBAAA,UAAU,EAAE,IAAI,UAAU;AAAA,MACzC;AAEM,aAAA;AAAA,QACN;AAAA,QACA,QAAQ;AAAA,MAAA;AAAA,WAEH;AACC,aAAA;AAAA,QACN,gBAAgB;AAAA,QAChB,QAAQ;AAAA,MAAA;AAAA,IAET;AAAA,EACF;AAAA,EAEA,MAAM,oBACL,MAAgD;;AAEhD,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,oBACA;AAAA,MACC,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,MACd,SAAS,cAAc,KAAK;AAAA,IAAA,CAC5B;AAEF,UAAM,EAAE,MAAM,OAAA,IAAW,iBACxB,EAAE,KAAK;AAAA,MACN,MAAM;AAAA,IAAA,CACN,GACD,UAAU;AAGJ,WAAA;AAAA,MACN,OAAM,UAAK,CAAC,MAAN,mBAAS;AAAA,MACf;AAAA,IAAA;AAAA,EAEF;AAAA,EAEA,MAAM,sBACL,MAAkD;AAElD,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,sBACA;AAAA,MACC,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,MACd,OAAO;AAAA,QACN,IAAI,cAAc,KAAK;AAAA,QACvB,MAAM,KAAK;AAAA,MACX;AAAA,IAAA,CACD;AAGK,WAAA;AAAA,MACN,QAAQ,WAAW;AAAA,IAAA;AAAA,EAErB;AAAA,EAEA,MAAM,sBACL,MAAkD;AAElD,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,sBACA;AAAA,MACC,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,MACd,SAAS,cAAc,KAAK;AAAA,IAAA,CAC5B;AAGK,WAAA;AAAA,MACN,QAAQ,WAAW;AAAA,IAAA;AAAA,EAErB;AAAA,EAEA,MAAM,eACL,MAA2C;;AAE3C,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,oBACA;AAAA,MACC,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,MACd,SAAS;AAAA,IAAA,CACT;AAEF,UAAM,EAAE,MAAM,OAAA,IAAW,iBACxB,EAAE,KAAK;AAAA,MACN,MAAM,EAAE,MAAM,kBAAkB;AAAA,IAAA,CAChC,GACD;AAAA,MACC,GAAG;AAAA;AAAA;AAAA,MAGH,MAAM,WAAW,KAAK,IAAI,CAAC,WAAU;AAChC,YAAA;AACI,iBAAA;AAAA,YACN,GAAG;AAAA,YACH,MAAM,KAAK,MAAM,OAAO,KAAK,UAAU;AAAA,UAAA;AAAA,gBAEvC;AACM,iBAAA;AAAA,QACP;AAAA,MAAA,CACD;AAAA,IAAA,CACD;AAGF,QAAI,MAAM;AACF,aAAA;AAAA,QACN,QAAO,UAAK,CAAC,MAAN,mBAAS;AAAA,QAChB;AAAA,MAAA;AAAA,WAEK;AACC,aAAA;AAAA,QACN,OAAO,CAAE;AAAA,QACT;AAAA,MAAA;AAAA,IAED;AAAA,EACF;AAAA,EAEA,MAAM,iBACL,MAA6C;AAE7C,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,sBACA;AAAA,MACC,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,MACd,OAAO;AAAA,QACN,IAAI;AAAA,QACJ,MAAM,OAAO,KAAK,KAAK,UAAU,KAAK,OAAO,MAAM,GAAI,CAAC;AAAA,MACxD;AAAA,IAAA,CACD;AAGK,WAAA;AAAA,MACN,QAAQ,WAAW;AAAA,IAAA;AAAA,EAErB;AAAA;AAAA,EAGA,MAAM,qBACL,MAAiD;;AAEjD,6BAAyB,KAAK,wBAAwB;AAEtD,UAAM,aAAa,MAAM,KAAK,yBAAyB,SACtD,oBACA;AAAA,MACC,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,MACd,SAAS;AAAA,IAAA,CACT;AAEF,UAAM,QAAO,gBAAW,KAAK,CAAC,MAAjB,mBAAoB;AAIjC,QAAI,MAAM;AACF,aAAA;AAAA,QACN,aAAa,KAAK,MAAM,KAAK,UAAU;AAAA,QACvC,QAAQ,WAAW;AAAA,MAAA;AAAA,WAEd;AACC,aAAA;AAAA,QACN,aAAa;AAAA,QACb,QAAQ,WAAW;AAAA,MAAA;AAAA,IAEpB;AAAA,EACF;AAAA,EAEA,MAAM,oBAAiB;AACtB,UAAM,sBAAsB,MAAM,KAAK,KAAK,uBAAsB;AAClE,UAAM,iBAAiB,MAAM,KAAK,QAAQ,0BAAyB;AAE7D,UAAA,SAAS,yBAAyB,aAAa;AAAA,MACpD,UAAU,cAAc;AAAA,MACxB;AAAA,MACA,OAAO;AAAA,MACP;AAAA,MACA,cAAc;AAAA,QACb,SAAS;AAAA,UACR,cAAc;AAAA,QACd;AAAA,MACD;AAAA,IAAA,CACD;AAEM,WAAA,MAAM,OAAO;EACrB;AAAA,EAEA,MAAM,mCACL,MAAkD;AAElD,UAAM,qBAAqB,MAAM,KAAK,QAAQ,sBAAqB;AAE7D,UAAA,aAAa,MAAM,QAAQ,IAChC,KAAK,MAAM,WAAW,IAAI,OAAO,cAAa;;AACvC,YAAA,aAAa,MAAM,KAAK,oBAAoB;AAAA,QACjD,WAAW,KAAK;AAAA,QAChB,SAAS,KAAK,MAAM;AAAA,QACpB,aAAa,UAAU;AAAA,MAAA,CACvB;AAGG,UAAA,CAAC,WAAW,MAAM;AACd,eAAA;AAAA,UACN,GAAG;AAAA,UACH,UAAU;AAAA,QAAA;AAAA,MAEX;AAEK,YAAA,uBAAuB,GAAC,eAAU,aAAV,mBAAoB,SACjD,oBAAoB,WAAW,IAAI;AAIpC,UAAI,CAAC,sBAAsB;AACnB,eAAA;AAAA,MACP;AAED,YAAM,YAAY;AAAA,QACjB,mBAAmB;AAAA,QACnB;AAAA,QACA,KAAK,MAAM;AAAA,QACX,UAAU;AAAA,MAAA,EACT,KAAK,GAAG;AAEV,YAAM,qBAAqB,MAAM,KAAK,YAAY,iBAAiB;AAAA,QAClE,MAAM,WAAW;AAAA,QACjB;AAAA,MAAA,CACA;AAEM,aAAA;AAAA,QACN,GAAG;AAAA,QACH,UAAU,mBAAmB;AAAA,MAAA;AAAA,IAE9B,CAAA,CAAC;AAGI,WAAA;AAAA,MACN,GAAG,KAAK;AAAA,MACR;AAAA,IAAA;AAAA,EAEF;AAAA,EAEQ,MAAM,4BAA4B,SAAe;AAClD,UAAA,EAAE,QAAQ,QAAQ,qBAAA,IACvB,MAAM,KAAK,YAAY;AAGxB,UAAM,QAAQ,IACb,OAAO,IAAI,OAAO,eAAc;AAC/B,YAAM,mBAAmB,OAAO,QAAQ,WAAW,MAAM,IAAI,EAAE,OAC9D,CAAC,gBAAgB,CAAC,QAAQ,GAAG,MAAK;AAC3B,cAAA,mBAAmB,OAAO,QAAQ,GAAG,EAAE,OAC5C,CAAC,kBAAkB,CAAC,UAAU,KAAK,MAAK;AAEtC,cAAA,MAAM,WAAW,UACjB,MAAM,SAAS,YACf,MAAM,OAAO,YAAY,QACxB;AACD,mBAAO,EAAE,GAAG,kBAAkB,CAAC,QAAQ,GAAG,MAAK;AAAA,UAC/C;AAED,gBAAM,kBAAkB,OAAO,QAC9B,MAAM,OAAO,OAAO,EACnB,OAAO,CAAC,mBAAmB,CAAC,WAAW,MAAM,MAAK;AACnD,gBAAI,cAAc,SAAS;AACnB,qBAAA;AAAA,YACP;AAED,mBAAO,EAAE,GAAG,mBAAmB,CAAC,SAAS,GAAG,OAAM;AAAA,UACnD,GAAG,CAAE,CAAA;AAEE,iBAAA;AAAA,YACN,GAAG;AAAA,YACH,CAAC,QAAQ,GAAG;AAAA,cACX,GAAG;AAAA,cACH,QAAQ,EAAE,GAAG,MAAM,QAAQ,SAAS,gBAAiB;AAAA,YACrD;AAAA,UAAA;AAAA,QAEH,GACA,CAAE,CAAA;AAGH,eAAO,EAAE,GAAG,gBAAgB,CAAC,MAAM,GAAG,iBAAgB;AAAA,MACvD,GACA,CAAE,CAAA;AAGG,YAAA,KAAK,YAAY,iBAAiB;AAAA,QACvC,OAAO,EAAE,GAAG,WAAW,OAAO,MAAM,iBAAkB;AAAA,MAAA,CACtD;AAAA,IACD,CAAA,CAAC;AAGI,WAAA,EAAE,QAAQ;EAClB;AACA;"}