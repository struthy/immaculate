/// <reference types="node" />
import { SharedSliceContent } from "@prismicio/types-internal/lib/content";
import { CompositeSlice, LegacySlice, SharedSlice, Variation } from "@prismicio/types-internal/lib/customtypes";
import { CallHookReturnType, HookError, SliceAssetUpdateHook, SliceCreateHook, SliceCreateHookData, SliceLibraryReadHookData, SliceReadHookData, SliceRenameHook, SliceRenameHookData, SliceUpdateHook } from "@slicemachine/plugin-kit";
import { DecodeError } from "../../lib/DecodeError";
import { OnlyHookErrors } from "../../types";
import { BaseManager } from "../BaseManager";
type SlicesManagerReadSliceLibraryReturnType = {
    sliceIDs: string[];
    errors: (DecodeError | HookError)[];
};
type SlicesManagerReadAllSliceLibrariesReturnType = {
    libraries: {
        libraryID: string;
        sliceIDs: string[] | undefined;
    }[];
    errors: (DecodeError | HookError)[];
};
type SliceMachineManagerReadAllSlicesForLibraryArgs = {
    libraryID: string;
};
type SliceMachineManagerUpdateSliceArgs = {
    libraryID: string;
    model: SharedSlice;
    mocks?: SharedSliceContent[];
};
type SliceMachineManagerReadAllSlicesForLibraryReturnType = {
    models: {
        model: SharedSlice;
    }[];
    errors: (DecodeError | HookError)[];
};
type SliceMachineManagerReadAllSlicesReturnType = {
    models: {
        libraryID: string;
        model: SharedSlice;
    }[];
    errors: (DecodeError | HookError)[];
};
type SliceMachineManagerReadSliceReturnType = {
    model: SharedSlice | undefined;
    errors: (DecodeError | HookError)[];
};
type SliceMachineManagerPushSliceArgs = {
    libraryID: string;
    sliceID: string;
    userAgent?: string;
};
export type SliceMachineManagerPushSliceReturnType = {
    /**
     * A record of Slice variation IDs mapped to uploaded screenshot URLs.
     */
    screenshotURLs: Record<string, string> | undefined;
    errors: (DecodeError | HookError)[];
};
type SliceMachineManagerReadSliceScreenshotArgs = {
    libraryID: string;
    sliceID: string;
    variationID: string;
};
type SliceMachineManagerReadSliceScreenshotReturnType = {
    data: Buffer | undefined;
    errors: (DecodeError | HookError)[];
};
type SliceMachineManagerUpdateSliceScreenshotArgs = {
    libraryID: string;
    sliceID: string;
    variationID: string;
    data: Buffer;
};
type SliceMachineManagerDeleteSliceScreenshotArgs = {
    libraryID: string;
    sliceID: string;
    variationID: string;
};
type SliceMachineManagerReadSliceMocksArgs = {
    libraryID: string;
    sliceID: string;
};
type SliceMachineManagerReadSliceMocksReturnType = {
    mocks?: SharedSliceContent[];
    errors: (DecodeError | HookError)[];
};
type SliceMachineManagerReadSliceMocksConfigArgs = {
    libraryID: string;
    sliceID: string;
};
type SliceMachineManagerReadSliceMocksConfigArgsReturnType = {
    mocksConfig?: Record<string, unknown>;
    errors: HookError[];
};
type SliceMachineManagerUpdateSliceMocksArgs = {
    libraryID: string;
    sliceID: string;
    mocks: SharedSliceContent[];
};
type SliceMachineManagerUpdateSliceMocksArgsReturnType = {
    errors: HookError[];
};
type SlicesManagerUpsertHostedSliceScrenshotsArgs = {
    libraryID: string;
    model: SharedSlice;
};
type SliceMachineManagerDeleteSliceArgs = {
    libraryID: string;
    sliceID: string;
};
type SliceMachineManagerDeleteSliceReturnType = {
    errors: (DecodeError | HookError)[];
};
type SliceMachineManagerRenameSliceVariationArgs = {
    libraryID: string;
    sliceID: string;
    /**
     * Current ID of the variation to rename.
     */
    variationID: string;
    model: Variation;
};
type SliceMachineManagerRenameSliceVariationReturnType = {
    errors: (DecodeError | HookError)[];
    assetsErrors: (DecodeError | HookError)[];
};
type SliceMachineManagerDeleteSliceVariationArgs = {
    libraryID: string;
    sliceID: string;
    variationID: string;
};
type SliceMachineManagerDeleteSliceVariationReturnType = {
    errors: (DecodeError | HookError)[];
    assetsErrors: (DecodeError | HookError)[];
};
type SliceMachineManagerConvertLegacySliceToSharedSliceArgs = {
    model: CompositeSlice | LegacySlice;
    src: {
        customTypeID: string;
        tabID: string;
        sliceZoneID: string;
        sliceID: string;
    };
    dest: {
        libraryID: string;
        sliceID: string;
        variationName: string;
        variationID: string;
    };
};
type SliceMachineManagerConvertLegacySliceToSharedSliceReturnType = {
    errors: (DecodeError | HookError)[];
};
export declare class SlicesManager extends BaseManager {
    readSliceLibrary(args: SliceLibraryReadHookData): Promise<SlicesManagerReadSliceLibraryReturnType>;
    readAllSliceLibraries(): Promise<SlicesManagerReadAllSliceLibrariesReturnType>;
    readAllSlicesForLibrary(args: SliceMachineManagerReadAllSlicesForLibraryArgs): Promise<SliceMachineManagerReadAllSlicesForLibraryReturnType>;
    readAllSlices(): Promise<SliceMachineManagerReadAllSlicesReturnType>;
    createSlice(args: SliceCreateHookData): Promise<OnlyHookErrors<CallHookReturnType<SliceCreateHook>>>;
    readSlice(args: SliceReadHookData): Promise<SliceMachineManagerReadSliceReturnType>;
    updateSlice(args: SliceMachineManagerUpdateSliceArgs): Promise<OnlyHookErrors<CallHookReturnType<SliceUpdateHook>>>;
    renameSlice(args: SliceRenameHookData): Promise<OnlyHookErrors<CallHookReturnType<SliceRenameHook>>>;
    deleteSlice(args: SliceMachineManagerDeleteSliceArgs): Promise<SliceMachineManagerDeleteSliceReturnType>;
    renameSliceVariation(args: SliceMachineManagerRenameSliceVariationArgs): Promise<SliceMachineManagerRenameSliceVariationReturnType>;
    deleteSliceVariation(args: SliceMachineManagerDeleteSliceVariationArgs): Promise<SliceMachineManagerDeleteSliceVariationReturnType>;
    convertLegacySliceToSharedSlice(args: SliceMachineManagerConvertLegacySliceToSharedSliceArgs): Promise<SliceMachineManagerConvertLegacySliceToSharedSliceReturnType>;
    /**
     * @returns Record of variation IDs mapped to uploaded screenshot URLs.
     */
    pushSlice(args: SliceMachineManagerPushSliceArgs): Promise<SliceMachineManagerPushSliceReturnType>;
    readSliceScreenshot(args: SliceMachineManagerReadSliceScreenshotArgs): Promise<SliceMachineManagerReadSliceScreenshotReturnType>;
    updateSliceScreenshot(args: SliceMachineManagerUpdateSliceScreenshotArgs): Promise<OnlyHookErrors<CallHookReturnType<SliceAssetUpdateHook>>>;
    deleteSliceScreenshot(args: SliceMachineManagerDeleteSliceScreenshotArgs): Promise<OnlyHookErrors<CallHookReturnType<SliceAssetUpdateHook>>>;
    readSliceMocks(args: SliceMachineManagerReadSliceMocksArgs): Promise<SliceMachineManagerReadSliceMocksReturnType>;
    updateSliceMocks(args: SliceMachineManagerUpdateSliceMocksArgs): Promise<SliceMachineManagerUpdateSliceMocksArgsReturnType>;
    readSliceMocksConfig(args: SliceMachineManagerReadSliceMocksConfigArgs): Promise<SliceMachineManagerReadSliceMocksConfigArgsReturnType>;
    fetchRemoteSlices(): Promise<SharedSlice[]>;
    updateSliceModelScreenshotsInPlace(args: SlicesManagerUpsertHostedSliceScrenshotsArgs): Promise<SharedSlice>;
    private _removeSliceFromCustomTypes;
}
export {};
