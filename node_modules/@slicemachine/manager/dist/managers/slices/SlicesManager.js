import * as t from "io-ts";
import * as prismicCustomTypesClient from "@prismicio/custom-types-client";
import { SharedSliceContent } from "@prismicio/types-internal/lib/content";
import { SliceComparator } from "@prismicio/types-internal/lib/customtypes/diff";
import { SharedSlice } from "@prismicio/types-internal/lib/customtypes";
import { assertPluginsInitialized } from "../../lib/assertPluginsInitialized.js";
import { bufferCodec } from "../../lib/bufferCodec.js";
import { decodeHookResult } from "../../lib/decodeHookResult.js";
import { createContentDigest } from "../../lib/createContentDigest.js";
import { mockSlice } from "../../lib/mockSlice.js";
import fetch from "../../lib/fetch.js";
import { DEFAULT_SLICE_SCREENSHOT_URL } from "../../constants/DEFAULT_SLICE_SCREENSHOT_URL.js";
import { SLICE_MACHINE_USER_AGENT } from "../../constants/SLICE_MACHINE_USER_AGENT.js";
import { API_ENDPOINTS } from "../../constants/API_ENDPOINTS.js";
import { UnauthenticatedError, UnauthorizedError } from "../../errors.js";
import { BaseManager } from "../BaseManager.js";
class SlicesManager extends BaseManager {
  async readSliceLibrary(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice-library:read", args);
    const { data, errors } = decodeHookResult(t.type({
      id: t.string,
      sliceIDs: t.array(t.string)
    }), hookResult);
    return {
      sliceIDs: ((_a = data[0]) == null ? void 0 : _a.sliceIDs) ?? [],
      errors
    };
  }
  async readAllSliceLibraries() {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const libraryIDs = sliceMachineConfig.libraries || [];
    const res = {
      libraries: [],
      errors: []
    };
    for (const libraryID of libraryIDs) {
      const { sliceIDs, errors } = await this.readSliceLibrary({
        libraryID
      });
      res.errors = [...res.errors, ...errors];
      res.libraries.push({
        libraryID,
        sliceIDs
      });
    }
    return res;
  }
  async readAllSlicesForLibrary(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const res = {
      models: [],
      errors: []
    };
    const { sliceIDs, errors } = await this.readSliceLibrary({
      libraryID: args.libraryID
    });
    res.errors.push(...errors);
    if (sliceIDs) {
      for (const sliceID of sliceIDs) {
        const { model, errors: errors2 } = await this.readSlice({
          libraryID: args.libraryID,
          sliceID
        });
        res.errors.push(...errors2);
        if (model) {
          res.models.push({ model });
        }
      }
    }
    return res;
  }
  async readAllSlices() {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const libraryIDs = sliceMachineConfig.libraries || [];
    const res = {
      models: [],
      errors: []
    };
    for (const libraryID of libraryIDs) {
      const { models, errors } = await this.readAllSlicesForLibrary({
        libraryID
      });
      res.errors.push(...errors);
      for (const model of models) {
        res.models.push({
          libraryID,
          model: model.model
        });
      }
    }
    return res;
  }
  async createSlice(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:create", args);
    const updateSliceMocksArgs = {
      libraryID: args.libraryID,
      sliceID: args.model.id,
      mocks: mockSlice({ model: args.model })
    };
    const { errors: updateSliceHookErrors } = await this.updateSliceMocks(updateSliceMocksArgs);
    return {
      errors: [...hookResult.errors, ...updateSliceHookErrors]
    };
  }
  async readSlice(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:read", args);
    const { data, errors } = decodeHookResult(t.type({
      model: SharedSlice
    }), hookResult);
    return {
      model: (_a = data[0]) == null ? void 0 : _a.model,
      errors: errors.map((error) => {
        error.message = `Failed to decode slice model with id '${args.sliceID}': ${error.message}`;
        return error;
      })
    };
  }
  async updateSlice(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const { mocks: previousMocks } = await this.readSliceMocks({
      libraryID: args.libraryID,
      sliceID: args.model.id
    });
    const { model: previousModel } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.model.id
    });
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:update", args);
    const updatedMocks = mockSlice({
      model: args.model,
      mocks: previousMocks,
      diff: SliceComparator.compare(previousModel, args.model)
    });
    const updateSliceMocksArgs = {
      libraryID: args.libraryID,
      sliceID: args.model.id,
      mocks: updatedMocks
    };
    const { errors: updateSliceMocksHookResult } = await this.updateSliceMocks(updateSliceMocksArgs);
    return {
      errors: [...hookResult.errors, ...updateSliceMocksHookResult]
    };
  }
  async renameSlice(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:rename", args);
    return {
      errors: hookResult.errors
    };
  }
  async deleteSlice(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const { model, errors: readSliceErrors } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.sliceID
    });
    if (model) {
      const { errors: deleteSliceErrors } = await this.sliceMachinePluginRunner.callHook("slice:delete", {
        model,
        libraryID: args.libraryID
      });
      if (deleteSliceErrors.length > 0) {
        return {
          errors: deleteSliceErrors
        };
      }
      const { errors: updateCustomTypeErrors } = await this._removeSliceFromCustomTypes(args.sliceID);
      return {
        errors: updateCustomTypeErrors
      };
    } else {
      return {
        errors: readSliceErrors
      };
    }
  }
  async renameSliceVariation(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    if (args.variationID !== args.model.id) {
      throw new Error("Renaming variation ID is not supported yet by the backend, only rename its name! For more information, see: https://linear.app/prismic/issue/DT-1708");
    }
    const { model, errors: readSliceErrors } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.sliceID
    });
    if (model) {
      const updatedModel = {
        ...model,
        variations: model.variations.map((variation) => {
          if (variation.id === args.variationID) {
            return args.model;
          } else if (variation.id === args.model.id) {
            throw new Error(`Cannot rename variation \`${args.variationID}\` to \`${args.model.id}\`. A variation already exists with that ID in slice \`${args.sliceID}\` from library \`${args.libraryID}\`, try deleting it first or choose another variation ID to rename that slice.`);
          }
          return variation;
        })
      };
      const updateSliceHookResult = await this.sliceMachinePluginRunner.callHook("slice:update", {
        libraryID: args.libraryID,
        model: updatedModel
      });
      const assetsErrors = [];
      if (args.variationID !== args.model.id) {
        const { data: screenshot, errors: readSliceScreenshotErrors } = await this.readSliceScreenshot({
          libraryID: args.libraryID,
          sliceID: args.sliceID,
          variationID: args.variationID
        });
        assetsErrors.push(...readSliceScreenshotErrors);
        if (screenshot) {
          const { errors: deleteSliceScreenshotErrors } = await this.deleteSliceScreenshot({
            libraryID: args.libraryID,
            sliceID: args.sliceID,
            variationID: args.variationID
          });
          assetsErrors.push(...deleteSliceScreenshotErrors);
          const { errors: updateSliceScreenshotErrors } = await this.updateSliceScreenshot({
            libraryID: args.libraryID,
            sliceID: args.sliceID,
            variationID: args.model.id,
            data: screenshot
          });
          assetsErrors.push(...updateSliceScreenshotErrors);
        }
        const { mocks, errors: readSliceMocksErrors } = await this.readSliceMocks({
          libraryID: args.libraryID,
          sliceID: args.sliceID
        });
        assetsErrors.push(...readSliceMocksErrors);
        if (mocks == null ? void 0 : mocks.length) {
          const { errors: updateSliceMocksErrors } = await this.updateSliceMocks({
            libraryID: args.libraryID,
            sliceID: args.sliceID,
            mocks: mocks.map((mock) => {
              if (mock.variation === args.variationID) {
                return {
                  ...mock,
                  variation: args.model.id
                };
              }
              return mock;
            })
          });
          assetsErrors.push(...updateSliceMocksErrors);
        }
      }
      return {
        errors: updateSliceHookResult.errors,
        assetsErrors
      };
    } else {
      return {
        errors: readSliceErrors,
        assetsErrors: []
      };
    }
  }
  async deleteSliceVariation(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const { model, errors: readSliceErrors } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.sliceID
    });
    if (model) {
      const updatedModel = {
        ...model,
        variations: model.variations.filter((variation) => variation.id !== args.variationID)
      };
      const updateSliceHookResult = await this.sliceMachinePluginRunner.callHook("slice:update", {
        libraryID: args.libraryID,
        model: updatedModel
      });
      const { errors: deleteSliceScreenshotErrors } = await this.deleteSliceScreenshot(args);
      const { mocks, errors: readSliceMocksErrors } = await this.readSliceMocks({
        libraryID: args.libraryID,
        sliceID: args.sliceID
      });
      let updateSliceMocksErrors = [];
      if (mocks == null ? void 0 : mocks.length) {
        updateSliceMocksErrors = (await this.updateSliceMocks({
          libraryID: args.libraryID,
          sliceID: args.sliceID,
          mocks: mocks.filter((mock) => mock.variation !== args.variationID)
        })).errors;
      }
      return {
        errors: updateSliceHookResult.errors,
        assetsErrors: [
          ...deleteSliceScreenshotErrors,
          ...readSliceMocksErrors,
          ...updateSliceMocksErrors
        ]
      };
    } else {
      return {
        errors: readSliceErrors,
        assetsErrors: []
      };
    }
  }
  async convertLegacySliceToSharedSlice(args) {
    var _a, _b;
    const errors = [];
    const { model: maybeExistingSlice } = await this.readSlice({
      libraryID: args.dest.libraryID,
      sliceID: args.dest.sliceID
    });
    const legacySliceAsVariation = {
      id: args.dest.variationID,
      name: args.dest.variationName,
      description: args.dest.variationName,
      imageUrl: "",
      docURL: "",
      version: "initial",
      primary: {},
      items: {}
    };
    switch (args.model.type) {
      case "Slice":
        legacySliceAsVariation.primary = args.model["non-repeat"];
        legacySliceAsVariation.items = args.model.repeat;
        break;
      case "Group":
        legacySliceAsVariation.items = ((_a = args.model.config) == null ? void 0 : _a.fields) ?? {};
        break;
      default:
        legacySliceAsVariation.primary = { [args.src.sliceID]: args.model };
        break;
    }
    if (maybeExistingSlice) {
      const maybeVariation = maybeExistingSlice.variations.find((variation) => variation.id === args.dest.variationID);
      if (!maybeVariation) {
        maybeExistingSlice.variations = [
          ...maybeExistingSlice.variations,
          legacySliceAsVariation
        ];
      }
      maybeExistingSlice.legacyPaths || (maybeExistingSlice.legacyPaths = {});
      maybeExistingSlice.legacyPaths[`${args.src.customTypeID}::${args.src.sliceZoneID}::${args.src.sliceID}`] = args.dest.variationID;
      await this.updateSlice({
        libraryID: args.dest.libraryID,
        model: maybeExistingSlice
      });
    } else {
      await this.createSlice({
        libraryID: args.dest.libraryID,
        model: {
          id: args.dest.sliceID,
          type: "SharedSlice",
          name: args.dest.sliceID,
          legacyPaths: {
            [`${args.src.customTypeID}::${args.src.sliceZoneID}::${args.src.sliceID}`]: args.dest.variationID
          },
          variations: [legacySliceAsVariation]
        }
      });
    }
    const { model: customType, errors: customTypeReadErrors } = await this.customTypes.readCustomType({
      id: args.src.customTypeID
    });
    errors.push(...customTypeReadErrors);
    if (customType) {
      const field = customType.json[args.src.tabID][args.src.sliceZoneID];
      if (field.type === "Slices" && ((_b = field.config) == null ? void 0 : _b.choices)) {
        delete field.config.choices[args.src.sliceID];
        field.config.choices[args.dest.sliceID] = {
          type: "SharedSlice"
        };
      }
      const { errors: customTypeUpdateErrors } = await this.customTypes.updateCustomType({ model: customType });
      errors.push(...customTypeUpdateErrors);
    }
    return { errors };
  }
  /**
   * @returns Record of variation IDs mapped to uploaded screenshot URLs.
   */
  async pushSlice(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    if (!await this.user.checkIsLoggedIn()) {
      throw new UnauthenticatedError();
    }
    const { model, errors: readSliceErrors } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.sliceID
    });
    if (model) {
      const modelWithScreenshots = await this.updateSliceModelScreenshotsInPlace({
        libraryID: args.libraryID,
        model
      });
      const authenticationToken = await this.user.getAuthenticationToken();
      const repositoryName = await this.project.getResolvedRepositoryName();
      const client = prismicCustomTypesClient.createClient({
        endpoint: API_ENDPOINTS.PrismicModels,
        repositoryName,
        token: authenticationToken,
        fetch,
        fetchOptions: {
          headers: {
            "User-Agent": args.userAgent || SLICE_MACHINE_USER_AGENT
          }
        }
      });
      try {
        await client.getSharedSliceByID(args.sliceID);
        await client.updateSharedSlice(modelWithScreenshots);
      } catch (error) {
        if (error instanceof prismicCustomTypesClient.NotFoundError) {
          await client.insertSharedSlice(modelWithScreenshots);
        } else if (error instanceof prismicCustomTypesClient.ForbiddenError) {
          throw new UnauthorizedError("You do not have access to push Slices to this Prismic repository.");
        } else {
          throw error;
        }
      }
      const screenshotURLs = {};
      for (const variation of modelWithScreenshots.variations) {
        screenshotURLs[variation.id] = variation.imageUrl;
      }
      return {
        screenshotURLs,
        errors: readSliceErrors
      };
    } else {
      return {
        screenshotURLs: void 0,
        errors: readSliceErrors
      };
    }
  }
  async readSliceScreenshot(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:read", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      assetID: `screenshot-${args.variationID}.png`
    });
    const { data, errors } = decodeHookResult(t.type({
      data: bufferCodec
    }), hookResult);
    return {
      data: (_a = data[0]) == null ? void 0 : _a.data,
      errors
    };
  }
  async updateSliceScreenshot(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:update", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      asset: {
        id: `screenshot-${args.variationID}.png`,
        data: args.data
      }
    });
    return {
      errors: hookResult.errors
    };
  }
  async deleteSliceScreenshot(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:delete", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      assetID: `screenshot-${args.variationID}.png`
    });
    return {
      errors: hookResult.errors
    };
  }
  async readSliceMocks(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:read", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      assetID: `mocks.json`
    });
    const { data, errors } = decodeHookResult(t.type({
      data: t.array(SharedSliceContent)
    }), {
      ...hookResult,
      // Convert the asset data from a Buffer to JSON
      // to prepare it for validation.
      data: hookResult.data.map((result) => {
        try {
          return {
            ...result,
            data: JSON.parse(result.data.toString())
          };
        } catch {
          return result;
        }
      })
    });
    if (data) {
      return {
        mocks: (_a = data[0]) == null ? void 0 : _a.data,
        errors
      };
    } else {
      return {
        mocks: [],
        errors
      };
    }
  }
  async updateSliceMocks(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:update", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      asset: {
        id: "mocks.json",
        data: Buffer.from(JSON.stringify(args.mocks, null, "	"))
      }
    });
    return {
      errors: hookResult.errors
    };
  }
  // TODO: Remove
  async readSliceMocksConfig(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:read", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      assetID: "mocks.config.json"
    });
    const data = (_a = hookResult.data[0]) == null ? void 0 : _a.data;
    if (data) {
      return {
        mocksConfig: JSON.parse(data.toString()),
        errors: hookResult.errors
      };
    } else {
      return {
        mocksConfig: void 0,
        errors: hookResult.errors
      };
    }
  }
  async fetchRemoteSlices() {
    const authenticationToken = await this.user.getAuthenticationToken();
    const repositoryName = await this.project.getResolvedRepositoryName();
    const client = prismicCustomTypesClient.createClient({
      endpoint: API_ENDPOINTS.PrismicModels,
      repositoryName,
      token: authenticationToken,
      fetch,
      fetchOptions: {
        headers: {
          "User-Agent": SLICE_MACHINE_USER_AGENT
        }
      }
    });
    return await client.getAllSharedSlices();
  }
  async updateSliceModelScreenshotsInPlace(args) {
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const variations = await Promise.all(args.model.variations.map(async (variation) => {
      var _a;
      const screenshot = await this.readSliceScreenshot({
        libraryID: args.libraryID,
        sliceID: args.model.id,
        variationID: variation.id
      });
      if (!screenshot.data) {
        return {
          ...variation,
          imageUrl: DEFAULT_SLICE_SCREENSHOT_URL
        };
      }
      const hasScreenshotChanged = !((_a = variation.imageUrl) == null ? void 0 : _a.includes(createContentDigest(screenshot.data)));
      if (!hasScreenshotChanged) {
        return variation;
      }
      const keyPrefix = [
        sliceMachineConfig.repositoryName,
        "shared-slices",
        args.model.id,
        variation.id
      ].join("/");
      const uploadedScreenshot = await this.screenshots.uploadScreenshot({
        data: screenshot.data,
        keyPrefix
      });
      return {
        ...variation,
        imageUrl: uploadedScreenshot.url
      };
    }));
    return {
      ...args.model,
      variations
    };
  }
  async _removeSliceFromCustomTypes(sliceID) {
    const { models, errors: customTypeReadErrors } = await this.customTypes.readAllCustomTypes();
    await Promise.all(models.map(async (customType) => {
      const updatedJsonModel = Object.entries(customType.model.json).reduce((tabAccumulator, [tabKey, tab]) => {
        const updatedTabFields = Object.entries(tab).reduce((fieldAccumulator, [fieldKey, field]) => {
          if (field.config === void 0 || field.type !== "Slices" || field.config.choices === void 0) {
            return { ...fieldAccumulator, [fieldKey]: field };
          }
          const filteredChoices = Object.entries(field.config.choices).reduce((choiceAccumulator, [choiceKey, choice]) => {
            if (choiceKey === sliceID) {
              return choiceAccumulator;
            }
            return { ...choiceAccumulator, [choiceKey]: choice };
          }, {});
          return {
            ...fieldAccumulator,
            [fieldKey]: {
              ...field,
              config: { ...field.config, choices: filteredChoices }
            }
          };
        }, {});
        return { ...tabAccumulator, [tabKey]: updatedTabFields };
      }, {});
      await this.customTypes.updateCustomType({
        model: { ...customType.model, json: updatedJsonModel }
      });
    }));
    return { errors: customTypeReadErrors };
  }
}
export {
  SlicesManager
};
//# sourceMappingURL=SlicesManager.js.map
