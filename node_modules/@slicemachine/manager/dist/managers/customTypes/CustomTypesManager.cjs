"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("io-ts");
const prismicCustomTypesClient = require("@prismicio/custom-types-client");
const customtypes = require("@prismicio/types-internal/lib/customtypes");
const assertPluginsInitialized = require("../../lib/assertPluginsInitialized.cjs");
const decodeHookResult = require("../../lib/decodeHookResult.cjs");
const fetch = require("../../lib/fetch.cjs");
const API_ENDPOINTS = require("../../constants/API_ENDPOINTS.cjs");
const SLICE_MACHINE_USER_AGENT = require("../../constants/SLICE_MACHINE_USER_AGENT.cjs");
const errors = require("../../errors.cjs");
const BaseManager = require("../BaseManager.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const prismicCustomTypesClient__namespace = /* @__PURE__ */ _interopNamespaceDefault(prismicCustomTypesClient);
class CustomTypesManager extends BaseManager.BaseManager {
  async readCustomTypeLibrary() {
    var _a;
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type-library:read", void 0);
    const { data, errors: errors2 } = decodeHookResult.decodeHookResult(t__namespace.type({
      ids: t__namespace.array(t__namespace.string)
    }), hookResult);
    return {
      ids: ((_a = data[0]) == null ? void 0 : _a.ids) || [],
      errors: errors2
    };
  }
  async readAllCustomTypes(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const res = {
      models: [],
      errors: []
    };
    const { ids, errors: errors2 } = await this.readCustomTypeLibrary();
    res.errors = [...res.errors, ...errors2];
    if (ids) {
      for (const id of ids) {
        const { model, errors: errors22 } = await this.readCustomType({ id });
        res.errors = [...res.errors, ...errors22];
        if (model && (!args || args.format === model.format)) {
          res.models.push({ model });
        }
      }
    }
    return res;
  }
  async createCustomType(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:create", args);
    return {
      errors: hookResult.errors
    };
  }
  async readCustomType(args) {
    var _a;
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:read", args);
    const { data, errors: errors2 } = decodeHookResult.decodeHookResult(t__namespace.type({
      model: customtypes.CustomType
    }), hookResult);
    return {
      model: (_a = data[0]) == null ? void 0 : _a.model,
      errors: errors2
    };
  }
  async updateCustomType(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:update", args);
    return {
      errors: hookResult.errors
    };
  }
  async renameCustomType(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:rename", args);
    return {
      errors: hookResult.errors
    };
  }
  async deleteCustomType(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const { model, errors: readCustomTypeErrors } = await this.readCustomType({
      id: args.id
    });
    if (model) {
      const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:delete", { model });
      return {
        errors: hookResult.errors
      };
    } else {
      return {
        errors: readCustomTypeErrors
      };
    }
  }
  async pushCustomType(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const authenticationToken = await this.user.getAuthenticationToken();
    const repositoryName = await this.project.getResolvedRepositoryName();
    const { model } = await this.readCustomType({ id: args.id });
    if (model) {
      const client = prismicCustomTypesClient__namespace.createClient({
        endpoint: API_ENDPOINTS.API_ENDPOINTS.PrismicModels,
        repositoryName,
        token: authenticationToken,
        fetch: fetch.default,
        fetchOptions: {
          headers: {
            "User-Agent": args.userAgent || SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT
          }
        }
      });
      try {
        await client.getCustomTypeByID(args.id);
        await client.updateCustomType(model);
      } catch (error) {
        if (error instanceof prismicCustomTypesClient__namespace.NotFoundError) {
          await client.insertCustomType(model);
        } else if (error instanceof prismicCustomTypesClient__namespace.ForbiddenError) {
          throw new errors.UnauthorizedError("You do not have access to push types to this Prismic repository.", {
            cause: error
          });
        } else {
          throw error;
        }
      }
    }
  }
  // TODO: Remove
  async readCustomTypeMocksConfig(args) {
    var _a;
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:asset:read", {
      customTypeID: args.customTypeID,
      assetID: "mocks.config.json"
    });
    const data = (_a = hookResult.data[0]) == null ? void 0 : _a.data;
    if (data) {
      return {
        mocksConfig: JSON.parse(data.toString()),
        errors: hookResult.errors
      };
    } else {
      return {
        mocksConfig: void 0,
        errors: hookResult.errors
      };
    }
  }
  // TODO: Remove
  async updateCustomTypeMocksConfig(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:asset:update", {
      customTypeID: args.customTypeID,
      asset: {
        id: "mocks.config.json",
        data: Buffer.from(JSON.stringify(args.mocksConfig, null, "	"))
      }
    });
    return {
      errors: hookResult.errors
    };
  }
  async fetchRemoteCustomTypes() {
    const authenticationToken = await this.user.getAuthenticationToken();
    const repositoryName = await this.project.getResolvedRepositoryName();
    const client = prismicCustomTypesClient__namespace.createClient({
      endpoint: API_ENDPOINTS.API_ENDPOINTS.PrismicModels,
      repositoryName,
      token: authenticationToken,
      fetch: fetch.default,
      fetchOptions: {
        headers: {
          "User-Agent": SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT
        }
      }
    });
    return await client.getAllCustomTypes();
  }
}
exports.CustomTypesManager = CustomTypesManager;
//# sourceMappingURL=CustomTypesManager.cjs.map
