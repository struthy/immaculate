import * as t from "io-ts";
import * as prismicCustomTypesClient from "@prismicio/custom-types-client";
import { CustomType } from "@prismicio/types-internal/lib/customtypes";
import { assertPluginsInitialized } from "../../lib/assertPluginsInitialized.js";
import { decodeHookResult } from "../../lib/decodeHookResult.js";
import fetch from "../../lib/fetch.js";
import { API_ENDPOINTS } from "../../constants/API_ENDPOINTS.js";
import { SLICE_MACHINE_USER_AGENT } from "../../constants/SLICE_MACHINE_USER_AGENT.js";
import { UnauthorizedError } from "../../errors.js";
import { BaseManager } from "../BaseManager.js";
class CustomTypesManager extends BaseManager {
  async readCustomTypeLibrary() {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type-library:read", void 0);
    const { data, errors } = decodeHookResult(t.type({
      ids: t.array(t.string)
    }), hookResult);
    return {
      ids: ((_a = data[0]) == null ? void 0 : _a.ids) || [],
      errors
    };
  }
  async readAllCustomTypes(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const res = {
      models: [],
      errors: []
    };
    const { ids, errors } = await this.readCustomTypeLibrary();
    res.errors = [...res.errors, ...errors];
    if (ids) {
      for (const id of ids) {
        const { model, errors: errors2 } = await this.readCustomType({ id });
        res.errors = [...res.errors, ...errors2];
        if (model && (!args || args.format === model.format)) {
          res.models.push({ model });
        }
      }
    }
    return res;
  }
  async createCustomType(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:create", args);
    return {
      errors: hookResult.errors
    };
  }
  async readCustomType(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:read", args);
    const { data, errors } = decodeHookResult(t.type({
      model: CustomType
    }), hookResult);
    return {
      model: (_a = data[0]) == null ? void 0 : _a.model,
      errors
    };
  }
  async updateCustomType(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:update", args);
    return {
      errors: hookResult.errors
    };
  }
  async renameCustomType(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:rename", args);
    return {
      errors: hookResult.errors
    };
  }
  async deleteCustomType(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const { model, errors: readCustomTypeErrors } = await this.readCustomType({
      id: args.id
    });
    if (model) {
      const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:delete", { model });
      return {
        errors: hookResult.errors
      };
    } else {
      return {
        errors: readCustomTypeErrors
      };
    }
  }
  async pushCustomType(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const authenticationToken = await this.user.getAuthenticationToken();
    const repositoryName = await this.project.getResolvedRepositoryName();
    const { model } = await this.readCustomType({ id: args.id });
    if (model) {
      const client = prismicCustomTypesClient.createClient({
        endpoint: API_ENDPOINTS.PrismicModels,
        repositoryName,
        token: authenticationToken,
        fetch,
        fetchOptions: {
          headers: {
            "User-Agent": args.userAgent || SLICE_MACHINE_USER_AGENT
          }
        }
      });
      try {
        await client.getCustomTypeByID(args.id);
        await client.updateCustomType(model);
      } catch (error) {
        if (error instanceof prismicCustomTypesClient.NotFoundError) {
          await client.insertCustomType(model);
        } else if (error instanceof prismicCustomTypesClient.ForbiddenError) {
          throw new UnauthorizedError("You do not have access to push types to this Prismic repository.", {
            cause: error
          });
        } else {
          throw error;
        }
      }
    }
  }
  // TODO: Remove
  async readCustomTypeMocksConfig(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:asset:read", {
      customTypeID: args.customTypeID,
      assetID: "mocks.config.json"
    });
    const data = (_a = hookResult.data[0]) == null ? void 0 : _a.data;
    if (data) {
      return {
        mocksConfig: JSON.parse(data.toString()),
        errors: hookResult.errors
      };
    } else {
      return {
        mocksConfig: void 0,
        errors: hookResult.errors
      };
    }
  }
  // TODO: Remove
  async updateCustomTypeMocksConfig(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:asset:update", {
      customTypeID: args.customTypeID,
      asset: {
        id: "mocks.config.json",
        data: Buffer.from(JSON.stringify(args.mocksConfig, null, "	"))
      }
    });
    return {
      errors: hookResult.errors
    };
  }
  async fetchRemoteCustomTypes() {
    const authenticationToken = await this.user.getAuthenticationToken();
    const repositoryName = await this.project.getResolvedRepositoryName();
    const client = prismicCustomTypesClient.createClient({
      endpoint: API_ENDPOINTS.PrismicModels,
      repositoryName,
      token: authenticationToken,
      fetch,
      fetchOptions: {
        headers: {
          "User-Agent": SLICE_MACHINE_USER_AGENT
        }
      }
    });
    return await client.getAllCustomTypes();
  }
}
export {
  CustomTypesManager
};
//# sourceMappingURL=CustomTypesManager.js.map
