"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const fs = require("node:fs/promises");
const node_fs = require("node:fs");
const path = require("node:path");
const node_module = require("node:module");
const ni = require("@antfu/ni");
const t = require("io-ts");
const assertPluginsInitialized = require("../../lib/assertPluginsInitialized.cjs");
const decodeHookResult = require("../../lib/decodeHookResult.cjs");
const decodeSliceMachineConfig = require("../../lib/decodeSliceMachineConfig.cjs");
const findEnvironment = require("../../lib/findEnvironment.cjs");
const format = require("../../lib/format.cjs");
const installDependencies = require("../../lib/installDependencies.cjs");
const locateFileUpward = require("../../lib/locateFileUpward.cjs");
const errors = require("../../errors.cjs");
const SLICE_MACHINE_CONFIG_FILENAME = require("../../constants/SLICE_MACHINE_CONFIG_FILENAME.cjs");
const TS_CONFIG_FILENAME = require("../../constants/TS_CONFIG_FILENAME.cjs");
const SLICE_MACHINE_NPM_PACKAGE_NAME = require("../../constants/SLICE_MACHINE_NPM_PACKAGE_NAME.cjs");
const BaseManager = require("../BaseManager.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs);
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
class ProjectManager extends BaseManager.BaseManager {
  constructor() {
    super(...arguments);
    __publicField(this, "_cachedRoot");
    __publicField(this, "_cachedSliceMachineConfigPath");
    __publicField(this, "_cachedSliceMachineConfig");
    __publicField(this, "_cachedEnvironments");
  }
  async getSliceMachineConfigPath(args) {
    if (this._cachedSliceMachineConfigPath && !(args == null ? void 0 : args.ignoreCache)) {
      return this._cachedSliceMachineConfigPath;
    }
    try {
      this._cachedSliceMachineConfigPath = await locateFileUpward.locateFileUpward(SLICE_MACHINE_CONFIG_FILENAME.SLICE_MACHINE_CONFIG_FILENAME, { startDir: this.cwd });
    } catch (error) {
      throw new Error(`Could not find a ${SLICE_MACHINE_CONFIG_FILENAME.SLICE_MACHINE_CONFIG_FILENAME} file. Please create a config file at the root of your project.`);
    }
    return this._cachedSliceMachineConfigPath;
  }
  async getRoot(args) {
    if (this._cachedRoot && !(args == null ? void 0 : args.ignoreCache)) {
      return this._cachedRoot;
    }
    const sliceMachineConfigFilePath = await this.getSliceMachineConfigPath({
      ignoreCache: args == null ? void 0 : args.ignoreCache
    });
    this._cachedRoot = path__namespace.dirname(sliceMachineConfigFilePath);
    return this._cachedRoot;
  }
  async suggestRoot() {
    const suggestedRootPackageJSON = await locateFileUpward.locateFileUpward("package.json", {
      startDir: this.cwd
    });
    return path__namespace.dirname(suggestedRootPackageJSON);
  }
  async suggestSliceMachineConfigPath() {
    const suggestedRoot = await this.suggestRoot();
    return path__namespace.resolve(suggestedRoot, SLICE_MACHINE_CONFIG_FILENAME.SLICE_MACHINE_CONFIG_FILENAME);
  }
  async checkIsTypeScript(args) {
    const root = (args == null ? void 0 : args.rootOverride) || await this.getRoot();
    const rootTSConfigPath = path__namespace.resolve(root, TS_CONFIG_FILENAME.TS_CONFIG_FILENAME);
    return node_fs.existsSync(rootTSConfigPath);
  }
  async getSliceMachineConfig() {
    if (this._cachedSliceMachineConfig) {
      return this._cachedSliceMachineConfig;
    } else {
      return await this.loadSliceMachineConfig();
    }
  }
  async writeSliceMachineConfig(args) {
    const configFilePath = args.path || await this.getSliceMachineConfigPath();
    const config = await format.format(JSON.stringify(args.config, null, 2), configFilePath);
    await fs__namespace.writeFile(configFilePath, config, "utf-8");
    delete this._cachedSliceMachineConfig;
  }
  async loadSliceMachineConfig() {
    const configFilePath = await this.getSliceMachineConfigPath();
    let rawConfig;
    try {
      const contents = await fs__namespace.readFile(configFilePath, "utf8");
      rawConfig = JSON.parse(contents);
    } catch (error2) {
      if (error2 instanceof SyntaxError) {
        throw new errors.SliceMachineError(`Could not parse config file at ${configFilePath}.

Error Message: ${error2.message}`);
      }
    }
    if (!rawConfig) {
      throw new Error("No config found.");
    }
    const { value: sliceMachineConfig, error } = decodeSliceMachineConfig.decodeSliceMachineConfig(rawConfig);
    if (error) {
      throw new Error(`Invalid config. ${error.errors.join(", ")}`, {
        cause: { rawConfig }
      });
    }
    this._cachedSliceMachineConfig = sliceMachineConfig;
    return sliceMachineConfig;
  }
  async locateSliceMachineUIDir() {
    const projectRoot = await this.getRoot();
    const require2 = node_module.createRequire(path__namespace.join(projectRoot, "index.js"));
    const sliceMachinePackageJSONPath = require2.resolve(`${SLICE_MACHINE_NPM_PACKAGE_NAME.SLICE_MACHINE_NPM_PACKAGE_NAME}/package.json`);
    return path__namespace.dirname(sliceMachinePackageJSONPath);
  }
  /**
   * Returns the project's repository name (i.e. the production environment). It
   * ignores the currently selected environment.
   *
   * Use this method to retrieve the production environment domain.
   *
   * @returns The project's repository name.
   */
  async getRepositoryName() {
    const sliceMachineConfig = await this.getSliceMachineConfig();
    return sliceMachineConfig.repositoryName;
  }
  /**
   * Returns the currently selected environment domain if set. If an environment
   * is not set, it returns the project's repository name (the production
   * environment).
   *
   * Use this method to retrieve the repository name to be sent with Prismic API
   * requests.
   *
   * @returns The resolved repository name.
   */
  async getResolvedRepositoryName() {
    const repositoryName = await this.getRepositoryName();
    const supportsEnvironments = this.project.checkSupportsEnvironments();
    if (!supportsEnvironments) {
      return repositoryName;
    }
    const { environment } = await this.project.readEnvironment();
    return environment ?? repositoryName;
  }
  async getAdapterName() {
    const sliceMachineConfig = await this.getSliceMachineConfig();
    const adapterName = typeof sliceMachineConfig.adapter === "string" ? sliceMachineConfig.adapter : sliceMachineConfig.adapter.resolve;
    return adapterName;
  }
  async locateAdapterDir() {
    const projectRoot = await this.getRoot();
    const adapterName = await this.getAdapterName();
    const require2 = node_module.createRequire(path__namespace.join(projectRoot, "index.js"));
    const adapterPackageJSONPath = require2.resolve(`${adapterName}/package.json`);
    return path__namespace.dirname(adapterPackageJSONPath);
  }
  async initProject(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const log = (args == null ? void 0 : args.log) || console.log.bind(this);
    const { errors: errors$1 } = await this.sliceMachinePluginRunner.callHook("project:init", {
      log,
      installDependencies: async (args2) => {
        const { execaProcess } = await this.installDependencies({
          dependencies: args2.dependencies,
          dev: args2.dev,
          log
        });
        await execaProcess;
      }
    });
    if (errors$1.length > 0) {
      throw new errors.SliceMachineError(`Failed to initialize project: ${errors$1.join(", ")}`);
    }
  }
  async detectPackageManager(args) {
    const projectRoot = (args == null ? void 0 : args.root) || await this.getRoot();
    const packageManager = await ni.detect({
      autoInstall: true,
      cwd: projectRoot
    });
    return packageManager || "npm";
  }
  async installDependencies(args) {
    var _a, _b;
    const packageManager = args.packageManager || await this.detectPackageManager();
    const log = args.log || console.log.bind(this);
    const wrappedLogger = (data) => {
      if (data instanceof Buffer) {
        log(data.toString());
      } else if (typeof data === "string") {
        log(data);
      }
    };
    try {
      const { execaProcess } = await installDependencies.installDependencies({
        packageManager,
        dependencies: args.dependencies,
        dev: args.dev
      });
      if (process.stdout.isTTY || process.env.NODE_ENV === "test") {
        (_a = execaProcess.stdout) == null ? void 0 : _a.on("data", wrappedLogger);
      }
      (_b = execaProcess.stderr) == null ? void 0 : _b.on("data", wrappedLogger);
      return {
        execaProcess
      };
    } catch (error) {
      if (error instanceof Error && "shortMessage" in error && "stderr" in error) {
        throw new errors.InternalError("Package installation failed", {
          cause: error
        });
      }
      throw error;
    }
  }
  checkSupportsEnvironments() {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    return this.sliceMachinePluginRunner.hooksForType("project:environment:read").length > 0 && this.sliceMachinePluginRunner.hooksForType("project:environment:update").length > 0;
  }
  async readEnvironment() {
    var _a, _b;
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    await this._assertAdapterSupportsEnvironments();
    const hookResult = await this.sliceMachinePluginRunner.callHook("project:environment:read", void 0);
    const { data, errors: errors2 } = decodeHookResult.decodeHookResult(t__namespace.type({
      environment: t__namespace.union([t__namespace.undefined, t__namespace.string])
    }), hookResult);
    const repositoryName = await this.project.getRepositoryName();
    const environmentDomain = ((_a = data[0]) == null ? void 0 : _a.environment) === repositoryName ? void 0 : (_b = data[0]) == null ? void 0 : _b.environment;
    return {
      environment: environmentDomain,
      errors: errors2
    };
  }
  async updateEnvironment(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    await this._assertAdapterSupportsEnvironments();
    const repositoryName = await this.project.getRepositoryName();
    const environment = args.environment === repositoryName ? void 0 : args.environment;
    const hookResult = await this.sliceMachinePluginRunner.callHook("project:environment:update", { environment });
    return {
      errors: hookResult.errors
    };
  }
  async fetchActiveEnvironment() {
    const { environment: activeEnvironmentDomain } = await this.readEnvironment();
    const cachedActiveEnvironment = findEnvironment.findEnvironment(activeEnvironmentDomain, this._cachedEnvironments || []);
    if (cachedActiveEnvironment) {
      return { activeEnvironment: cachedActiveEnvironment };
    }
    const { environments } = await this.prismicRepository.fetchEnvironments();
    if (environments) {
      this._cachedEnvironments = environments;
    }
    const activeEnvironment = findEnvironment.findEnvironment(activeEnvironmentDomain, this._cachedEnvironments || []);
    if (!activeEnvironment) {
      throw new errors.InvalidActiveEnvironmentError();
    }
    return { activeEnvironment };
  }
  async detectVersionControlSystem() {
    try {
      const projectRoot = await this.getRoot();
      if (node_fs.existsSync(path__namespace.join(projectRoot, ".git"))) {
        return "Git";
      }
      if (node_fs.existsSync(path__namespace.join(projectRoot, ".svn"))) {
        return "SVN";
      }
      if (node_fs.existsSync(path__namespace.join(projectRoot, ".hg"))) {
        return "Mercurial";
      }
      if (node_fs.existsSync(path__namespace.join(projectRoot, "CVS"))) {
        return "CVS";
      }
    } catch (error) {
    }
    return "_unknown";
  }
  async _assertAdapterSupportsEnvironments() {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const supportsEnvironments = this.checkSupportsEnvironments();
    if (!supportsEnvironments) {
      const adapterName = await this.project.getAdapterName();
      throw new errors.PluginError(`${adapterName} does not support environments. Use an adapter that implements the \`project:environment:read\` and \`project:environment:update\` hooks to use environments.`);
    }
  }
}
exports.ProjectManager = ProjectManager;
//# sourceMappingURL=ProjectManager.cjs.map
