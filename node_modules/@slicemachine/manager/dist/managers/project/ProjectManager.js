var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as fs from "node:fs/promises";
import { existsSync } from "node:fs";
import * as path from "node:path";
import { createRequire } from "node:module";
import { detect } from "@antfu/ni";
import * as t from "io-ts";
import { assertPluginsInitialized } from "../../lib/assertPluginsInitialized.js";
import { decodeHookResult } from "../../lib/decodeHookResult.js";
import { decodeSliceMachineConfig } from "../../lib/decodeSliceMachineConfig.js";
import { findEnvironment } from "../../lib/findEnvironment.js";
import { format } from "../../lib/format.js";
import { installDependencies } from "../../lib/installDependencies.js";
import { locateFileUpward } from "../../lib/locateFileUpward.js";
import { SliceMachineError, InternalError, InvalidActiveEnvironmentError, PluginError } from "../../errors.js";
import { SLICE_MACHINE_CONFIG_FILENAME } from "../../constants/SLICE_MACHINE_CONFIG_FILENAME.js";
import { TS_CONFIG_FILENAME } from "../../constants/TS_CONFIG_FILENAME.js";
import { SLICE_MACHINE_NPM_PACKAGE_NAME } from "../../constants/SLICE_MACHINE_NPM_PACKAGE_NAME.js";
import { BaseManager } from "../BaseManager.js";
class ProjectManager extends BaseManager {
  constructor() {
    super(...arguments);
    __publicField(this, "_cachedRoot");
    __publicField(this, "_cachedSliceMachineConfigPath");
    __publicField(this, "_cachedSliceMachineConfig");
    __publicField(this, "_cachedEnvironments");
  }
  async getSliceMachineConfigPath(args) {
    if (this._cachedSliceMachineConfigPath && !(args == null ? void 0 : args.ignoreCache)) {
      return this._cachedSliceMachineConfigPath;
    }
    try {
      this._cachedSliceMachineConfigPath = await locateFileUpward(SLICE_MACHINE_CONFIG_FILENAME, { startDir: this.cwd });
    } catch (error) {
      throw new Error(`Could not find a ${SLICE_MACHINE_CONFIG_FILENAME} file. Please create a config file at the root of your project.`);
    }
    return this._cachedSliceMachineConfigPath;
  }
  async getRoot(args) {
    if (this._cachedRoot && !(args == null ? void 0 : args.ignoreCache)) {
      return this._cachedRoot;
    }
    const sliceMachineConfigFilePath = await this.getSliceMachineConfigPath({
      ignoreCache: args == null ? void 0 : args.ignoreCache
    });
    this._cachedRoot = path.dirname(sliceMachineConfigFilePath);
    return this._cachedRoot;
  }
  async suggestRoot() {
    const suggestedRootPackageJSON = await locateFileUpward("package.json", {
      startDir: this.cwd
    });
    return path.dirname(suggestedRootPackageJSON);
  }
  async suggestSliceMachineConfigPath() {
    const suggestedRoot = await this.suggestRoot();
    return path.resolve(suggestedRoot, SLICE_MACHINE_CONFIG_FILENAME);
  }
  async checkIsTypeScript(args) {
    const root = (args == null ? void 0 : args.rootOverride) || await this.getRoot();
    const rootTSConfigPath = path.resolve(root, TS_CONFIG_FILENAME);
    return existsSync(rootTSConfigPath);
  }
  async getSliceMachineConfig() {
    if (this._cachedSliceMachineConfig) {
      return this._cachedSliceMachineConfig;
    } else {
      return await this.loadSliceMachineConfig();
    }
  }
  async writeSliceMachineConfig(args) {
    const configFilePath = args.path || await this.getSliceMachineConfigPath();
    const config = await format(JSON.stringify(args.config, null, 2), configFilePath);
    await fs.writeFile(configFilePath, config, "utf-8");
    delete this._cachedSliceMachineConfig;
  }
  async loadSliceMachineConfig() {
    const configFilePath = await this.getSliceMachineConfigPath();
    let rawConfig;
    try {
      const contents = await fs.readFile(configFilePath, "utf8");
      rawConfig = JSON.parse(contents);
    } catch (error2) {
      if (error2 instanceof SyntaxError) {
        throw new SliceMachineError(`Could not parse config file at ${configFilePath}.

Error Message: ${error2.message}`);
      }
    }
    if (!rawConfig) {
      throw new Error("No config found.");
    }
    const { value: sliceMachineConfig, error } = decodeSliceMachineConfig(rawConfig);
    if (error) {
      throw new Error(`Invalid config. ${error.errors.join(", ")}`, {
        cause: { rawConfig }
      });
    }
    this._cachedSliceMachineConfig = sliceMachineConfig;
    return sliceMachineConfig;
  }
  async locateSliceMachineUIDir() {
    const projectRoot = await this.getRoot();
    const require2 = createRequire(path.join(projectRoot, "index.js"));
    const sliceMachinePackageJSONPath = require2.resolve(`${SLICE_MACHINE_NPM_PACKAGE_NAME}/package.json`);
    return path.dirname(sliceMachinePackageJSONPath);
  }
  /**
   * Returns the project's repository name (i.e. the production environment). It
   * ignores the currently selected environment.
   *
   * Use this method to retrieve the production environment domain.
   *
   * @returns The project's repository name.
   */
  async getRepositoryName() {
    const sliceMachineConfig = await this.getSliceMachineConfig();
    return sliceMachineConfig.repositoryName;
  }
  /**
   * Returns the currently selected environment domain if set. If an environment
   * is not set, it returns the project's repository name (the production
   * environment).
   *
   * Use this method to retrieve the repository name to be sent with Prismic API
   * requests.
   *
   * @returns The resolved repository name.
   */
  async getResolvedRepositoryName() {
    const repositoryName = await this.getRepositoryName();
    const supportsEnvironments = this.project.checkSupportsEnvironments();
    if (!supportsEnvironments) {
      return repositoryName;
    }
    const { environment } = await this.project.readEnvironment();
    return environment ?? repositoryName;
  }
  async getAdapterName() {
    const sliceMachineConfig = await this.getSliceMachineConfig();
    const adapterName = typeof sliceMachineConfig.adapter === "string" ? sliceMachineConfig.adapter : sliceMachineConfig.adapter.resolve;
    return adapterName;
  }
  async locateAdapterDir() {
    const projectRoot = await this.getRoot();
    const adapterName = await this.getAdapterName();
    const require2 = createRequire(path.join(projectRoot, "index.js"));
    const adapterPackageJSONPath = require2.resolve(`${adapterName}/package.json`);
    return path.dirname(adapterPackageJSONPath);
  }
  async initProject(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const log = (args == null ? void 0 : args.log) || console.log.bind(this);
    const { errors } = await this.sliceMachinePluginRunner.callHook("project:init", {
      log,
      installDependencies: async (args2) => {
        const { execaProcess } = await this.installDependencies({
          dependencies: args2.dependencies,
          dev: args2.dev,
          log
        });
        await execaProcess;
      }
    });
    if (errors.length > 0) {
      throw new SliceMachineError(`Failed to initialize project: ${errors.join(", ")}`);
    }
  }
  async detectPackageManager(args) {
    const projectRoot = (args == null ? void 0 : args.root) || await this.getRoot();
    const packageManager = await detect({
      autoInstall: true,
      cwd: projectRoot
    });
    return packageManager || "npm";
  }
  async installDependencies(args) {
    var _a, _b;
    const packageManager = args.packageManager || await this.detectPackageManager();
    const log = args.log || console.log.bind(this);
    const wrappedLogger = (data) => {
      if (data instanceof Buffer) {
        log(data.toString());
      } else if (typeof data === "string") {
        log(data);
      }
    };
    try {
      const { execaProcess } = await installDependencies({
        packageManager,
        dependencies: args.dependencies,
        dev: args.dev
      });
      if (process.stdout.isTTY || process.env.NODE_ENV === "test") {
        (_a = execaProcess.stdout) == null ? void 0 : _a.on("data", wrappedLogger);
      }
      (_b = execaProcess.stderr) == null ? void 0 : _b.on("data", wrappedLogger);
      return {
        execaProcess
      };
    } catch (error) {
      if (error instanceof Error && "shortMessage" in error && "stderr" in error) {
        throw new InternalError("Package installation failed", {
          cause: error
        });
      }
      throw error;
    }
  }
  checkSupportsEnvironments() {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    return this.sliceMachinePluginRunner.hooksForType("project:environment:read").length > 0 && this.sliceMachinePluginRunner.hooksForType("project:environment:update").length > 0;
  }
  async readEnvironment() {
    var _a, _b;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    await this._assertAdapterSupportsEnvironments();
    const hookResult = await this.sliceMachinePluginRunner.callHook("project:environment:read", void 0);
    const { data, errors } = decodeHookResult(t.type({
      environment: t.union([t.undefined, t.string])
    }), hookResult);
    const repositoryName = await this.project.getRepositoryName();
    const environmentDomain = ((_a = data[0]) == null ? void 0 : _a.environment) === repositoryName ? void 0 : (_b = data[0]) == null ? void 0 : _b.environment;
    return {
      environment: environmentDomain,
      errors
    };
  }
  async updateEnvironment(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    await this._assertAdapterSupportsEnvironments();
    const repositoryName = await this.project.getRepositoryName();
    const environment = args.environment === repositoryName ? void 0 : args.environment;
    const hookResult = await this.sliceMachinePluginRunner.callHook("project:environment:update", { environment });
    return {
      errors: hookResult.errors
    };
  }
  async fetchActiveEnvironment() {
    const { environment: activeEnvironmentDomain } = await this.readEnvironment();
    const cachedActiveEnvironment = findEnvironment(activeEnvironmentDomain, this._cachedEnvironments || []);
    if (cachedActiveEnvironment) {
      return { activeEnvironment: cachedActiveEnvironment };
    }
    const { environments } = await this.prismicRepository.fetchEnvironments();
    if (environments) {
      this._cachedEnvironments = environments;
    }
    const activeEnvironment = findEnvironment(activeEnvironmentDomain, this._cachedEnvironments || []);
    if (!activeEnvironment) {
      throw new InvalidActiveEnvironmentError();
    }
    return { activeEnvironment };
  }
  async detectVersionControlSystem() {
    try {
      const projectRoot = await this.getRoot();
      if (existsSync(path.join(projectRoot, ".git"))) {
        return "Git";
      }
      if (existsSync(path.join(projectRoot, ".svn"))) {
        return "SVN";
      }
      if (existsSync(path.join(projectRoot, ".hg"))) {
        return "Mercurial";
      }
      if (existsSync(path.join(projectRoot, "CVS"))) {
        return "CVS";
      }
    } catch (error) {
    }
    return "_unknown";
  }
  async _assertAdapterSupportsEnvironments() {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const supportsEnvironments = this.checkSupportsEnvironments();
    if (!supportsEnvironments) {
      const adapterName = await this.project.getAdapterName();
      throw new PluginError(`${adapterName} does not support environments. Use an adapter that implements the \`project:environment:read\` and \`project:environment:update\` hooks to use environments.`);
    }
  }
}
export {
  ProjectManager
};
//# sourceMappingURL=ProjectManager.js.map
