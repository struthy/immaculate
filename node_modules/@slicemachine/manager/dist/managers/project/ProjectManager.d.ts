import { ExecaChildProcess } from "execa";
import { HookError, CallHookReturnType, ProjectEnvironmentUpdateHook } from "@slicemachine/plugin-kit";
import { DecodeError } from "../../lib/DecodeError";
import { PackageManager, SliceMachineConfig, OnlyHookErrors } from "../../types";
import { BaseManager } from "../BaseManager";
import { Environment } from "../prismicRepository/types";
type ProjectManagerGetSliceMachineConfigPathArgs = {
    ignoreCache?: boolean;
};
type ProjectManagerGetRootArgs = {
    ignoreCache?: boolean;
};
type ProjectManagerCheckIsTypeScriptArgs = {
    rootOverride?: string;
};
type ProjectManagerWriteSliceMachineConfigArgs = {
    config: SliceMachineConfig;
    path?: string;
};
type ProjectManagerInitProjectArgs = {
    log?: (message: string) => void;
};
type ProjectManagerDetectPackageManager = {
    root?: string;
};
type ProjectManagerInstallDependenciesArgs = {
    dependencies: Record<string, string>;
    dev?: boolean;
    packageManager?: PackageManager;
    log?: (message: string) => void;
};
type ProjectManagerInstallDependenciesReturnType = {
    execaProcess: ExecaChildProcess;
};
type ProjectManagerReadEnvironmentReturnType = {
    environment: string | undefined;
    errors: (DecodeError | HookError)[];
};
type ProjectManagerUpdateEnvironmentArgs = {
    environment: string | undefined;
};
type ProjectManagerFetchActiveEnvironmentReturnType = {
    activeEnvironment: Environment;
};
export declare class ProjectManager extends BaseManager {
    private _cachedRoot;
    private _cachedSliceMachineConfigPath;
    private _cachedSliceMachineConfig;
    private _cachedEnvironments;
    getSliceMachineConfigPath(args?: ProjectManagerGetSliceMachineConfigPathArgs): Promise<string>;
    getRoot(args?: ProjectManagerGetRootArgs): Promise<string>;
    suggestRoot(): Promise<string>;
    suggestSliceMachineConfigPath(): Promise<string>;
    checkIsTypeScript(args?: ProjectManagerCheckIsTypeScriptArgs): Promise<boolean>;
    getSliceMachineConfig(): Promise<SliceMachineConfig>;
    writeSliceMachineConfig(args: ProjectManagerWriteSliceMachineConfigArgs): Promise<void>;
    loadSliceMachineConfig(): Promise<SliceMachineConfig>;
    locateSliceMachineUIDir(): Promise<string>;
    /**
     * Returns the project's repository name (i.e. the production environment). It
     * ignores the currently selected environment.
     *
     * Use this method to retrieve the production environment domain.
     *
     * @returns The project's repository name.
     */
    getRepositoryName(): Promise<string>;
    /**
     * Returns the currently selected environment domain if set. If an environment
     * is not set, it returns the project's repository name (the production
     * environment).
     *
     * Use this method to retrieve the repository name to be sent with Prismic API
     * requests.
     *
     * @returns The resolved repository name.
     */
    getResolvedRepositoryName(): Promise<string>;
    getAdapterName(): Promise<string>;
    locateAdapterDir(): Promise<string>;
    initProject(args?: ProjectManagerInitProjectArgs): Promise<void>;
    detectPackageManager(args?: ProjectManagerDetectPackageManager): Promise<PackageManager>;
    installDependencies(args: ProjectManagerInstallDependenciesArgs): Promise<ProjectManagerInstallDependenciesReturnType>;
    checkSupportsEnvironments(): boolean;
    readEnvironment(): Promise<ProjectManagerReadEnvironmentReturnType>;
    updateEnvironment(args: ProjectManagerUpdateEnvironmentArgs): Promise<OnlyHookErrors<CallHookReturnType<ProjectEnvironmentUpdateHook>>>;
    fetchActiveEnvironment(): Promise<ProjectManagerFetchActiveEnvironmentReturnType>;
    detectVersionControlSystem(): Promise<string | "_unknown">;
    private _assertAdapterSupportsEnvironments;
}
export {};
