{"version":3,"file":"ProjectManager.js","sources":["../../../../src/managers/project/ProjectManager.ts"],"sourcesContent":["import * as fs from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport * as path from \"node:path\";\nimport { createRequire } from \"node:module\";\nimport { detect as niDetect } from \"@antfu/ni\";\nimport { ExecaChildProcess } from \"execa\";\nimport {\n\tHookError,\n\tCallHookReturnType,\n\tProjectEnvironmentUpdateHook,\n} from \"@slicemachine/plugin-kit\";\nimport * as t from \"io-ts\";\n\nimport { DecodeError } from \"../../lib/DecodeError\";\nimport { assertPluginsInitialized } from \"../../lib/assertPluginsInitialized\";\nimport { decodeHookResult } from \"../../lib/decodeHookResult\";\nimport { decodeSliceMachineConfig } from \"../../lib/decodeSliceMachineConfig\";\nimport { findEnvironment } from \"../../lib/findEnvironment\";\nimport { format } from \"../../lib/format\";\nimport { installDependencies } from \"../../lib/installDependencies\";\nimport { locateFileUpward } from \"../../lib/locateFileUpward\";\n\nimport {\n\tPackageManager,\n\tSliceMachineConfig,\n\tOnlyHookErrors,\n} from \"../../types\";\n\nimport {\n\tSliceMachineError,\n\tInternalError,\n\tPluginError,\n\tInvalidActiveEnvironmentError,\n} from \"../../errors\";\n\nimport { SLICE_MACHINE_CONFIG_FILENAME } from \"../../constants/SLICE_MACHINE_CONFIG_FILENAME\";\nimport { TS_CONFIG_FILENAME } from \"../../constants/TS_CONFIG_FILENAME\";\nimport { SLICE_MACHINE_NPM_PACKAGE_NAME } from \"../../constants/SLICE_MACHINE_NPM_PACKAGE_NAME\";\n\nimport { BaseManager } from \"../BaseManager\";\nimport { Environment } from \"../prismicRepository/types\";\n\ntype ProjectManagerGetSliceMachineConfigPathArgs = {\n\tignoreCache?: boolean;\n};\n\ntype ProjectManagerGetRootArgs = {\n\tignoreCache?: boolean;\n};\n\ntype ProjectManagerCheckIsTypeScriptArgs = {\n\trootOverride?: string;\n};\n\ntype ProjectManagerWriteSliceMachineConfigArgs = {\n\tconfig: SliceMachineConfig;\n\tpath?: string;\n};\n\ntype ProjectManagerInitProjectArgs = {\n\tlog?: (message: string) => void;\n};\n\ntype ProjectManagerDetectPackageManager = {\n\troot?: string;\n};\n\ntype ProjectManagerInstallDependenciesArgs = {\n\tdependencies: Record<string, string>;\n\tdev?: boolean;\n\tpackageManager?: PackageManager;\n\tlog?: (message: string) => void;\n};\n\ntype ProjectManagerInstallDependenciesReturnType = {\n\texecaProcess: ExecaChildProcess;\n};\n\ntype ProjectManagerReadEnvironmentReturnType = {\n\tenvironment: string | undefined;\n\terrors: (DecodeError | HookError)[];\n};\n\ntype ProjectManagerUpdateEnvironmentArgs = {\n\tenvironment: string | undefined;\n};\n\ntype ProjectManagerFetchActiveEnvironmentReturnType = {\n\tactiveEnvironment: Environment;\n};\n\nexport class ProjectManager extends BaseManager {\n\tprivate _cachedRoot: string | undefined;\n\tprivate _cachedSliceMachineConfigPath: string | undefined;\n\tprivate _cachedSliceMachineConfig: SliceMachineConfig | undefined;\n\tprivate _cachedEnvironments: Environment[] | undefined;\n\n\tasync getSliceMachineConfigPath(\n\t\targs?: ProjectManagerGetSliceMachineConfigPathArgs,\n\t): Promise<string> {\n\t\tif (this._cachedSliceMachineConfigPath && !args?.ignoreCache) {\n\t\t\treturn this._cachedSliceMachineConfigPath;\n\t\t}\n\n\t\ttry {\n\t\t\tthis._cachedSliceMachineConfigPath = await locateFileUpward(\n\t\t\t\tSLICE_MACHINE_CONFIG_FILENAME,\n\t\t\t\t{ startDir: this.cwd },\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthrow new Error(\n\t\t\t\t`Could not find a ${SLICE_MACHINE_CONFIG_FILENAME} file. Please create a config file at the root of your project.`,\n\t\t\t);\n\t\t}\n\n\t\treturn this._cachedSliceMachineConfigPath;\n\t}\n\n\tasync getRoot(args?: ProjectManagerGetRootArgs): Promise<string> {\n\t\tif (this._cachedRoot && !args?.ignoreCache) {\n\t\t\treturn this._cachedRoot;\n\t\t}\n\n\t\tconst sliceMachineConfigFilePath = await this.getSliceMachineConfigPath({\n\t\t\tignoreCache: args?.ignoreCache,\n\t\t});\n\n\t\tthis._cachedRoot = path.dirname(sliceMachineConfigFilePath);\n\n\t\treturn this._cachedRoot;\n\t}\n\n\tasync suggestRoot(): Promise<string> {\n\t\tconst suggestedRootPackageJSON = await locateFileUpward(\"package.json\", {\n\t\t\tstartDir: this.cwd,\n\t\t});\n\n\t\treturn path.dirname(suggestedRootPackageJSON);\n\t}\n\n\tasync suggestSliceMachineConfigPath(): Promise<string> {\n\t\tconst suggestedRoot = await this.suggestRoot();\n\n\t\treturn path.resolve(suggestedRoot, SLICE_MACHINE_CONFIG_FILENAME);\n\t}\n\n\tasync checkIsTypeScript(\n\t\targs?: ProjectManagerCheckIsTypeScriptArgs,\n\t): Promise<boolean> {\n\t\tconst root = args?.rootOverride || (await this.getRoot());\n\t\tconst rootTSConfigPath = path.resolve(root, TS_CONFIG_FILENAME);\n\n\t\t// We just care if the file exists, we don't need access to it\n\t\treturn existsSync(rootTSConfigPath);\n\t}\n\n\tasync getSliceMachineConfig(): Promise<SliceMachineConfig> {\n\t\tif (this._cachedSliceMachineConfig) {\n\t\t\treturn this._cachedSliceMachineConfig;\n\t\t} else {\n\t\t\treturn await this.loadSliceMachineConfig();\n\t\t}\n\t}\n\n\tasync writeSliceMachineConfig(\n\t\targs: ProjectManagerWriteSliceMachineConfigArgs,\n\t): Promise<void> {\n\t\tconst configFilePath =\n\t\t\targs.path || (await this.getSliceMachineConfigPath());\n\n\t\tconst config = await format(\n\t\t\tJSON.stringify(args.config, null, 2),\n\t\t\tconfigFilePath,\n\t\t);\n\n\t\tawait fs.writeFile(configFilePath, config, \"utf-8\");\n\t\tdelete this._cachedSliceMachineConfig; // Clear config cache\n\t}\n\n\tasync loadSliceMachineConfig(): Promise<SliceMachineConfig> {\n\t\t// TODO: Reload plugins with a fresh plugin runner. Plugins may\n\t\t// have been added or removed.\n\t\tconst configFilePath = await this.getSliceMachineConfigPath();\n\n\t\tlet rawConfig: unknown | undefined;\n\t\ttry {\n\t\t\tconst contents = await fs.readFile(configFilePath, \"utf8\");\n\t\t\trawConfig = JSON.parse(contents);\n\t\t} catch (error) {\n\t\t\tif (error instanceof SyntaxError) {\n\t\t\t\tthrow new SliceMachineError(\n\t\t\t\t\t`Could not parse config file at ${configFilePath}.\\n\\nError Message: ${error.message}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Noop, more specific error is thrown after\n\t\t}\n\n\t\tif (!rawConfig) {\n\t\t\t// TODO: Write a more friendly and useful message.\n\t\t\tthrow new Error(\"No config found.\");\n\t\t}\n\n\t\tconst { value: sliceMachineConfig, error } =\n\t\t\tdecodeSliceMachineConfig(rawConfig);\n\n\t\tif (error) {\n\t\t\t// TODO: Write a more friendly and useful message.\n\t\t\tthrow new Error(`Invalid config. ${error.errors.join(\", \")}`, {\n\t\t\t\tcause: { rawConfig },\n\t\t\t});\n\t\t}\n\n\t\t// Allow cached config reading using `SliceMachineManager.prototype.getProjectConfig()`.\n\t\tthis._cachedSliceMachineConfig = sliceMachineConfig;\n\n\t\treturn sliceMachineConfig;\n\t}\n\n\tasync locateSliceMachineUIDir(): Promise<string> {\n\t\tconst projectRoot = await this.getRoot();\n\n\t\tconst require = createRequire(path.join(projectRoot, \"index.js\"));\n\t\tconst sliceMachinePackageJSONPath = require.resolve(\n\t\t\t`${SLICE_MACHINE_NPM_PACKAGE_NAME}/package.json`,\n\t\t);\n\n\t\treturn path.dirname(sliceMachinePackageJSONPath);\n\t}\n\n\t/**\n\t * Returns the project's repository name (i.e. the production environment). It\n\t * ignores the currently selected environment.\n\t *\n\t * Use this method to retrieve the production environment domain.\n\t *\n\t * @returns The project's repository name.\n\t */\n\tasync getRepositoryName(): Promise<string> {\n\t\tconst sliceMachineConfig = await this.getSliceMachineConfig();\n\n\t\treturn sliceMachineConfig.repositoryName;\n\t}\n\n\t/**\n\t * Returns the currently selected environment domain if set. If an environment\n\t * is not set, it returns the project's repository name (the production\n\t * environment).\n\t *\n\t * Use this method to retrieve the repository name to be sent with Prismic API\n\t * requests.\n\t *\n\t * @returns The resolved repository name.\n\t */\n\tasync getResolvedRepositoryName(): Promise<string> {\n\t\tconst repositoryName = await this.getRepositoryName();\n\n\t\tconst supportsEnvironments = this.project.checkSupportsEnvironments();\n\t\tif (!supportsEnvironments) {\n\t\t\treturn repositoryName;\n\t\t}\n\n\t\tconst { environment } = await this.project.readEnvironment();\n\n\t\treturn environment ?? repositoryName;\n\t}\n\n\tasync getAdapterName(): Promise<string> {\n\t\tconst sliceMachineConfig = await this.getSliceMachineConfig();\n\t\tconst adapterName =\n\t\t\ttypeof sliceMachineConfig.adapter === \"string\"\n\t\t\t\t? sliceMachineConfig.adapter\n\t\t\t\t: sliceMachineConfig.adapter.resolve;\n\n\t\treturn adapterName;\n\t}\n\n\tasync locateAdapterDir(): Promise<string> {\n\t\tconst projectRoot = await this.getRoot();\n\t\tconst adapterName = await this.getAdapterName();\n\t\tconst require = createRequire(path.join(projectRoot, \"index.js\"));\n\t\tconst adapterPackageJSONPath = require.resolve(\n\t\t\t`${adapterName}/package.json`,\n\t\t);\n\n\t\treturn path.dirname(adapterPackageJSONPath);\n\t}\n\n\tasync initProject(args?: ProjectManagerInitProjectArgs): Promise<void> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\t// eslint-disable-next-line no-console\n\t\tconst log = args?.log || console.log.bind(this);\n\n\t\tconst { errors } = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"project:init\",\n\t\t\t{\n\t\t\t\tlog,\n\t\t\t\tinstallDependencies: async (args) => {\n\t\t\t\t\tconst { execaProcess } = await this.installDependencies({\n\t\t\t\t\t\tdependencies: args.dependencies,\n\t\t\t\t\t\tdev: args.dev,\n\t\t\t\t\t\tlog,\n\t\t\t\t\t});\n\n\t\t\t\t\tawait execaProcess;\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tif (errors.length > 0) {\n\t\t\t// TODO: Provide better error message.\n\t\t\tthrow new SliceMachineError(\n\t\t\t\t`Failed to initialize project: ${errors.join(\", \")}`,\n\t\t\t);\n\t\t}\n\t}\n\n\tasync detectPackageManager(\n\t\targs?: ProjectManagerDetectPackageManager,\n\t): Promise<PackageManager> {\n\t\tconst projectRoot = args?.root || (await this.getRoot());\n\n\t\tconst packageManager = await niDetect({\n\t\t\tautoInstall: true,\n\t\t\tcwd: projectRoot,\n\t\t});\n\n\t\treturn packageManager || \"npm\";\n\t}\n\n\tasync installDependencies(\n\t\targs: ProjectManagerInstallDependenciesArgs,\n\t): Promise<ProjectManagerInstallDependenciesReturnType> {\n\t\tconst packageManager =\n\t\t\targs.packageManager || (await this.detectPackageManager());\n\n\t\t// eslint-disable-next-line no-console\n\t\tconst log = args.log || console.log.bind(this);\n\n\t\tconst wrappedLogger = (data: Buffer | string | null) => {\n\t\t\tif (data instanceof Buffer) {\n\t\t\t\tlog(data.toString());\n\t\t\t} else if (typeof data === \"string\") {\n\t\t\t\tlog(data);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\tconst { execaProcess } = await installDependencies({\n\t\t\t\tpackageManager,\n\t\t\t\tdependencies: args.dependencies,\n\t\t\t\tdev: args.dev,\n\t\t\t});\n\n\t\t\t// Don't clutter console with logs when process is non TTY (CI, etc.)\n\t\t\tif (process.stdout.isTTY || process.env.NODE_ENV === \"test\") {\n\t\t\t\texecaProcess.stdout?.on(\"data\", wrappedLogger);\n\t\t\t}\n\t\t\texecaProcess.stderr?.on(\"data\", wrappedLogger);\n\n\t\t\treturn {\n\t\t\t\texecaProcess,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\terror instanceof Error &&\n\t\t\t\t\"shortMessage\" in error &&\n\t\t\t\t\"stderr\" in error\n\t\t\t) {\n\t\t\t\tthrow new InternalError(\"Package installation failed\", {\n\t\t\t\t\tcause: error,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tcheckSupportsEnvironments(): boolean {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\treturn (\n\t\t\tthis.sliceMachinePluginRunner.hooksForType(\"project:environment:read\")\n\t\t\t\t.length > 0 &&\n\t\t\tthis.sliceMachinePluginRunner.hooksForType(\"project:environment:update\")\n\t\t\t\t.length > 0\n\t\t);\n\t}\n\n\tasync readEnvironment(): Promise<ProjectManagerReadEnvironmentReturnType> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tawait this._assertAdapterSupportsEnvironments();\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"project:environment:read\",\n\t\t\tundefined,\n\t\t);\n\t\tconst { data, errors } = decodeHookResult(\n\t\t\tt.type({\n\t\t\t\tenvironment: t.union([t.undefined, t.string]),\n\t\t\t}),\n\t\t\thookResult,\n\t\t);\n\n\t\t// An undefined value is equivalent to the production environment.\n\t\t// We cast to undefined.\n\t\tconst repositoryName = await this.project.getRepositoryName();\n\t\tconst environmentDomain =\n\t\t\tdata[0]?.environment === repositoryName\n\t\t\t\t? undefined\n\t\t\t\t: data[0]?.environment;\n\n\t\treturn {\n\t\t\tenvironment: environmentDomain,\n\t\t\terrors,\n\t\t};\n\t}\n\n\tasync updateEnvironment(\n\t\targs: ProjectManagerUpdateEnvironmentArgs,\n\t): Promise<OnlyHookErrors<CallHookReturnType<ProjectEnvironmentUpdateHook>>> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tawait this._assertAdapterSupportsEnvironments();\n\n\t\tconst repositoryName = await this.project.getRepositoryName();\n\t\tconst environment =\n\t\t\targs.environment === repositoryName ? undefined : args.environment;\n\n\t\tconst hookResult = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"project:environment:update\",\n\t\t\t{ environment },\n\t\t);\n\n\t\treturn {\n\t\t\terrors: hookResult.errors,\n\t\t};\n\t}\n\n\tasync fetchActiveEnvironment(): Promise<ProjectManagerFetchActiveEnvironmentReturnType> {\n\t\tconst { environment: activeEnvironmentDomain } =\n\t\t\tawait this.readEnvironment();\n\n\t\t// We can assume an environment cannot change its kind. If the\n\t\t// environment exists in the cached list, we are confident it\n\t\t// will not change.\n\t\tconst cachedActiveEnvironment = findEnvironment(\n\t\t\tactiveEnvironmentDomain,\n\t\t\tthis._cachedEnvironments || [],\n\t\t);\n\t\tif (cachedActiveEnvironment) {\n\t\t\treturn { activeEnvironment: cachedActiveEnvironment };\n\t\t}\n\n\t\t// If the environment is not in the cached environments list, we\n\t\t// must fetch a fresh list and set the cache.\n\t\tconst { environments } = await this.prismicRepository.fetchEnvironments();\n\t\t// TODO: Remove the wrapping if statement when\n\t\t// `this.prismicRepository.fetchEnvironments()` is able to throw\n\t\t// normally. The method returns an object with an `error`\n\t\t// property at the time of this writing, which means we need to\n\t\t// check if the `environments` property exists.\n\t\tif (environments) {\n\t\t\tthis._cachedEnvironments = environments;\n\t\t}\n\n\t\tconst activeEnvironment = findEnvironment(\n\t\t\tactiveEnvironmentDomain,\n\t\t\tthis._cachedEnvironments || [],\n\t\t);\n\n\t\tif (!activeEnvironment) {\n\t\t\tthrow new InvalidActiveEnvironmentError();\n\t\t}\n\n\t\treturn { activeEnvironment };\n\t}\n\n\tasync detectVersionControlSystem(): Promise<string | \"_unknown\"> {\n\t\ttry {\n\t\t\tconst projectRoot = await this.getRoot();\n\n\t\t\tif (existsSync(path.join(projectRoot, \".git\"))) {\n\t\t\t\treturn \"Git\";\n\t\t\t}\n\n\t\t\tif (existsSync(path.join(projectRoot, \".svn\"))) {\n\t\t\t\treturn \"SVN\";\n\t\t\t}\n\n\t\t\tif (existsSync(path.join(projectRoot, \".hg\"))) {\n\t\t\t\treturn \"Mercurial\";\n\t\t\t}\n\n\t\t\tif (existsSync(path.join(projectRoot, \"CVS\"))) {\n\t\t\t\treturn \"CVS\";\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (import.meta.env.DEV) {\n\t\t\t\tconsole.error(\"Failed to detect Version Control System:\", error);\n\t\t\t}\n\t\t}\n\n\t\treturn \"_unknown\";\n\t}\n\n\tprivate async _assertAdapterSupportsEnvironments(): Promise<void> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\tconst supportsEnvironments = this.checkSupportsEnvironments();\n\n\t\tif (!supportsEnvironments) {\n\t\t\tconst adapterName = await this.project.getAdapterName();\n\n\t\t\tthrow new PluginError(\n\t\t\t\t`${adapterName} does not support environments. Use an adapter that implements the \\`project:environment:read\\` and \\`project:environment:update\\` hooks to use environments.`,\n\t\t\t);\n\t\t}\n\t}\n}\n"],"names":["error","require","args","niDetect"],"mappings":"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"}