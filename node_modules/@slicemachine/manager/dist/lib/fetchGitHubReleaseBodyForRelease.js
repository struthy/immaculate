import * as t from "io-ts";
import fetch from "./fetch.js";
import pLimit from './../_node_modules/p-limit/index.js';
import { decode } from "./decode.js";
const GITHUB_JSON_ACCEPT_HEADER = "application/vnd.github+json";
const GitHubReleaseMetadata = t.type({
  name: t.string,
  body: t.union([t.null, t.string])
});
const fetchAllGitHubReleases = async (args) => {
  const res = await fetch(`https://api.github.com/repos/${args.repositoryOwner}/${args.repositoryName}/releases`, {
    headers: {
      Accept: GITHUB_JSON_ACCEPT_HEADER
    }
  });
  if (res.ok) {
    const json = await res.json();
    const { value, error } = decode(t.array(GitHubReleaseMetadata), json);
    if (error) {
      throw new Error(`Invalid GitHub Release response.`, { cause: error });
    }
    return value;
  } else {
    const text = await res.text();
    throw new Error(`Invalid GitHub Release response.`, {
      cause: text
    });
  }
};
const fetchGitHubReleaseByVersion = async (args) => {
  let url;
  if (args.packageName) {
    url = `https://api.github.com/repos/${args.repositoryOwner}/${args.repositoryName}/releases/tags/${args.packageName}@${args.version}`;
  } else {
    url = `https://api.github.com/repos/${args.repositoryOwner}/${args.repositoryName}/releases/tags/${args.version}`;
  }
  const res = await fetch(url, {
    headers: {
      Accept: GITHUB_JSON_ACCEPT_HEADER
    }
  });
  if (res.ok) {
    const json = await res.json();
    const { value, error } = decode(GitHubReleaseMetadata, json);
    if (error) {
      throw new Error(`Invalid GitHub Release response.`, { cause: error });
    }
    return value;
  }
};
const _fetchGitHubReleaseBodyForRelease = async (args) => {
  const cache = args.cache || {};
  if (Object.keys(cache).length < 1) {
    const releases = await fetchAllGitHubReleases({
      repositoryOwner: args.repositoryOwner,
      repositoryName: args.repositoryName
    });
    for (const release of releases) {
      cache[release.name] = release;
    }
  }
  if (args.version in cache) {
    const release = cache[args.version];
    return (release == null ? void 0 : release.body) ?? void 0;
  } else {
    try {
      const version = await fetchGitHubReleaseByVersion({
        repositoryOwner: args.repositoryOwner,
        repositoryName: args.repositoryName,
        packageName: args.packageName,
        version: args.version
      });
      cache[args.version] = version;
      return (version == null ? void 0 : version.body) ?? void 0;
    } catch {
      cache[args.version] = void 0;
      return void 0;
    }
  }
};
const limit = pLimit(1);
const fetchGitHubReleaseBodyForRelease = async (...args) => {
  return await limit(() => _fetchGitHubReleaseBodyForRelease(...args));
};
export {
  fetchGitHubReleaseBodyForRelease
};
//# sourceMappingURL=fetchGitHubReleaseBodyForRelease.js.map
