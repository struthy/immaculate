"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("io-ts");
const fetch = require("./fetch.cjs");
const index = require('./../_node_modules/p-limit/index.cjs');
const decode = require("./decode.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const GITHUB_JSON_ACCEPT_HEADER = "application/vnd.github+json";
const GitHubReleaseMetadata = t__namespace.type({
  name: t__namespace.string,
  body: t__namespace.union([t__namespace.null, t__namespace.string])
});
const fetchAllGitHubReleases = async (args) => {
  const res = await fetch.default(`https://api.github.com/repos/${args.repositoryOwner}/${args.repositoryName}/releases`, {
    headers: {
      Accept: GITHUB_JSON_ACCEPT_HEADER
    }
  });
  if (res.ok) {
    const json = await res.json();
    const { value, error } = decode.decode(t__namespace.array(GitHubReleaseMetadata), json);
    if (error) {
      throw new Error(`Invalid GitHub Release response.`, { cause: error });
    }
    return value;
  } else {
    const text = await res.text();
    throw new Error(`Invalid GitHub Release response.`, {
      cause: text
    });
  }
};
const fetchGitHubReleaseByVersion = async (args) => {
  let url;
  if (args.packageName) {
    url = `https://api.github.com/repos/${args.repositoryOwner}/${args.repositoryName}/releases/tags/${args.packageName}@${args.version}`;
  } else {
    url = `https://api.github.com/repos/${args.repositoryOwner}/${args.repositoryName}/releases/tags/${args.version}`;
  }
  const res = await fetch.default(url, {
    headers: {
      Accept: GITHUB_JSON_ACCEPT_HEADER
    }
  });
  if (res.ok) {
    const json = await res.json();
    const { value, error } = decode.decode(GitHubReleaseMetadata, json);
    if (error) {
      throw new Error(`Invalid GitHub Release response.`, { cause: error });
    }
    return value;
  }
};
const _fetchGitHubReleaseBodyForRelease = async (args) => {
  const cache = args.cache || {};
  if (Object.keys(cache).length < 1) {
    const releases = await fetchAllGitHubReleases({
      repositoryOwner: args.repositoryOwner,
      repositoryName: args.repositoryName
    });
    for (const release of releases) {
      cache[release.name] = release;
    }
  }
  if (args.version in cache) {
    const release = cache[args.version];
    return (release == null ? void 0 : release.body) ?? void 0;
  } else {
    try {
      const version = await fetchGitHubReleaseByVersion({
        repositoryOwner: args.repositoryOwner,
        repositoryName: args.repositoryName,
        packageName: args.packageName,
        version: args.version
      });
      cache[args.version] = version;
      return (version == null ? void 0 : version.body) ?? void 0;
    } catch {
      cache[args.version] = void 0;
      return void 0;
    }
  }
};
const limit = index(1);
const fetchGitHubReleaseBodyForRelease = async (...args) => {
  return await limit(() => _fetchGitHubReleaseBodyForRelease(...args));
};
exports.fetchGitHubReleaseBodyForRelease = fetchGitHubReleaseBodyForRelease;
//# sourceMappingURL=fetchGitHubReleaseBodyForRelease.cjs.map
