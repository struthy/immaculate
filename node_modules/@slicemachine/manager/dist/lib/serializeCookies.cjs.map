{"version":3,"file":"serializeCookies.cjs","sources":["../../../src/lib/serializeCookies.ts"],"sourcesContent":["import cookie from \"cookie\";\n\nconst COOKIE_SEPARATOR = \"; \";\n\ntype Cookies = string | string[] | Record<string, string>;\n\nconst castParsedCookies = (cookies: Cookies): Record<string, string> => {\n\tif (Array.isArray(cookies)) {\n\t\treturn cookie.parse(cookies.join(COOKIE_SEPARATOR));\n\t} else if (typeof cookies === \"string\") {\n\t\treturn cookie.parse(cookies);\n\t} else {\n\t\treturn cookies;\n\t}\n};\n\ntype SerializeCookiesArgs = {\n\tcookieJar?: Cookies;\n};\n\n// TODO: If the `cookieJar` and multiple input types are not used anywhere,\n// simplify this function to only serialize a given object of cookies into a\n// string.\nexport const serializeCookies = (\n\tcookies: Cookies,\n\targs: SerializeCookiesArgs = {},\n): string => {\n\tconst cookiesToSerialize = {\n\t\t...castParsedCookies(args.cookieJar || {}),\n\t\t...castParsedCookies(cookies),\n\t};\n\n\tconst items: string[] = [];\n\n\tfor (const name in cookiesToSerialize) {\n\t\titems.push(\n\t\t\tcookie.serialize(name, cookiesToSerialize[name], {\n\t\t\t\t// Cookies need be stored raw (not encoded or escaped), so that consumers can format them the way they want them to be formatted.\n\t\t\t\tencode: (cookie) => cookie,\n\t\t\t}),\n\t\t);\n\t}\n\n\treturn items.join(COOKIE_SEPARATOR);\n};\n"],"names":["cookie"],"mappings":";;;AAEA,MAAM,mBAAmB;AAIzB,MAAM,oBAAoB,CAAC,YAA4C;AAClE,MAAA,MAAM,QAAQ,OAAO,GAAG;AAC3B,WAAO,OAAO,MAAM,QAAQ,KAAK,gBAAgB,CAAC;AAAA,EAAA,WACxC,OAAO,YAAY,UAAU;AAChC,WAAA,OAAO,MAAM,OAAO;AAAA,EAAA,OACrB;AACC,WAAA;AAAA,EACP;AACF;AASO,MAAM,mBAAmB,CAC/B,SACA,OAA6B,OAClB;AACX,QAAM,qBAAqB;AAAA,IAC1B,GAAG,kBAAkB,KAAK,aAAa,EAAE;AAAA,IACzC,GAAG,kBAAkB,OAAO;AAAA,EAAA;AAG7B,QAAM,QAAkB,CAAA;AAExB,aAAW,QAAQ,oBAAoB;AACtC,UAAM,KACL,OAAO,UAAU,MAAM,mBAAmB,IAAI,GAAG;AAAA;AAAA,MAEhD,QAAQ,CAACA,YAAWA;AAAAA,IACpB,CAAA,CAAC;AAAA,EAEH;AAEM,SAAA,MAAM,KAAK,gBAAgB;AACnC;;"}