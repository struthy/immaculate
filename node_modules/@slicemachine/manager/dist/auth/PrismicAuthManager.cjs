"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("io-ts");
const fs = require("node:fs/promises");
const path = require("node:path");
const os = require("node:os");
const http = require("node:http");
const h3 = require("h3");
const fetch = require("../lib/fetch.cjs");
const cookie = require("cookie");
const cors = require("cors");
const index = require('./../_node_modules/get-port/index.cjs');
const decode = require("../lib/decode.cjs");
const serializeCookies = require("../lib/serializeCookies.cjs");
const API_ENDPOINTS = require("../constants/API_ENDPOINTS.cjs");
const SLICE_MACHINE_USER_AGENT = require("../constants/SLICE_MACHINE_USER_AGENT.cjs");
const createPrismicAuthManagerMiddleware = require("./createPrismicAuthManagerMiddleware.cjs");
const errors = require("../errors.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs);
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
const os__namespace = /* @__PURE__ */ _interopNamespaceDefault(os);
const http__namespace = /* @__PURE__ */ _interopNamespaceDefault(http);
const h3__namespace = /* @__PURE__ */ _interopNamespaceDefault(h3);
const COOKIE_SEPARATOR = "; ";
const AUTH_COOKIE_KEY = "prismic-auth";
const SESSION_COOKIE_KEY = "SESSION";
const PERSISTED_AUTH_STATE_FILE_NAME = ".prismic";
const DEFAULT_PERSISTED_AUTH_STATE = {
  base: "https://prismic.io",
  cookies: {}
};
const PrismicAuthState = t__namespace.intersection([
  t__namespace.type({
    base: t__namespace.string,
    cookies: t__namespace.intersection([
      t__namespace.partial({
        [AUTH_COOKIE_KEY]: t__namespace.string,
        SESSION: t__namespace.string
      }),
      t__namespace.record(t__namespace.string, t__namespace.string)
    ])
  }),
  t__namespace.partial({
    shortId: t__namespace.string,
    intercomHash: t__namespace.string,
    oauthAccessToken: t__namespace.string,
    authUrl: t__namespace.string
  })
]);
const PrismicUserProfile = t__namespace.exact(t__namespace.type({
  userId: t__namespace.string,
  shortId: t__namespace.string,
  intercomHash: t__namespace.string,
  email: t__namespace.string,
  firstName: t__namespace.string,
  lastName: t__namespace.string
}));
const checkHasAuthenticationToken = (authState) => {
  return Boolean(authState.cookies[AUTH_COOKIE_KEY] && authState.cookies[SESSION_COOKIE_KEY]);
};
const parseCookies = (cookies) => {
  return cookie.parse(cookies, {
    // Don't escape any values.
    decode: (value) => value
  });
};
class PrismicAuthManager {
  constructor({ scopedDirectory = os__namespace.homedir() } = {}) {
    // TODO: Automatically scope the manager to the current Slice Machine
    // project? If not, this internal state can be removed.
    __publicField(this, "scopedDirectory");
    this.scopedDirectory = scopedDirectory;
  }
  // TODO: Make the `cookies` argument more explicit. What are these
  // mysterious cookies?
  async login(args) {
    const authState = await this._readPersistedAuthState();
    authState.base = API_ENDPOINTS.API_ENDPOINTS.PrismicWroom;
    authState.cookies = {
      ...authState.cookies,
      ...parseCookies(args.cookies.join(COOKIE_SEPARATOR))
    };
    if (checkHasAuthenticationToken(authState)) {
      const authenticationToken = authState.cookies[AUTH_COOKIE_KEY];
      const profile = await this._getProfileForAuthenticationToken({
        authenticationToken
      });
      authState.shortId = profile.shortId;
      authState.intercomHash = profile.intercomHash;
    }
    await this._writePersistedAuthState(authState);
  }
  async getLoginSessionInfo() {
    const port = await index({ port: 5555 });
    const url = new URL(`./dashboard/cli/login?source=slice-machine&port=${port}`, API_ENDPOINTS.API_ENDPOINTS.PrismicWroom).toString();
    return {
      port,
      url
    };
  }
  async nodeLoginSession(args) {
    return new Promise(async (resolve) => {
      const timeout = setTimeout(() => {
        server.close();
        throw new Error("Login timeout, server did not receive a response within a 3-minute delay");
      }, 18e4);
      const app = h3__namespace.createApp();
      app.use(h3__namespace.fromNodeMiddleware(cors()));
      app.use(h3__namespace.fromNodeMiddleware(createPrismicAuthManagerMiddleware.createPrismicAuthManagerMiddleware({
        prismicAuthManager: this,
        onLoginCallback() {
          clearTimeout(timeout);
          server.close();
          resolve();
        }
      })));
      const server = http__namespace.createServer(h3__namespace.toNodeListener(app));
      await new Promise((resolve2) => {
        server.once("listening", () => {
          resolve2();
        });
        server.listen(args.port);
      });
      if (args.onListenCallback) {
        args.onListenCallback();
      }
    });
  }
  async logout() {
    const authState = await this._readPersistedAuthState();
    authState.cookies = {};
    authState.shortId = void 0;
    authState.intercomHash = void 0;
    await this._writePersistedAuthState(authState);
  }
  async checkIsLoggedIn() {
    const authState = await this._readPersistedAuthState();
    if (checkHasAuthenticationToken(authState)) {
      const url = new URL("./validate", API_ENDPOINTS.API_ENDPOINTS.PrismicAuthentication);
      url.searchParams.set("token", authState.cookies[AUTH_COOKIE_KEY]);
      let res;
      try {
        res = await fetch.default(url.toString(), {
          headers: {
            "User-Agent": SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT
          }
        });
      } catch (error) {
      }
      if (!res || !res.ok) {
        await this.logout();
        return false;
      }
      return true;
    } else {
      return false;
    }
  }
  async getAuthenticationCookies() {
    const isLoggedIn = await this.checkIsLoggedIn();
    if (isLoggedIn) {
      const authState = await this._readPersistedAuthState();
      if (checkHasAuthenticationToken(authState)) {
        return authState.cookies;
      }
    }
    throw new errors.UnauthenticatedError();
  }
  async getAuthenticationToken() {
    const cookies = await this.getAuthenticationCookies();
    return cookies[AUTH_COOKIE_KEY];
  }
  async refreshAuthenticationToken() {
    const authState = await this._readPersistedAuthState();
    if (checkHasAuthenticationToken(authState)) {
      const url = new URL("./refreshtoken", API_ENDPOINTS.API_ENDPOINTS.PrismicAuthentication);
      url.searchParams.set("token", authState.cookies[AUTH_COOKIE_KEY]);
      const res = await fetch.default(url.toString(), {
        headers: {
          "User-Agent": SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT
        }
      });
      const text = await res.text();
      if (res.ok) {
        authState.cookies[AUTH_COOKIE_KEY] = text;
        await this._writePersistedAuthState(authState);
      } else {
        throw new errors.InternalError("Failed to refresh authentication token.", {
          cause: text
        });
      }
    } else {
      throw new errors.UnauthenticatedError();
    }
  }
  async getProfile() {
    const authenticationToken = await this.getAuthenticationToken();
    return await this._getProfileForAuthenticationToken({
      authenticationToken
    });
  }
  async _getProfileForAuthenticationToken(args) {
    const url = new URL("./profile", API_ENDPOINTS.API_ENDPOINTS.PrismicUser);
    const res = await fetch.default(url.toString(), {
      headers: {
        Authorization: `Bearer ${args.authenticationToken}`,
        "User-Agent": SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT
      }
    });
    if (res.ok) {
      const json = await res.json();
      const { value: profile, error } = decode.decode(PrismicUserProfile, json);
      if (error) {
        throw new errors.UnexpectedDataError("Received invalid data from the Prismic user service.");
      }
      return profile;
    } else {
      const text = await res.text();
      throw new errors.InternalError("Failed to retrieve profile from the Prismic user service.", {
        cause: text
      });
    }
  }
  async _readPersistedAuthState() {
    const authStateFilePath = this._getPersistedAuthStateFilePath();
    let authStateFileContents = JSON.stringify({});
    let rawAuthState = {};
    try {
      authStateFileContents = await fs__namespace.readFile(authStateFilePath, "utf8");
      rawAuthState = JSON.parse(authStateFileContents);
    } catch {
      rawAuthState = {
        ...DEFAULT_PERSISTED_AUTH_STATE,
        cookies: serializeCookies.serializeCookies(DEFAULT_PERSISTED_AUTH_STATE.cookies)
      };
      authStateFileContents = JSON.stringify(rawAuthState, null, "	");
      await fs__namespace.mkdir(path__namespace.dirname(authStateFilePath), { recursive: true });
      await fs__namespace.writeFile(authStateFilePath, authStateFileContents);
    }
    if (typeof rawAuthState.cookies === "string") {
      rawAuthState.cookies = parseCookies(rawAuthState.cookies);
    }
    const { value: authState, error } = decode.decode(PrismicAuthState, rawAuthState);
    if (error) {
      throw new errors.UnexpectedDataError("Prismic authentication state is invalid.");
    }
    return authState;
  }
  async _writePersistedAuthState(authState) {
    const authStateFilePath = this._getPersistedAuthStateFilePath();
    const preparedAuthState = {
      ...authState,
      cookies: serializeCookies.serializeCookies(authState.cookies)
    };
    try {
      await fs__namespace.writeFile(authStateFilePath, JSON.stringify(preparedAuthState, null, 2));
    } catch (error) {
      throw new errors.InternalError("Failed to write Prismic authentication state to the file system.", {
        cause: error
      });
    }
  }
  _getPersistedAuthStateFilePath() {
    return path__namespace.resolve(this.scopedDirectory, PERSISTED_AUTH_STATE_FILE_NAME);
  }
}
exports.PrismicAuthManager = PrismicAuthManager;
//# sourceMappingURL=PrismicAuthManager.cjs.map
