var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as t from "io-ts";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import * as os from "node:os";
import * as http from "node:http";
import * as h3 from "h3";
import fetch from "../lib/fetch.js";
import cookie from "cookie";
import cors from "cors";
import getPorts from './../_node_modules/get-port/index.js';
import { decode } from "../lib/decode.js";
import { serializeCookies } from "../lib/serializeCookies.js";
import { API_ENDPOINTS } from "../constants/API_ENDPOINTS.js";
import { SLICE_MACHINE_USER_AGENT } from "../constants/SLICE_MACHINE_USER_AGENT.js";
import { createPrismicAuthManagerMiddleware } from "./createPrismicAuthManagerMiddleware.js";
import { UnauthenticatedError, InternalError, UnexpectedDataError } from "../errors.js";
const COOKIE_SEPARATOR = "; ";
const AUTH_COOKIE_KEY = "prismic-auth";
const SESSION_COOKIE_KEY = "SESSION";
const PERSISTED_AUTH_STATE_FILE_NAME = ".prismic";
const DEFAULT_PERSISTED_AUTH_STATE = {
  base: "https://prismic.io",
  cookies: {}
};
const PrismicAuthState = t.intersection([
  t.type({
    base: t.string,
    cookies: t.intersection([
      t.partial({
        [AUTH_COOKIE_KEY]: t.string,
        SESSION: t.string
      }),
      t.record(t.string, t.string)
    ])
  }),
  t.partial({
    shortId: t.string,
    intercomHash: t.string,
    oauthAccessToken: t.string,
    authUrl: t.string
  })
]);
const PrismicUserProfile = t.exact(t.type({
  userId: t.string,
  shortId: t.string,
  intercomHash: t.string,
  email: t.string,
  firstName: t.string,
  lastName: t.string
}));
const checkHasAuthenticationToken = (authState) => {
  return Boolean(authState.cookies[AUTH_COOKIE_KEY] && authState.cookies[SESSION_COOKIE_KEY]);
};
const parseCookies = (cookies) => {
  return cookie.parse(cookies, {
    // Don't escape any values.
    decode: (value) => value
  });
};
class PrismicAuthManager {
  constructor({ scopedDirectory = os.homedir() } = {}) {
    // TODO: Automatically scope the manager to the current Slice Machine
    // project? If not, this internal state can be removed.
    __publicField(this, "scopedDirectory");
    this.scopedDirectory = scopedDirectory;
  }
  // TODO: Make the `cookies` argument more explicit. What are these
  // mysterious cookies?
  async login(args) {
    const authState = await this._readPersistedAuthState();
    authState.base = API_ENDPOINTS.PrismicWroom;
    authState.cookies = {
      ...authState.cookies,
      ...parseCookies(args.cookies.join(COOKIE_SEPARATOR))
    };
    if (checkHasAuthenticationToken(authState)) {
      const authenticationToken = authState.cookies[AUTH_COOKIE_KEY];
      const profile = await this._getProfileForAuthenticationToken({
        authenticationToken
      });
      authState.shortId = profile.shortId;
      authState.intercomHash = profile.intercomHash;
    }
    await this._writePersistedAuthState(authState);
  }
  async getLoginSessionInfo() {
    const port = await getPorts({ port: 5555 });
    const url = new URL(`./dashboard/cli/login?source=slice-machine&port=${port}`, API_ENDPOINTS.PrismicWroom).toString();
    return {
      port,
      url
    };
  }
  async nodeLoginSession(args) {
    return new Promise(async (resolve) => {
      const timeout = setTimeout(() => {
        server.close();
        throw new Error("Login timeout, server did not receive a response within a 3-minute delay");
      }, 18e4);
      const app = h3.createApp();
      app.use(h3.fromNodeMiddleware(cors()));
      app.use(h3.fromNodeMiddleware(createPrismicAuthManagerMiddleware({
        prismicAuthManager: this,
        onLoginCallback() {
          clearTimeout(timeout);
          server.close();
          resolve();
        }
      })));
      const server = http.createServer(h3.toNodeListener(app));
      await new Promise((resolve2) => {
        server.once("listening", () => {
          resolve2();
        });
        server.listen(args.port);
      });
      if (args.onListenCallback) {
        args.onListenCallback();
      }
    });
  }
  async logout() {
    const authState = await this._readPersistedAuthState();
    authState.cookies = {};
    authState.shortId = void 0;
    authState.intercomHash = void 0;
    await this._writePersistedAuthState(authState);
  }
  async checkIsLoggedIn() {
    const authState = await this._readPersistedAuthState();
    if (checkHasAuthenticationToken(authState)) {
      const url = new URL("./validate", API_ENDPOINTS.PrismicAuthentication);
      url.searchParams.set("token", authState.cookies[AUTH_COOKIE_KEY]);
      let res;
      try {
        res = await fetch(url.toString(), {
          headers: {
            "User-Agent": SLICE_MACHINE_USER_AGENT
          }
        });
      } catch (error) {
      }
      if (!res || !res.ok) {
        await this.logout();
        return false;
      }
      return true;
    } else {
      return false;
    }
  }
  async getAuthenticationCookies() {
    const isLoggedIn = await this.checkIsLoggedIn();
    if (isLoggedIn) {
      const authState = await this._readPersistedAuthState();
      if (checkHasAuthenticationToken(authState)) {
        return authState.cookies;
      }
    }
    throw new UnauthenticatedError();
  }
  async getAuthenticationToken() {
    const cookies = await this.getAuthenticationCookies();
    return cookies[AUTH_COOKIE_KEY];
  }
  async refreshAuthenticationToken() {
    const authState = await this._readPersistedAuthState();
    if (checkHasAuthenticationToken(authState)) {
      const url = new URL("./refreshtoken", API_ENDPOINTS.PrismicAuthentication);
      url.searchParams.set("token", authState.cookies[AUTH_COOKIE_KEY]);
      const res = await fetch(url.toString(), {
        headers: {
          "User-Agent": SLICE_MACHINE_USER_AGENT
        }
      });
      const text = await res.text();
      if (res.ok) {
        authState.cookies[AUTH_COOKIE_KEY] = text;
        await this._writePersistedAuthState(authState);
      } else {
        throw new InternalError("Failed to refresh authentication token.", {
          cause: text
        });
      }
    } else {
      throw new UnauthenticatedError();
    }
  }
  async getProfile() {
    const authenticationToken = await this.getAuthenticationToken();
    return await this._getProfileForAuthenticationToken({
      authenticationToken
    });
  }
  async _getProfileForAuthenticationToken(args) {
    const url = new URL("./profile", API_ENDPOINTS.PrismicUser);
    const res = await fetch(url.toString(), {
      headers: {
        Authorization: `Bearer ${args.authenticationToken}`,
        "User-Agent": SLICE_MACHINE_USER_AGENT
      }
    });
    if (res.ok) {
      const json = await res.json();
      const { value: profile, error } = decode(PrismicUserProfile, json);
      if (error) {
        throw new UnexpectedDataError("Received invalid data from the Prismic user service.");
      }
      return profile;
    } else {
      const text = await res.text();
      throw new InternalError("Failed to retrieve profile from the Prismic user service.", {
        cause: text
      });
    }
  }
  async _readPersistedAuthState() {
    const authStateFilePath = this._getPersistedAuthStateFilePath();
    let authStateFileContents = JSON.stringify({});
    let rawAuthState = {};
    try {
      authStateFileContents = await fs.readFile(authStateFilePath, "utf8");
      rawAuthState = JSON.parse(authStateFileContents);
    } catch {
      rawAuthState = {
        ...DEFAULT_PERSISTED_AUTH_STATE,
        cookies: serializeCookies(DEFAULT_PERSISTED_AUTH_STATE.cookies)
      };
      authStateFileContents = JSON.stringify(rawAuthState, null, "	");
      await fs.mkdir(path.dirname(authStateFilePath), { recursive: true });
      await fs.writeFile(authStateFilePath, authStateFileContents);
    }
    if (typeof rawAuthState.cookies === "string") {
      rawAuthState.cookies = parseCookies(rawAuthState.cookies);
    }
    const { value: authState, error } = decode(PrismicAuthState, rawAuthState);
    if (error) {
      throw new UnexpectedDataError("Prismic authentication state is invalid.");
    }
    return authState;
  }
  async _writePersistedAuthState(authState) {
    const authStateFilePath = this._getPersistedAuthStateFilePath();
    const preparedAuthState = {
      ...authState,
      cookies: serializeCookies(authState.cookies)
    };
    try {
      await fs.writeFile(authStateFilePath, JSON.stringify(preparedAuthState, null, 2));
    } catch (error) {
      throw new InternalError("Failed to write Prismic authentication state to the file system.", {
        cause: error
      });
    }
  }
  _getPersistedAuthStateFilePath() {
    return path.resolve(this.scopedDirectory, PERSISTED_AUTH_STATE_FILE_NAME);
  }
}
export {
  PrismicAuthManager
};
//# sourceMappingURL=PrismicAuthManager.js.map
