{"version":3,"file":"promise.cjs","sources":["../../../../../../node_modules/execa/lib/promise.js"],"sourcesContent":["// eslint-disable-next-line unicorn/prefer-top-level-await\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\n\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property),\n]);\n\n// The return value is a mixin of `childProcess` and `Promise`\nexport const mergePromise = (spawned, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\t// Starting the main `promise` is deferred to avoid consuming streams\n\t\tconst value = typeof promise === 'function'\n\t\t\t? (...args) => Reflect.apply(descriptor.value, promise(), args)\n\t\t\t: descriptor.value.bind(promise);\n\n\t\tReflect.defineProperty(spawned, property, {...descriptor, value});\n\t}\n};\n\n// Use promises instead of `child_process` events\nexport const getSpawnedPromise = spawned => new Promise((resolve, reject) => {\n\tspawned.on('exit', (exitCode, signal) => {\n\t\tresolve({exitCode, signal});\n\t});\n\n\tspawned.on('error', error => {\n\t\treject(error);\n\t});\n\n\tif (spawned.stdin) {\n\t\tspawned.stdin.on('error', error => {\n\t\t\treject(error);\n\t\t});\n\t}\n});\n"],"names":[],"mappings":";;AACA,MAAM,0BAA0B,YAAY;AAAA,KAAM,YAAY;AAE9D,MAAM,cAAc,CAAC,QAAQ,SAAS,SAAS,EAAE,IAAI,cAAY;AAAA,EAChE;AAAA,EACA,QAAQ,yBAAyB,wBAAwB,QAAQ;AAClE,CAAC;AAGW,MAAC,eAAe,CAAC,SAAS,YAAY;AACjD,aAAW,CAAC,UAAU,UAAU,KAAK,aAAa;AAEjD,UAAM,QAAQ,OAAO,YAAY,aAC9B,IAAI,SAAS,QAAQ,MAAM,WAAW,OAAO,QAAS,GAAE,IAAI,IAC5D,WAAW,MAAM,KAAK,OAAO;AAEhC,YAAQ,eAAe,SAAS,UAAU,EAAC,GAAG,YAAY,MAAK,CAAC;AAAA,EAChE;AACF;AAGY,MAAC,oBAAoB,aAAW,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC5E,UAAQ,GAAG,QAAQ,CAAC,UAAU,WAAW;AACxC,YAAQ,EAAC,UAAU,OAAM,CAAC;AAAA,EAC5B,CAAE;AAED,UAAQ,GAAG,SAAS,WAAS;AAC5B,WAAO,KAAK;AAAA,EACd,CAAE;AAED,MAAI,QAAQ,OAAO;AAClB,YAAQ,MAAM,GAAG,SAAS,WAAS;AAClC,aAAO,KAAK;AAAA,IACf,CAAG;AAAA,EACD;AACF,CAAC;;;","x_google_ignoreList":[0]}