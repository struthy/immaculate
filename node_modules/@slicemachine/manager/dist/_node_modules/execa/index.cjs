"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const node_buffer = require("node:buffer");
const path = require("node:path");
const childProcess = require("node:child_process");
const process = require("node:process");
const index = require("../cross-spawn/index.cjs");
const index$1 = require("../strip-final-newline/index.cjs");
const index$3 = require('./_node_modules/npm-run-path/index.cjs');
const index$2 = require('./_node_modules/onetime/index.cjs');
const error = require("./lib/error.cjs");
const stdio = require("./lib/stdio.cjs");
const kill = require("./lib/kill.cjs");
const pipe = require("./lib/pipe.cjs");
const stream = require("./lib/stream.cjs");
const promise = require("./lib/promise.cjs");
const command = require("./lib/command.cjs");
const verbose = require("./lib/verbose.cjs");
const DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
const getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
  const env = extendEnv ? { ...process.env, ...envOption } : envOption;
  if (preferLocal) {
    return index$3.npmRunPathEnv({ env, cwd: localDir, execPath });
  }
  return env;
};
const handleArguments = (file, args, options = {}) => {
  const parsed = index._parse(file, args, options);
  file = parsed.command;
  args = parsed.args;
  options = parsed.options;
  options = {
    maxBuffer: DEFAULT_MAX_BUFFER,
    buffer: true,
    stripFinalNewline: true,
    extendEnv: true,
    preferLocal: false,
    localDir: options.cwd || process.cwd(),
    execPath: process.execPath,
    encoding: "utf8",
    reject: true,
    cleanup: true,
    all: false,
    windowsHide: true,
    verbose: verbose.verboseDefault,
    ...options
  };
  options.env = getEnv(options);
  options.stdio = stdio.normalizeStdio(options);
  if (process.platform === "win32" && path.basename(file, ".exe") === "cmd") {
    args.unshift("/q");
  }
  return { file, args, options, parsed };
};
const handleOutput = (options, value, error2) => {
  if (typeof value !== "string" && !node_buffer.Buffer.isBuffer(value)) {
    return error2 === void 0 ? void 0 : "";
  }
  if (options.stripFinalNewline) {
    return index$1(value);
  }
  return value;
};
function execa(file, args, options) {
  const parsed = handleArguments(file, args, options);
  const command$1 = command.joinCommand(file, args);
  const escapedCommand = command.getEscapedCommand(file, args);
  verbose.logCommand(escapedCommand, parsed.options);
  kill.validateTimeout(parsed.options);
  let spawned;
  try {
    spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
  } catch (error$1) {
    const dummySpawned = new childProcess.ChildProcess();
    const errorPromise = Promise.reject(error.makeError({
      error: error$1,
      stdout: "",
      stderr: "",
      all: "",
      command: command$1,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    }));
    promise.mergePromise(dummySpawned, errorPromise);
    return dummySpawned;
  }
  const spawnedPromise = promise.getSpawnedPromise(spawned);
  const timedPromise = kill.setupTimeout(spawned, parsed.options, spawnedPromise);
  const processDone = kill.setExitHandler(spawned, parsed.options, timedPromise);
  const context = { isCanceled: false };
  spawned.kill = kill.spawnedKill.bind(null, spawned.kill.bind(spawned));
  spawned.cancel = kill.spawnedCancel.bind(null, spawned, context);
  const handlePromise = async () => {
    const [{ error: error$1, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await stream.getSpawnedResult(spawned, parsed.options, processDone);
    const stdout = handleOutput(parsed.options, stdoutResult);
    const stderr = handleOutput(parsed.options, stderrResult);
    const all = handleOutput(parsed.options, allResult);
    if (error$1 || exitCode !== 0 || signal !== null) {
      const returnedError = error.makeError({
        error: error$1,
        exitCode,
        signal,
        stdout,
        stderr,
        all,
        command: command$1,
        escapedCommand,
        parsed,
        timedOut,
        isCanceled: parsed.options.signal ? parsed.options.signal.aborted : false,
        killed: spawned.killed
      });
      if (!parsed.options.reject) {
        return returnedError;
      }
      throw returnedError;
    }
    return {
      command: command$1,
      escapedCommand,
      exitCode: 0,
      stdout,
      stderr,
      all,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  };
  const handlePromiseOnce = index$2(handlePromise);
  stream.handleInput(spawned, parsed.options);
  spawned.all = stream.makeAllStream(spawned, parsed.options);
  pipe.addPipeMethods(spawned);
  promise.mergePromise(spawned, handlePromiseOnce);
  return spawned;
}
function execaSync(file, args, options) {
  const parsed = handleArguments(file, args, options);
  const command$1 = command.joinCommand(file, args);
  const escapedCommand = command.getEscapedCommand(file, args);
  verbose.logCommand(escapedCommand, parsed.options);
  const input = stream.handleInputSync(parsed.options);
  let result;
  try {
    result = childProcess.spawnSync(parsed.file, parsed.args, { ...parsed.options, input });
  } catch (error$1) {
    throw error.makeError({
      error: error$1,
      stdout: "",
      stderr: "",
      all: "",
      command: command$1,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    });
  }
  const stdout = handleOutput(parsed.options, result.stdout, result.error);
  const stderr = handleOutput(parsed.options, result.stderr, result.error);
  if (result.error || result.status !== 0 || result.signal !== null) {
    const error$1 = error.makeError({
      stdout,
      stderr,
      error: result.error,
      signal: result.signal,
      exitCode: result.status,
      command: command$1,
      escapedCommand,
      parsed,
      timedOut: result.error && result.error.code === "ETIMEDOUT",
      isCanceled: false,
      killed: result.signal !== null
    });
    if (!parsed.options.reject) {
      return error$1;
    }
    throw error$1;
  }
  return {
    command: command$1,
    escapedCommand,
    exitCode: 0,
    stdout,
    stderr,
    failed: false,
    timedOut: false,
    isCanceled: false,
    killed: false
  };
}
function execaCommand(command$1, options) {
  const [file, ...args] = command.parseCommand(command$1);
  return execa(file, args, options);
}
function execaCommandSync(command$1, options) {
  const [file, ...args] = command.parseCommand(command$1);
  return execaSync(file, args, options);
}
exports.execa = execa;
exports.execaCommand = execaCommand;
exports.execaCommandSync = execaCommandSync;
exports.execaSync = execaSync;
//# sourceMappingURL=index.cjs.map
