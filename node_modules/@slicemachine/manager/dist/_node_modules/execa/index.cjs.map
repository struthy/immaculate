{"version":3,"file":"index.cjs","sources":["../../../../../node_modules/execa/index.js"],"sourcesContent":["import {Buffer} from 'node:buffer';\nimport path from 'node:path';\nimport childProcess from 'node:child_process';\nimport process from 'node:process';\nimport crossSpawn from 'cross-spawn';\nimport stripFinalNewline from 'strip-final-newline';\nimport {npmRunPathEnv} from 'npm-run-path';\nimport onetime from 'onetime';\nimport {makeError} from './lib/error.js';\nimport {normalizeStdio, normalizeStdioNode} from './lib/stdio.js';\nimport {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} from './lib/kill.js';\nimport {addPipeMethods} from './lib/pipe.js';\nimport {handleInput, getSpawnedResult, makeAllStream, handleInputSync} from './lib/stream.js';\nimport {mergePromise, getSpawnedPromise} from './lib/promise.js';\nimport {joinCommand, parseCommand, parseTemplates, getEscapedCommand} from './lib/command.js';\nimport {logCommand, verboseDefault} from './lib/verbose.js';\n\nconst DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;\n\nconst getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {\n\tconst env = extendEnv ? {...process.env, ...envOption} : envOption;\n\n\tif (preferLocal) {\n\t\treturn npmRunPathEnv({env, cwd: localDir, execPath});\n\t}\n\n\treturn env;\n};\n\nconst handleArguments = (file, args, options = {}) => {\n\tconst parsed = crossSpawn._parse(file, args, options);\n\tfile = parsed.command;\n\targs = parsed.args;\n\toptions = parsed.options;\n\n\toptions = {\n\t\tmaxBuffer: DEFAULT_MAX_BUFFER,\n\t\tbuffer: true,\n\t\tstripFinalNewline: true,\n\t\textendEnv: true,\n\t\tpreferLocal: false,\n\t\tlocalDir: options.cwd || process.cwd(),\n\t\texecPath: process.execPath,\n\t\tencoding: 'utf8',\n\t\treject: true,\n\t\tcleanup: true,\n\t\tall: false,\n\t\twindowsHide: true,\n\t\tverbose: verboseDefault,\n\t\t...options,\n\t};\n\n\toptions.env = getEnv(options);\n\n\toptions.stdio = normalizeStdio(options);\n\n\tif (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n\t\t// #116\n\t\targs.unshift('/q');\n\t}\n\n\treturn {file, args, options, parsed};\n};\n\nconst handleOutput = (options, value, error) => {\n\tif (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n\t\t// When `execaSync()` errors, we normalize it to '' to mimic `execa()`\n\t\treturn error === undefined ? undefined : '';\n\t}\n\n\tif (options.stripFinalNewline) {\n\t\treturn stripFinalNewline(value);\n\t}\n\n\treturn value;\n};\n\nexport function execa(file, args, options) {\n\tconst parsed = handleArguments(file, args, options);\n\tconst command = joinCommand(file, args);\n\tconst escapedCommand = getEscapedCommand(file, args);\n\tlogCommand(escapedCommand, parsed.options);\n\n\tvalidateTimeout(parsed.options);\n\n\tlet spawned;\n\ttry {\n\t\tspawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);\n\t} catch (error) {\n\t\t// Ensure the returned error is always both a promise and a child process\n\t\tconst dummySpawned = new childProcess.ChildProcess();\n\t\tconst errorPromise = Promise.reject(makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false,\n\t\t}));\n\t\tmergePromise(dummySpawned, errorPromise);\n\t\treturn dummySpawned;\n\t}\n\n\tconst spawnedPromise = getSpawnedPromise(spawned);\n\tconst timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);\n\tconst processDone = setExitHandler(spawned, parsed.options, timedPromise);\n\n\tconst context = {isCanceled: false};\n\n\tspawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));\n\tspawned.cancel = spawnedCancel.bind(null, spawned, context);\n\n\tconst handlePromise = async () => {\n\t\tconst [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);\n\t\tconst stdout = handleOutput(parsed.options, stdoutResult);\n\t\tconst stderr = handleOutput(parsed.options, stderrResult);\n\t\tconst all = handleOutput(parsed.options, allResult);\n\n\t\tif (error || exitCode !== 0 || signal !== null) {\n\t\t\tconst returnedError = makeError({\n\t\t\t\terror,\n\t\t\t\texitCode,\n\t\t\t\tsignal,\n\t\t\t\tstdout,\n\t\t\t\tstderr,\n\t\t\t\tall,\n\t\t\t\tcommand,\n\t\t\t\tescapedCommand,\n\t\t\t\tparsed,\n\t\t\t\ttimedOut,\n\t\t\t\tisCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),\n\t\t\t\tkilled: spawned.killed,\n\t\t\t});\n\n\t\t\tif (!parsed.options.reject) {\n\t\t\t\treturn returnedError;\n\t\t\t}\n\n\t\t\tthrow returnedError;\n\t\t}\n\n\t\treturn {\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\texitCode: 0,\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\tall,\n\t\t\tfailed: false,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false,\n\t\t};\n\t};\n\n\tconst handlePromiseOnce = onetime(handlePromise);\n\n\thandleInput(spawned, parsed.options);\n\n\tspawned.all = makeAllStream(spawned, parsed.options);\n\n\taddPipeMethods(spawned);\n\tmergePromise(spawned, handlePromiseOnce);\n\treturn spawned;\n}\n\nexport function execaSync(file, args, options) {\n\tconst parsed = handleArguments(file, args, options);\n\tconst command = joinCommand(file, args);\n\tconst escapedCommand = getEscapedCommand(file, args);\n\tlogCommand(escapedCommand, parsed.options);\n\n\tconst input = handleInputSync(parsed.options);\n\n\tlet result;\n\ttry {\n\t\tresult = childProcess.spawnSync(parsed.file, parsed.args, {...parsed.options, input});\n\t} catch (error) {\n\t\tthrow makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false,\n\t\t});\n\t}\n\n\tconst stdout = handleOutput(parsed.options, result.stdout, result.error);\n\tconst stderr = handleOutput(parsed.options, result.stderr, result.error);\n\n\tif (result.error || result.status !== 0 || result.signal !== null) {\n\t\tconst error = makeError({\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\terror: result.error,\n\t\t\tsignal: result.signal,\n\t\t\texitCode: result.status,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: result.error && result.error.code === 'ETIMEDOUT',\n\t\t\tisCanceled: false,\n\t\t\tkilled: result.signal !== null,\n\t\t});\n\n\t\tif (!parsed.options.reject) {\n\t\t\treturn error;\n\t\t}\n\n\t\tthrow error;\n\t}\n\n\treturn {\n\t\tcommand,\n\t\tescapedCommand,\n\t\texitCode: 0,\n\t\tstdout,\n\t\tstderr,\n\t\tfailed: false,\n\t\ttimedOut: false,\n\t\tisCanceled: false,\n\t\tkilled: false,\n\t};\n}\n\nconst normalizeScriptStdin = ({input, inputFile, stdio}) => input === undefined && inputFile === undefined && stdio === undefined\n\t? {stdin: 'inherit'}\n\t: {};\n\nconst normalizeScriptOptions = (options = {}) => ({\n\tpreferLocal: true,\n\t...normalizeScriptStdin(options),\n\t...options,\n});\n\nfunction create$(options) {\n\tfunction $(templatesOrOptions, ...expressions) {\n\t\tif (!Array.isArray(templatesOrOptions)) {\n\t\t\treturn create$({...options, ...templatesOrOptions});\n\t\t}\n\n\t\tconst [file, ...args] = parseTemplates(templatesOrOptions, expressions);\n\t\treturn execa(file, args, normalizeScriptOptions(options));\n\t}\n\n\t$.sync = (templates, ...expressions) => {\n\t\tif (!Array.isArray(templates)) {\n\t\t\tthrow new TypeError('Please use $(options).sync`command` instead of $.sync(options)`command`.');\n\t\t}\n\n\t\tconst [file, ...args] = parseTemplates(templates, expressions);\n\t\treturn execaSync(file, args, normalizeScriptOptions(options));\n\t};\n\n\treturn $;\n}\n\nexport const $ = create$();\n\nexport function execaCommand(command, options) {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execa(file, args, options);\n}\n\nexport function execaCommandSync(command, options) {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execaSync(file, args, options);\n}\n\nexport function execaNode(scriptPath, args, options = {}) {\n\tif (args && !Array.isArray(args) && typeof args === 'object') {\n\t\toptions = args;\n\t\targs = [];\n\t}\n\n\tconst stdio = normalizeStdioNode(options);\n\tconst defaultExecArgv = process.execArgv.filter(arg => !arg.startsWith('--inspect'));\n\n\tconst {\n\t\tnodePath = process.execPath,\n\t\tnodeOptions = defaultExecArgv,\n\t} = options;\n\n\treturn execa(\n\t\tnodePath,\n\t\t[\n\t\t\t...nodeOptions,\n\t\t\tscriptPath,\n\t\t\t...(Array.isArray(args) ? args : []),\n\t\t],\n\t\t{\n\t\t\t...options,\n\t\t\tstdin: undefined,\n\t\t\tstdout: undefined,\n\t\t\tstderr: undefined,\n\t\t\tstdio,\n\t\t\tshell: false,\n\t\t},\n\t);\n}\n"],"names":["npmRunPathEnv","crossSpawn","verboseDefault","normalizeStdio","error","Buffer","stripFinalNewline","command","joinCommand","getEscapedCommand","logCommand","validateTimeout","makeError","mergePromise","getSpawnedPromise","setupTimeout","setExitHandler","spawnedKill","spawnedCancel","getSpawnedResult","onetime","handleInput","makeAllStream","addPipeMethods","handleInputSync","parseCommand"],"mappings":"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","x_google_ignoreList":[0]}