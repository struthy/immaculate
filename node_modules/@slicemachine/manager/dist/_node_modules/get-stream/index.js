import { getDefaultExportFromCjs } from "../../_virtual/_commonjsHelpers.js";
import { __module as getStream$2 } from "../../_virtual/index5.js";
import require$$0$1 from "buffer";
import require$$0 from "stream";
import require$$2 from "util";
import { b as bufferStream$1 } from "./buffer-stream.js";
const { constants: BufferConstants } = require$$0$1;
const stream = require$$0;
const { promisify } = require$$2;
const bufferStream = bufferStream$1;
const streamPipelinePromisified = promisify(stream.pipeline);
class MaxBufferError extends Error {
  constructor() {
    super("maxBuffer exceeded");
    this.name = "MaxBufferError";
  }
}
async function getStream(inputStream, options) {
  if (!inputStream) {
    throw new Error("Expected a stream");
  }
  options = {
    maxBuffer: Infinity,
    ...options
  };
  const { maxBuffer } = options;
  const stream2 = bufferStream(options);
  await new Promise((resolve, reject) => {
    const rejectPromise = (error) => {
      if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
        error.bufferedData = stream2.getBufferedValue();
      }
      reject(error);
    };
    (async () => {
      try {
        await streamPipelinePromisified(inputStream, stream2);
        resolve();
      } catch (error) {
        rejectPromise(error);
      }
    })();
    stream2.on("data", () => {
      if (stream2.getBufferedLength() > maxBuffer) {
        rejectPromise(new MaxBufferError());
      }
    });
  });
  return stream2.getBufferedValue();
}
getStream$2.exports = getStream;
getStream$2.exports.buffer = (stream2, options) => getStream(stream2, { ...options, encoding: "buffer" });
getStream$2.exports.array = (stream2, options) => getStream(stream2, { ...options, array: true });
getStream$2.exports.MaxBufferError = MaxBufferError;
var getStreamExports = getStream$2.exports;
const getStream$1 = /* @__PURE__ */ getDefaultExportFromCjs(getStreamExports);
export {
  getStream$1 as default
};
//# sourceMappingURL=index.js.map
