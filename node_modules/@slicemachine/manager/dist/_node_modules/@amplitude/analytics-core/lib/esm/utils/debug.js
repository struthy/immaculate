import { __assign, __values } from "../../../../../tslib/tslib.es6.js";
import { LogLevel } from "../../../../analytics-types/lib/esm/logger.js";
var getStacktrace = function(ignoreDepth) {
  if (ignoreDepth === void 0) {
    ignoreDepth = 0;
  }
  var trace = new Error().stack || "";
  return trace.split("\n").slice(2 + ignoreDepth).map(function(text) {
    return text.trim();
  });
};
var getClientLogConfig = function(client) {
  return function() {
    var _a = __assign({}, client.config), logger = _a.loggerProvider, logLevel = _a.logLevel;
    return {
      logger,
      logLevel
    };
  };
};
var getValueByStringPath = function(obj, path) {
  var e_1, _a;
  path = path.replace(/\[(\w+)\]/g, ".$1");
  path = path.replace(/^\./, "");
  try {
    for (var _b = __values(path.split(".")), _c = _b.next(); !_c.done; _c = _b.next()) {
      var attr = _c.value;
      if (attr in obj) {
        obj = obj[attr];
      } else {
        return;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return obj;
};
var getClientStates = function(client, paths) {
  return function() {
    var e_2, _a;
    var res = {};
    try {
      for (var paths_1 = __values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
        var path = paths_1_1.value;
        res[path] = getValueByStringPath(client, path);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return))
          _a.call(paths_1);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return res;
  };
};
var debugWrapper = function(fn, fnName, getLogConfig, getStates, fnContext) {
  if (fnContext === void 0) {
    fnContext = null;
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var _a = getLogConfig(), logger = _a.logger, logLevel = _a.logLevel;
    if (logLevel && logLevel < LogLevel.Debug || !logLevel || !logger) {
      return fn.apply(fnContext, args);
    }
    var debugContext = {
      type: "invoke public method",
      name: fnName,
      args,
      stacktrace: getStacktrace(1),
      time: {
        start: (/* @__PURE__ */ new Date()).toISOString()
      },
      states: {}
    };
    if (getStates && debugContext.states) {
      debugContext.states.before = getStates();
    }
    var result = fn.apply(fnContext, args);
    if (result && result.promise) {
      result.promise.then(function() {
        if (getStates && debugContext.states) {
          debugContext.states.after = getStates();
        }
        if (debugContext.time) {
          debugContext.time.end = (/* @__PURE__ */ new Date()).toISOString();
        }
        logger.debug(JSON.stringify(debugContext, null, 2));
      });
    } else {
      if (getStates && debugContext.states) {
        debugContext.states.after = getStates();
      }
      if (debugContext.time) {
        debugContext.time.end = (/* @__PURE__ */ new Date()).toISOString();
      }
      logger.debug(JSON.stringify(debugContext, null, 2));
    }
    return result;
  };
};
export {
  debugWrapper,
  getClientLogConfig,
  getClientStates,
  getStacktrace,
  getValueByStringPath
};
//# sourceMappingURL=debug.js.map
