"use strict";
const _commonjsHelpers = require("../../../../../../_virtual/_commonjsHelpers.cjs");
const http = require("../../../../../../_virtual/http.cjs");
const require$$0 = require("http");
const require$$1 = require("https");
const require$$2 = require("url");
var __awaiter = _commonjsHelpers.commonjsGlobal && _commonjsHelpers.commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = _commonjsHelpers.commonjsGlobal && _commonjsHelpers.commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(http.__exports, "__esModule", { value: true });
http.__exports.WrapperClient = http.__exports.FetchHttpClient = void 0;
const http_1 = __importDefault(require$$0);
const https_1 = __importDefault(require$$1);
const url_1 = __importDefault(require$$2);
const defaultHttpAgent = new https_1.default.Agent({
  keepAlive: true
});
class FetchHttpClient {
  constructor(httpAgent) {
    this.httpAgent = httpAgent || defaultHttpAgent;
  }
  /**
   * Wraps the http and https libraries in a fetch()-like interface
   * @param requestUrl
   * @param method HTTP Method (GET, POST, etc.)
   * @param headers HTTP Headers
   * @param  Request body
   */
  request(requestUrl, method, headers, body, timeoutMillis) {
    return new Promise((resolve, reject) => {
      if (timeoutMillis === 0) {
        reject(Error("Response timed out"));
        return;
      }
      const urlParams = url_1.default.parse(requestUrl);
      const options = Object.assign(Object.assign({}, urlParams), { method, headers, body, agent: this.httpAgent, timeout: timeoutMillis });
      const protocol = urlParams.protocol === "http:" ? http_1.default : https_1.default;
      const req = protocol.request(options);
      req.on("response", (res) => {
        res.setEncoding("utf-8");
        let responseBody = "";
        res.on("data", (chunk) => {
          responseBody += chunk;
        });
        res.on("end", () => {
          resolve({
            status: res.statusCode,
            body: responseBody
          });
        });
      });
      req.on("timeout", () => {
        req.destroy(Error("Socket connection timed out"));
      });
      req.on("error", (e) => {
        reject(e);
      });
      if (method !== "GET" && body) {
        req.write(body);
      }
      req.end();
    });
  }
}
http.__exports.FetchHttpClient = FetchHttpClient;
class WrapperClient {
  constructor(client) {
    this.client = client;
  }
  request(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.client.request(request.requestUrl, request.method, request.headers, null, request.timeoutMillis);
    });
  }
}
http.__exports.WrapperClient = WrapperClient;
module.exports = http.__exports;
//# sourceMappingURL=http.cjs.map
