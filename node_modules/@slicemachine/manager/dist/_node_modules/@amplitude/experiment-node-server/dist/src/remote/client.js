import { commonjsGlobal } from "../../../../../../_virtual/_commonjsHelpers.js";
import { __exports as client } from "../../../../../../_virtual/client.js";
import require$$1 from "../../../../../../_virtual/experiment-core.esm.js";
import "../../gen/version.js";
import "../transport/http.js";
import "../types/config.js";
import "../util/time.js";
import "../util/variant.js";
import { __exports as version } from "../../../../../../_virtual/version.js";
import { __exports as http } from "../../../../../../_virtual/http.js";
import { __exports as config } from "../../../../../../_virtual/config.js";
import { __exports as time } from "../../../../../../_virtual/time.js";
import { __exports as variant } from "../../../../../../_virtual/variant.js";
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(client, "__esModule", { value: true });
client.ExperimentClient = client.RemoteEvaluationClient = void 0;
const experiment_core_1 = require$$1;
const version_1 = version;
const http_1 = http;
const config_1 = config;
const time_1 = time;
const variant_1 = variant;
class RemoteEvaluationClient {
  /**
   * Creates a new RemoteEvaluationClient instance.
   *
   * @param apiKey The environment API Key
   * @param config See {@link ExperimentConfig} for config options
   */
  constructor(apiKey, config2) {
    var _a;
    this.apiKey = apiKey;
    this.config = Object.assign(Object.assign({}, config_1.RemoteEvaluationDefaults), config2);
    this.evaluationApi = new experiment_core_1.SdkEvaluationApi(apiKey, this.config.serverUrl, new http_1.WrapperClient(new http_1.FetchHttpClient((_a = this.config) === null || _a === void 0 ? void 0 : _a.httpAgent)));
  }
  /**
   * Fetch remote evaluated variants for a user. This function can
   * automatically retry the request on failure (if configured), and will
   * throw the original error if all retries fail.
   *
   * Unlike {@link fetch}, this function returns a default variant object
   * if the flag or experiment was evaluated, but the user was not assigned a
   * variant (i.e. 'off').
   *
   * @param user The user to fetch variants for.
   * @param options Options to configure the fetch request.
   */
  fetchV2(user, options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.apiKey) {
        throw Error("Experiment API key is empty");
      }
      this.debug("[Experiment] Fetching variants for user: ", user);
      try {
        return yield this.doFetch(user, this.config.fetchTimeoutMillis, options);
      } catch (e) {
        console.error("[Experiment] Fetch failed: ", e);
        try {
          return yield this.retryFetch(user, options);
        } catch (e2) {
          console.error(e2);
        }
        throw e;
      }
    });
  }
  /**
   * Fetch all variants for a user.
   *
   * This method will automatically retry if configured (default).
   *
   * @param user The {@link ExperimentUser} context
   * @param options The {@link FetchOptions} for this specific fetch request.
   * @return The {@link Variants} for the user on success, empty
   * {@link Variants} on error.
   * @deprecated use fetchV2 instead
   */
  fetch(user, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const results = yield this.fetchV2(user, options);
        return (0, variant_1.filterDefaultVariants)(results);
      } catch (e) {
        console.error("[Experiment] Failed to fetch variants: ", e);
        return {};
      }
    });
  }
  doFetch(user, timeoutMillis, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const userContext = this.addContext(user || {});
      const results = yield this.evaluationApi.getVariants(userContext, {
        flagKeys: options === null || options === void 0 ? void 0 : options.flagKeys,
        timeoutMillis
      });
      this.debug("[Experiment] Fetched variants: ", results);
      return (0, variant_1.evaluationVariantsToVariants)(results);
    });
  }
  retryFetch(user, options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.config.fetchRetries == 0) {
        return {};
      }
      this.debug("[Experiment] Retrying fetch");
      let err = null;
      let delayMillis = this.config.fetchRetryBackoffMinMillis;
      for (let i = 0; i < this.config.fetchRetries; i++) {
        yield (0, time_1.sleep)(delayMillis);
        try {
          return yield this.doFetch(user, this.config.fetchRetryTimeoutMillis, options);
        } catch (e) {
          console.error("[Experiment] Retry falied: ", e);
          err = e;
        }
        delayMillis = Math.min(delayMillis * this.config.fetchRetryBackoffScalar, this.config.fetchRetryBackoffMaxMillis);
      }
      throw err;
    });
  }
  addContext(user) {
    return Object.assign({ library: `experiment-node-server/${version_1.version}` }, user);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  debug(message, ...optionalParams) {
    if (this.config.debug) {
      console.debug(message, ...optionalParams);
    }
  }
}
client.RemoteEvaluationClient = RemoteEvaluationClient;
class ExperimentClient extends RemoteEvaluationClient {
  constructor(apiKey, config2) {
    super(apiKey, config2);
  }
}
client.ExperimentClient = ExperimentClient;
export {
  client as default
};
//# sourceMappingURL=client.js.map
