import { commonjsGlobal } from "../../../../../../_virtual/_commonjsHelpers.js";
import { __exports as client } from "../../../../../../_virtual/client2.js";
import require$$0 from "../../../../../../_virtual/index3.js";
import require$$1 from "../../../../../../_virtual/experiment-core.esm.js";
import "../assignment/assignment.js";
import "../assignment/assignment-filter.js";
import "../assignment/assignment-service.js";
import "../transport/http.js";
import "../types/config.js";
import "../util/logger.js";
import "../util/user.js";
import "../util/variant.js";
import "./cache.js";
import "./fetcher.js";
import "./poller.js";
import { __exports as assignment } from "../../../../../../_virtual/assignment.js";
import { __exports as assignmentFilter } from "../../../../../../_virtual/assignment-filter.js";
import { __exports as assignmentService } from "../../../../../../_virtual/assignment-service.js";
import { __exports as http } from "../../../../../../_virtual/http.js";
import { __exports as config } from "../../../../../../_virtual/config.js";
import { __exports as logger } from "../../../../../../_virtual/logger.js";
import { __exports as user } from "../../../../../../_virtual/user.js";
import { __exports as variant } from "../../../../../../_virtual/variant.js";
import { __exports as cache } from "../../../../../../_virtual/cache.js";
import { __exports as fetcher } from "../../../../../../_virtual/fetcher.js";
import { __exports as poller } from "../../../../../../_virtual/poller.js";
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = commonjsGlobal && commonjsGlobal.__rest || function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
Object.defineProperty(client, "__esModule", { value: true });
client.LocalEvaluationClient = void 0;
const amplitude = __importStar(require$$0);
const experiment_core_1 = require$$1;
const assignment_1 = assignment;
const assignment_filter_1 = assignmentFilter;
const assignment_service_1 = assignmentService;
const http_1 = http;
const config_1 = config;
const logger_1 = logger;
const user_1 = user;
const variant_1 = variant;
const cache_1 = cache;
const fetcher_1 = fetcher;
const poller_1 = poller;
class LocalEvaluationClient {
  constructor(apiKey, config2, flagConfigCache, httpClient = new http_1.FetchHttpClient(config2 === null || config2 === void 0 ? void 0 : config2.httpAgent)) {
    this.config = Object.assign(Object.assign({}, config_1.LocalEvaluationDefaults), config2);
    const fetcher2 = new fetcher_1.FlagConfigFetcher(apiKey, httpClient, this.config.serverUrl, this.config.debug);
    this.cache = new cache_1.InMemoryFlagConfigCache(flagConfigCache, this.config.bootstrap);
    this.logger = new logger_1.ConsoleLogger(this.config.debug);
    this.poller = new poller_1.FlagConfigPoller(fetcher2, this.cache, this.config.flagConfigPollingIntervalMillis, this.config.debug);
    if (this.config.assignmentConfig) {
      this.config.assignmentConfig = Object.assign(Object.assign({}, config_1.AssignmentConfigDefaults), this.config.assignmentConfig);
      this.assignmentService = this.createAssignmentService(this.config.assignmentConfig);
    }
    this.evaluation = new experiment_core_1.EvaluationEngine();
  }
  createAssignmentService(assignmentConfig) {
    const instance = amplitude.createInstance();
    const { apiKey, cacheCapacity } = assignmentConfig, ampConfig = __rest(assignmentConfig, ["apiKey", "cacheCapacity"]);
    instance.init(apiKey, ampConfig);
    return new assignment_service_1.AmplitudeAssignmentService(instance, new assignment_filter_1.InMemoryAssignmentFilter(cacheCapacity));
  }
  /**
   * Locally evaluate varints for a user.
   *
   * This function will only evaluate flags for the keys specified in the
   * {@link flagKeys} argument. If {@link flagKeys} is missing, all flags in the
   * {@link FlagConfigCache} will be evaluated.
   *
   * Unlike {@link evaluate}, this function returns a default variant object
   * if the flag or experiment was evaluated, but the user was not assigned a
   * variant (i.e. 'off').
   *
   * @param user The user to evaluate
   * @param flagKeys The flags to evaluate with the user. If empty, all flags
   * from the flag cache are evaluated.
   * @returns The evaluated variants
   */
  evaluateV2(user2, flagKeys) {
    var _a;
    const flags = this.cache.getAllCached();
    this.logger.debug("[Experiment] evaluate - user:", user2, "flags:", flags);
    const context = (0, user_1.convertUserToEvaluationContext)(user2);
    const sortedFlags = (0, experiment_core_1.topologicalSort)(flags, flagKeys);
    const results = this.evaluation.evaluate(context, sortedFlags);
    void ((_a = this.assignmentService) === null || _a === void 0 ? void 0 : _a.track(new assignment_1.Assignment(user2, results)));
    this.logger.debug("[Experiment] evaluate - variants: ", results);
    return (0, variant_1.evaluationVariantsToVariants)(results);
  }
  /**
   * Locally evaluates flag variants for a user.
   *
   * This function will only evaluate flags for the keys specified in the
   * {@link flagKeys} argument. If {@link flagKeys} is missing, all flags in the
   * {@link FlagConfigCache} will be evaluated.
   *
   * @param user The user to evaluate
   * @param flagKeys The flags to evaluate with the user. If empty, all flags
   * from the flag cache are evaluated.
   * @returns The evaluated variants
   * @deprecated use evaluateV2 instead
   */
  evaluate(user2, flagKeys) {
    return __awaiter(this, void 0, void 0, function* () {
      const results = this.evaluateV2(user2, flagKeys);
      return (0, variant_1.filterDefaultVariants)(results);
    });
  }
  /**
   * Fetch initial flag configurations and start polling for updates.
   *
   * You must call this function to begin polling for flag config updates.
   * The promise returned by this function is resolved when the initial call
   * to fetch the flag configuration completes.
   *
   * Calling this function while the poller is already running does nothing.
   */
  start() {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.poller.start();
    });
  }
  /**
   * Stop polling for flag configurations.
   *
   * Calling this function while the poller is not running will do nothing.
   */
  stop() {
    return this.poller.stop();
  }
}
client.LocalEvaluationClient = LocalEvaluationClient;
export {
  client as default
};
//# sourceMappingURL=client.js.map
