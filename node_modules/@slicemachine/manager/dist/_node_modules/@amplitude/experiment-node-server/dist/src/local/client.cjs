"use strict";
const _commonjsHelpers = require("../../../../../../_virtual/_commonjsHelpers.cjs");
const client = require("../../../../../../_virtual/client2.cjs");
const index = require("../../../../../../_virtual/index3.cjs");
const experimentCore_esm = require("../../../../../../_virtual/experiment-core.esm.cjs");
require("../assignment/assignment.cjs");
require("../assignment/assignment-filter.cjs");
require("../assignment/assignment-service.cjs");
require("../transport/http.cjs");
require("../types/config.cjs");
require("../util/logger.cjs");
require("../util/user.cjs");
require("../util/variant.cjs");
require("./cache.cjs");
require("./fetcher.cjs");
require("./poller.cjs");
const assignment = require("../../../../../../_virtual/assignment.cjs");
const assignmentFilter = require("../../../../../../_virtual/assignment-filter.cjs");
const assignmentService = require("../../../../../../_virtual/assignment-service.cjs");
const http = require("../../../../../../_virtual/http.cjs");
const config = require("../../../../../../_virtual/config.cjs");
const logger = require("../../../../../../_virtual/logger.cjs");
const user = require("../../../../../../_virtual/user.cjs");
const variant = require("../../../../../../_virtual/variant.cjs");
const cache = require("../../../../../../_virtual/cache.cjs");
const fetcher = require("../../../../../../_virtual/fetcher.cjs");
const poller = require("../../../../../../_virtual/poller.cjs");
var __createBinding = _commonjsHelpers.commonjsGlobal && _commonjsHelpers.commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = _commonjsHelpers.commonjsGlobal && _commonjsHelpers.commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = _commonjsHelpers.commonjsGlobal && _commonjsHelpers.commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __awaiter = _commonjsHelpers.commonjsGlobal && _commonjsHelpers.commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = _commonjsHelpers.commonjsGlobal && _commonjsHelpers.commonjsGlobal.__rest || function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
Object.defineProperty(client.__exports, "__esModule", { value: true });
client.__exports.LocalEvaluationClient = void 0;
const amplitude = __importStar(index);
const experiment_core_1 = experimentCore_esm;
const assignment_1 = assignment.__exports;
const assignment_filter_1 = assignmentFilter.__exports;
const assignment_service_1 = assignmentService.__exports;
const http_1 = http.__exports;
const config_1 = config.__exports;
const logger_1 = logger.__exports;
const user_1 = user.__exports;
const variant_1 = variant.__exports;
const cache_1 = cache.__exports;
const fetcher_1 = fetcher.__exports;
const poller_1 = poller.__exports;
class LocalEvaluationClient {
  constructor(apiKey, config2, flagConfigCache, httpClient = new http_1.FetchHttpClient(config2 === null || config2 === void 0 ? void 0 : config2.httpAgent)) {
    this.config = Object.assign(Object.assign({}, config_1.LocalEvaluationDefaults), config2);
    const fetcher2 = new fetcher_1.FlagConfigFetcher(apiKey, httpClient, this.config.serverUrl, this.config.debug);
    this.cache = new cache_1.InMemoryFlagConfigCache(flagConfigCache, this.config.bootstrap);
    this.logger = new logger_1.ConsoleLogger(this.config.debug);
    this.poller = new poller_1.FlagConfigPoller(fetcher2, this.cache, this.config.flagConfigPollingIntervalMillis, this.config.debug);
    if (this.config.assignmentConfig) {
      this.config.assignmentConfig = Object.assign(Object.assign({}, config_1.AssignmentConfigDefaults), this.config.assignmentConfig);
      this.assignmentService = this.createAssignmentService(this.config.assignmentConfig);
    }
    this.evaluation = new experiment_core_1.EvaluationEngine();
  }
  createAssignmentService(assignmentConfig) {
    const instance = amplitude.createInstance();
    const { apiKey, cacheCapacity } = assignmentConfig, ampConfig = __rest(assignmentConfig, ["apiKey", "cacheCapacity"]);
    instance.init(apiKey, ampConfig);
    return new assignment_service_1.AmplitudeAssignmentService(instance, new assignment_filter_1.InMemoryAssignmentFilter(cacheCapacity));
  }
  /**
   * Locally evaluate varints for a user.
   *
   * This function will only evaluate flags for the keys specified in the
   * {@link flagKeys} argument. If {@link flagKeys} is missing, all flags in the
   * {@link FlagConfigCache} will be evaluated.
   *
   * Unlike {@link evaluate}, this function returns a default variant object
   * if the flag or experiment was evaluated, but the user was not assigned a
   * variant (i.e. 'off').
   *
   * @param user The user to evaluate
   * @param flagKeys The flags to evaluate with the user. If empty, all flags
   * from the flag cache are evaluated.
   * @returns The evaluated variants
   */
  evaluateV2(user2, flagKeys) {
    var _a;
    const flags = this.cache.getAllCached();
    this.logger.debug("[Experiment] evaluate - user:", user2, "flags:", flags);
    const context = (0, user_1.convertUserToEvaluationContext)(user2);
    const sortedFlags = (0, experiment_core_1.topologicalSort)(flags, flagKeys);
    const results = this.evaluation.evaluate(context, sortedFlags);
    void ((_a = this.assignmentService) === null || _a === void 0 ? void 0 : _a.track(new assignment_1.Assignment(user2, results)));
    this.logger.debug("[Experiment] evaluate - variants: ", results);
    return (0, variant_1.evaluationVariantsToVariants)(results);
  }
  /**
   * Locally evaluates flag variants for a user.
   *
   * This function will only evaluate flags for the keys specified in the
   * {@link flagKeys} argument. If {@link flagKeys} is missing, all flags in the
   * {@link FlagConfigCache} will be evaluated.
   *
   * @param user The user to evaluate
   * @param flagKeys The flags to evaluate with the user. If empty, all flags
   * from the flag cache are evaluated.
   * @returns The evaluated variants
   * @deprecated use evaluateV2 instead
   */
  evaluate(user2, flagKeys) {
    return __awaiter(this, void 0, void 0, function* () {
      const results = this.evaluateV2(user2, flagKeys);
      return (0, variant_1.filterDefaultVariants)(results);
    });
  }
  /**
   * Fetch initial flag configurations and start polling for updates.
   *
   * You must call this function to begin polling for flag config updates.
   * The promise returned by this function is resolved when the initial call
   * to fetch the flag configuration completes.
   *
   * Calling this function while the poller is already running does nothing.
   */
  start() {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.poller.start();
    });
  }
  /**
   * Stop polling for flag configurations.
   *
   * Calling this function while the poller is not running will do nothing.
   */
  stop() {
    return this.poller.stop();
  }
}
client.__exports.LocalEvaluationClient = LocalEvaluationClient;
module.exports = client.__exports;
//# sourceMappingURL=client.cjs.map
