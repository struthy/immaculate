"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var EvaluationOperator = {
  IS: "is",
  IS_NOT: "is not",
  CONTAINS: "contains",
  DOES_NOT_CONTAIN: "does not contain",
  LESS_THAN: "less",
  LESS_THAN_EQUALS: "less or equal",
  GREATER_THAN: "greater",
  GREATER_THAN_EQUALS: "greater or equal",
  VERSION_LESS_THAN: "version less",
  VERSION_LESS_THAN_EQUALS: "version less or equal",
  VERSION_GREATER_THAN: "version greater",
  VERSION_GREATER_THAN_EQUALS: "version greater or equal",
  SET_IS: "set is",
  SET_IS_NOT: "set is not",
  SET_CONTAINS: "set contains",
  SET_DOES_NOT_CONTAIN: "set does not contain",
  SET_CONTAINS_ANY: "set contains any",
  SET_DOES_NOT_CONTAIN_ANY: "set does not contain any",
  REGEX_MATCH: "regex match",
  REGEX_DOES_NOT_MATCH: "regex does not match"
};
var stringToUtf8ByteArray = function(str) {
  var out = [];
  var p = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) == 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) == 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return Uint8Array.from(out);
};
var C1_32 = -862048943;
var C2_32 = 461845907;
var R1_32 = 15;
var R2_32 = 13;
var M_32 = 5;
var N_32 = -430675100;
var hash32x86 = function(input, seed) {
  if (seed === void 0) {
    seed = 0;
  }
  var data = stringToUtf8ByteArray(input);
  var length = data.length;
  var nBlocks = length >> 2;
  var hash = seed;
  for (var i = 0; i < nBlocks; i++) {
    var index_1 = i << 2;
    var k = readIntLe(data, index_1);
    hash = mix32(k, hash);
  }
  var index = nBlocks << 2;
  var k1 = 0;
  switch (length - index) {
    case 3:
      k1 ^= data[index + 2] << 16;
      k1 ^= data[index + 1] << 8;
      k1 ^= data[index];
      k1 = Math.imul(k1, C1_32);
      k1 = rotateLeft(k1, R1_32);
      k1 = Math.imul(k1, C2_32);
      hash ^= k1;
      break;
    case 2:
      k1 ^= data[index + 1] << 8;
      k1 ^= data[index];
      k1 = Math.imul(k1, C1_32);
      k1 = rotateLeft(k1, R1_32);
      k1 = Math.imul(k1, C2_32);
      hash ^= k1;
      break;
    case 1:
      k1 ^= data[index];
      k1 = Math.imul(k1, C1_32);
      k1 = rotateLeft(k1, R1_32);
      k1 = Math.imul(k1, C2_32);
      hash ^= k1;
      break;
  }
  hash ^= length;
  return fmix32(hash) >>> 0;
};
var mix32 = function(k, hash) {
  var kResult = k;
  var hashResult = hash;
  kResult = Math.imul(kResult, C1_32);
  kResult = rotateLeft(kResult, R1_32);
  kResult = Math.imul(kResult, C2_32);
  hashResult ^= kResult;
  hashResult = rotateLeft(hashResult, R2_32);
  hashResult = Math.imul(hashResult, M_32);
  return hashResult + N_32 | 0;
};
var fmix32 = function(hash) {
  var hashResult = hash;
  hashResult ^= hashResult >>> 16;
  hashResult = Math.imul(hashResult, -2048144789);
  hashResult ^= hashResult >>> 13;
  hashResult = Math.imul(hashResult, -1028477387);
  hashResult ^= hashResult >>> 16;
  return hashResult;
};
var rotateLeft = function(x, n, width) {
  if (width === void 0) {
    width = 32;
  }
  if (n > width)
    n = n % width;
  var mask = 4294967295 << width - n >>> 0;
  var r = (x & mask) >>> 0 >>> width - n >>> 0;
  return (x << n | r) >>> 0;
};
var readIntLe = function(data, index) {
  if (index === void 0) {
    index = 0;
  }
  var n = data[index] << 24 | data[index + 1] << 16 | data[index + 2] << 8 | data[index + 3];
  return reverseBytes(n);
};
var reverseBytes = function(n) {
  return (n & -16777216) >>> 24 | (n & 16711680) >>> 8 | (n & 65280) << 8 | (n & 255) << 24;
};
var select = function(selectable, selector) {
  var e_1, _a;
  if (!selector || selector.length === 0) {
    return void 0;
  }
  try {
    for (var selector_1 = __values(selector), selector_1_1 = selector_1.next(); !selector_1_1.done; selector_1_1 = selector_1.next()) {
      var selectorElement = selector_1_1.value;
      if (!selectorElement || !selectable || typeof selectable !== "object") {
        return void 0;
      }
      selectable = selectable[selectorElement];
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (selector_1_1 && !selector_1_1.done && (_a = selector_1.return))
        _a.call(selector_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  if (!selectable) {
    return void 0;
  } else {
    return selectable;
  }
};
var MAJOR_MINOR_REGEX = "(\\d+)\\.(\\d+)";
var PATCH_REGEX = "(\\d+)";
var PRERELEASE_REGEX = "(-(([-\\w]+\\.?)*))?";
var VERSION_PATTERN = "^".concat(MAJOR_MINOR_REGEX, "(\\.").concat(PATCH_REGEX).concat(PRERELEASE_REGEX, ")?$");
var SemanticVersion = (
  /** @class */
  function() {
    function SemanticVersion2(major, minor, patch, preRelease) {
      if (preRelease === void 0) {
        preRelease = void 0;
      }
      this.major = major;
      this.minor = minor;
      this.patch = patch;
      this.preRelease = preRelease;
    }
    SemanticVersion2.parse = function(version2) {
      if (!version2) {
        return void 0;
      }
      var matchGroup = new RegExp(VERSION_PATTERN).exec(version2);
      if (!matchGroup) {
        return void 0;
      }
      var major = Number(matchGroup[1]);
      var minor = Number(matchGroup[2]);
      if (isNaN(major) || isNaN(minor)) {
        return void 0;
      }
      var patch = Number(matchGroup[4]) || 0;
      var preRelease = matchGroup[5] || void 0;
      return new SemanticVersion2(major, minor, patch, preRelease);
    };
    SemanticVersion2.prototype.compareTo = function(other) {
      if (this.major > other.major)
        return 1;
      if (this.major < other.major)
        return -1;
      if (this.minor > other.minor)
        return 1;
      if (this.minor < other.minor)
        return -1;
      if (this.patch > other.patch)
        return 1;
      if (this.patch < other.patch)
        return -1;
      if (this.preRelease && !other.preRelease)
        return -1;
      if (!this.preRelease && other.preRelease)
        return 1;
      if (this.preRelease && other.preRelease) {
        if (this.preRelease > other.preRelease)
          return 1;
        if (this.preRelease < other.preRelease)
          return -1;
        return 0;
      }
      return 0;
    };
    return SemanticVersion2;
  }()
);
var EvaluationEngine = (
  /** @class */
  function() {
    function EvaluationEngine2() {
    }
    EvaluationEngine2.prototype.evaluate = function(context, flags) {
      var e_1, _a;
      var results = {};
      var target = {
        context,
        result: results
      };
      try {
        for (var flags_1 = __values(flags), flags_1_1 = flags_1.next(); !flags_1_1.done; flags_1_1 = flags_1.next()) {
          var flag = flags_1_1.value;
          var variant = this.evaluateFlag(target, flag);
          if (variant) {
            results[flag.key] = variant;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (flags_1_1 && !flags_1_1.done && (_a = flags_1.return))
            _a.call(flags_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return results;
    };
    EvaluationEngine2.prototype.evaluateFlag = function(target, flag) {
      var e_2, _a;
      var result;
      try {
        for (var _b = __values(flag.segments), _c = _b.next(); !_c.done; _c = _b.next()) {
          var segment = _c.value;
          result = this.evaluateSegment(target, flag, segment);
          if (result) {
            var metadata = __assign(__assign(__assign({}, flag.metadata), segment.metadata), result.metadata);
            result = __assign(__assign({}, result), { metadata });
            break;
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return result;
    };
    EvaluationEngine2.prototype.evaluateSegment = function(target, flag, segment) {
      var e_3, _a, e_4, _b;
      if (!segment.conditions) {
        var variantKey = this.bucket(target, segment);
        if (variantKey !== void 0) {
          return flag.variants[variantKey];
        } else {
          return void 0;
        }
      }
      try {
        for (var _c = __values(segment.conditions), _d = _c.next(); !_d.done; _d = _c.next()) {
          var conditions = _d.value;
          var match = true;
          try {
            for (var conditions_1 = (e_4 = void 0, __values(conditions)), conditions_1_1 = conditions_1.next(); !conditions_1_1.done; conditions_1_1 = conditions_1.next()) {
              var condition = conditions_1_1.value;
              match = this.matchCondition(target, condition);
              if (!match) {
                break;
              }
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (conditions_1_1 && !conditions_1_1.done && (_b = conditions_1.return))
                _b.call(conditions_1);
            } finally {
              if (e_4)
                throw e_4.error;
            }
          }
          if (match) {
            var variantKey = this.bucket(target, segment);
            if (variantKey !== void 0) {
              return flag.variants[variantKey];
            } else {
              return void 0;
            }
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return void 0;
    };
    EvaluationEngine2.prototype.matchCondition = function(target, condition) {
      var propValue = select(target, condition.selector);
      if (!propValue) {
        return this.matchNull(condition.op, condition.values);
      } else if (this.isSetOperator(condition.op)) {
        var propValueStringList = this.coerceStringArray(propValue);
        if (!propValueStringList) {
          return false;
        }
        return this.matchSet(propValueStringList, condition.op, condition.values);
      } else {
        var propValueString = this.coerceString(propValue);
        if (propValueString !== void 0) {
          return this.matchString(propValueString, condition.op, condition.values);
        } else {
          return false;
        }
      }
    };
    EvaluationEngine2.prototype.getHash = function(key) {
      return hash32x86(key);
    };
    EvaluationEngine2.prototype.bucket = function(target, segment) {
      var e_5, _a, e_6, _b;
      if (!segment.bucket) {
        return segment.variant;
      }
      var bucketingValue = this.coerceString(select(target, segment.bucket.selector));
      if (!bucketingValue || bucketingValue.length === 0) {
        return segment.variant;
      }
      var keyToHash = "".concat(segment.bucket.salt, "/").concat(bucketingValue);
      var hash = this.getHash(keyToHash);
      var allocationValue = hash % 100;
      var distributionValue = Math.floor(hash / 100);
      try {
        for (var _c = __values(segment.bucket.allocations), _d = _c.next(); !_d.done; _d = _c.next()) {
          var allocation = _d.value;
          var allocationStart = allocation.range[0];
          var allocationEnd = allocation.range[1];
          if (allocationValue >= allocationStart && allocationValue < allocationEnd) {
            try {
              for (var _e = (e_6 = void 0, __values(allocation.distributions)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var distribution = _f.value;
                var distributionStart = distribution.range[0];
                var distributionEnd = distribution.range[1];
                if (distributionValue >= distributionStart && distributionValue < distributionEnd) {
                  return distribution.variant;
                }
              }
            } catch (e_6_1) {
              e_6 = { error: e_6_1 };
            } finally {
              try {
                if (_f && !_f.done && (_b = _e.return))
                  _b.call(_e);
              } finally {
                if (e_6)
                  throw e_6.error;
              }
            }
          }
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      return segment.variant;
    };
    EvaluationEngine2.prototype.matchNull = function(op, filterValues) {
      var containsNone = this.containsNone(filterValues);
      switch (op) {
        case EvaluationOperator.IS:
        case EvaluationOperator.CONTAINS:
        case EvaluationOperator.LESS_THAN:
        case EvaluationOperator.LESS_THAN_EQUALS:
        case EvaluationOperator.GREATER_THAN:
        case EvaluationOperator.GREATER_THAN_EQUALS:
        case EvaluationOperator.VERSION_LESS_THAN:
        case EvaluationOperator.VERSION_LESS_THAN_EQUALS:
        case EvaluationOperator.VERSION_GREATER_THAN:
        case EvaluationOperator.VERSION_GREATER_THAN_EQUALS:
        case EvaluationOperator.SET_IS:
        case EvaluationOperator.SET_CONTAINS:
        case EvaluationOperator.SET_CONTAINS_ANY:
          return containsNone;
        case EvaluationOperator.IS_NOT:
        case EvaluationOperator.DOES_NOT_CONTAIN:
        case EvaluationOperator.SET_DOES_NOT_CONTAIN:
        case EvaluationOperator.SET_DOES_NOT_CONTAIN_ANY:
          return !containsNone;
        default:
          return false;
      }
    };
    EvaluationEngine2.prototype.matchSet = function(propValues, op, filterValues) {
      switch (op) {
        case EvaluationOperator.SET_IS:
          return this.setEquals(propValues, filterValues);
        case EvaluationOperator.SET_IS_NOT:
          return !this.setEquals(propValues, filterValues);
        case EvaluationOperator.SET_CONTAINS:
          return this.matchesSetContainsAll(propValues, filterValues);
        case EvaluationOperator.SET_DOES_NOT_CONTAIN:
          return !this.matchesSetContainsAll(propValues, filterValues);
        case EvaluationOperator.SET_CONTAINS_ANY:
          return this.matchesSetContainsAny(propValues, filterValues);
        case EvaluationOperator.SET_DOES_NOT_CONTAIN_ANY:
          return !this.matchesSetContainsAny(propValues, filterValues);
        default:
          return false;
      }
    };
    EvaluationEngine2.prototype.matchString = function(propValue, op, filterValues) {
      var _this = this;
      switch (op) {
        case EvaluationOperator.IS:
          return this.matchesIs(propValue, filterValues);
        case EvaluationOperator.IS_NOT:
          return !this.matchesIs(propValue, filterValues);
        case EvaluationOperator.CONTAINS:
          return this.matchesContains(propValue, filterValues);
        case EvaluationOperator.DOES_NOT_CONTAIN:
          return !this.matchesContains(propValue, filterValues);
        case EvaluationOperator.LESS_THAN:
        case EvaluationOperator.LESS_THAN_EQUALS:
        case EvaluationOperator.GREATER_THAN:
        case EvaluationOperator.GREATER_THAN_EQUALS:
          return this.matchesComparable(propValue, op, filterValues, function(value) {
            return _this.parseNumber(value);
          }, this.comparator);
        case EvaluationOperator.VERSION_LESS_THAN:
        case EvaluationOperator.VERSION_LESS_THAN_EQUALS:
        case EvaluationOperator.VERSION_GREATER_THAN:
        case EvaluationOperator.VERSION_GREATER_THAN_EQUALS:
          return this.matchesComparable(propValue, op, filterValues, function(value) {
            return SemanticVersion.parse(value);
          }, this.versionComparator);
        case EvaluationOperator.REGEX_MATCH:
          return this.matchesRegex(propValue, filterValues);
        case EvaluationOperator.REGEX_DOES_NOT_MATCH:
          return !this.matchesRegex(propValue, filterValues);
        default:
          return false;
      }
    };
    EvaluationEngine2.prototype.matchesIs = function(propValue, filterValues) {
      if (this.containsBooleans(filterValues)) {
        var lower_1 = propValue.toLowerCase();
        if (lower_1 === "true" || lower_1 === "false") {
          return filterValues.some(function(value) {
            return value.toLowerCase() === lower_1;
          });
        }
      }
      return filterValues.some(function(value) {
        return propValue === value;
      });
    };
    EvaluationEngine2.prototype.matchesContains = function(propValue, filterValues) {
      var e_7, _a;
      try {
        for (var filterValues_1 = __values(filterValues), filterValues_1_1 = filterValues_1.next(); !filterValues_1_1.done; filterValues_1_1 = filterValues_1.next()) {
          var filterValue = filterValues_1_1.value;
          if (propValue.toLowerCase().includes(filterValue.toLowerCase())) {
            return true;
          }
        }
      } catch (e_7_1) {
        e_7 = { error: e_7_1 };
      } finally {
        try {
          if (filterValues_1_1 && !filterValues_1_1.done && (_a = filterValues_1.return))
            _a.call(filterValues_1);
        } finally {
          if (e_7)
            throw e_7.error;
        }
      }
      return false;
    };
    EvaluationEngine2.prototype.matchesComparable = function(propValue, op, filterValues, typeTransformer, typeComparator) {
      var _this = this;
      var propValueTransformed = typeTransformer(propValue);
      var filterValuesTransformed = filterValues.map(function(filterValue) {
        return typeTransformer(filterValue);
      }).filter(function(filterValue) {
        return filterValue !== void 0;
      });
      if (propValueTransformed === void 0 || filterValuesTransformed.length === 0) {
        return filterValues.some(function(filterValue) {
          return _this.comparator(propValue, op, filterValue);
        });
      } else {
        return filterValuesTransformed.some(function(filterValueTransformed) {
          return typeComparator(propValueTransformed, op, filterValueTransformed);
        });
      }
    };
    EvaluationEngine2.prototype.comparator = function(propValue, op, filterValue) {
      switch (op) {
        case EvaluationOperator.LESS_THAN:
        case EvaluationOperator.VERSION_LESS_THAN:
          return propValue < filterValue;
        case EvaluationOperator.LESS_THAN_EQUALS:
        case EvaluationOperator.VERSION_LESS_THAN_EQUALS:
          return propValue <= filterValue;
        case EvaluationOperator.GREATER_THAN:
        case EvaluationOperator.VERSION_GREATER_THAN:
          return propValue > filterValue;
        case EvaluationOperator.GREATER_THAN_EQUALS:
        case EvaluationOperator.VERSION_GREATER_THAN_EQUALS:
          return propValue >= filterValue;
        default:
          return false;
      }
    };
    EvaluationEngine2.prototype.versionComparator = function(propValue, op, filterValue) {
      var compareTo = propValue.compareTo(filterValue);
      switch (op) {
        case EvaluationOperator.LESS_THAN:
        case EvaluationOperator.VERSION_LESS_THAN:
          return compareTo < 0;
        case EvaluationOperator.LESS_THAN_EQUALS:
        case EvaluationOperator.VERSION_LESS_THAN_EQUALS:
          return compareTo <= 0;
        case EvaluationOperator.GREATER_THAN:
        case EvaluationOperator.VERSION_GREATER_THAN:
          return compareTo > 0;
        case EvaluationOperator.GREATER_THAN_EQUALS:
        case EvaluationOperator.VERSION_GREATER_THAN_EQUALS:
          return compareTo >= 0;
        default:
          return false;
      }
    };
    EvaluationEngine2.prototype.matchesRegex = function(propValue, filterValues) {
      return filterValues.some(function(filterValue) {
        return Boolean(new RegExp(filterValue).exec(propValue));
      });
    };
    EvaluationEngine2.prototype.containsNone = function(filterValues) {
      return filterValues.some(function(filterValue) {
        return filterValue === "(none)";
      });
    };
    EvaluationEngine2.prototype.containsBooleans = function(filterValues) {
      return filterValues.some(function(filterValue) {
        switch (filterValue.toLowerCase()) {
          case "true":
          case "false":
            return true;
          default:
            return false;
        }
      });
    };
    EvaluationEngine2.prototype.parseNumber = function(value) {
      var _a;
      return (_a = Number(value)) !== null && _a !== void 0 ? _a : void 0;
    };
    EvaluationEngine2.prototype.coerceString = function(value) {
      if (!value) {
        return void 0;
      }
      if (typeof value === "object") {
        return JSON.stringify(value);
      }
      return String(value);
    };
    EvaluationEngine2.prototype.coerceStringArray = function(value) {
      var _this = this;
      if (Array.isArray(value)) {
        var anyArray = value;
        return anyArray.map(function(e) {
          return _this.coerceString(e);
        }).filter(Boolean);
      }
      var stringValue = String(value);
      try {
        var parsedValue = JSON.parse(stringValue);
        if (Array.isArray(parsedValue)) {
          var anyArray = value;
          return anyArray.map(function(e) {
            return _this.coerceString(e);
          }).filter(Boolean);
        } else {
          return void 0;
        }
      } catch (_a) {
        return void 0;
      }
    };
    EvaluationEngine2.prototype.isSetOperator = function(op) {
      switch (op) {
        case EvaluationOperator.SET_IS:
        case EvaluationOperator.SET_IS_NOT:
        case EvaluationOperator.SET_CONTAINS:
        case EvaluationOperator.SET_DOES_NOT_CONTAIN:
        case EvaluationOperator.SET_CONTAINS_ANY:
        case EvaluationOperator.SET_DOES_NOT_CONTAIN_ANY:
          return true;
        default:
          return false;
      }
    };
    EvaluationEngine2.prototype.setEquals = function(xa, ya) {
      var xs = new Set(xa);
      var ys = new Set(ya);
      return xs.size === ys.size && __spreadArray([], __read(ys), false).every(function(y) {
        return xs.has(y);
      });
    };
    EvaluationEngine2.prototype.matchesSetContainsAll = function(propValues, filterValues) {
      var e_8, _a;
      if (propValues.length < filterValues.length) {
        return false;
      }
      try {
        for (var filterValues_2 = __values(filterValues), filterValues_2_1 = filterValues_2.next(); !filterValues_2_1.done; filterValues_2_1 = filterValues_2.next()) {
          var filterValue = filterValues_2_1.value;
          if (!this.matchesIs(filterValue, propValues)) {
            return false;
          }
        }
      } catch (e_8_1) {
        e_8 = { error: e_8_1 };
      } finally {
        try {
          if (filterValues_2_1 && !filterValues_2_1.done && (_a = filterValues_2.return))
            _a.call(filterValues_2);
        } finally {
          if (e_8)
            throw e_8.error;
        }
      }
      return true;
    };
    EvaluationEngine2.prototype.matchesSetContainsAny = function(propValues, filterValues) {
      var e_9, _a;
      try {
        for (var filterValues_3 = __values(filterValues), filterValues_3_1 = filterValues_3.next(); !filterValues_3_1.done; filterValues_3_1 = filterValues_3.next()) {
          var filterValue = filterValues_3_1.value;
          if (this.matchesIs(filterValue, propValues)) {
            return true;
          }
        }
      } catch (e_9_1) {
        e_9 = { error: e_9_1 };
      } finally {
        try {
          if (filterValues_3_1 && !filterValues_3_1.done && (_a = filterValues_3.return))
            _a.call(filterValues_3);
        } finally {
          if (e_9)
            throw e_9.error;
        }
      }
      return false;
    };
    return EvaluationEngine2;
  }()
);
var topologicalSort = function(flags, flagKeys) {
  var e_1, _a;
  var available = __assign({}, flags);
  var result = [];
  var startingKeys = flagKeys || Object.keys(available);
  try {
    for (var startingKeys_1 = __values(startingKeys), startingKeys_1_1 = startingKeys_1.next(); !startingKeys_1_1.done; startingKeys_1_1 = startingKeys_1.next()) {
      var flagKey = startingKeys_1_1.value;
      var traversal = parentTraversal(flagKey, available);
      if (traversal) {
        result.push.apply(result, __spreadArray([], __read(traversal), false));
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (startingKeys_1_1 && !startingKeys_1_1.done && (_a = startingKeys_1.return))
        _a.call(startingKeys_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return result;
};
var parentTraversal = function(flagKey, available, path) {
  var e_2, _a;
  if (path === void 0) {
    path = [];
  }
  var flag = available[flagKey];
  if (!flag) {
    return void 0;
  } else if (!flag.dependencies || flag.dependencies.length === 0) {
    delete available[flag.key];
    return [flag];
  }
  path.push(flag.key);
  var result = [];
  var _loop_1 = function(parentKey2) {
    if (path.some(function(p) {
      return p === parentKey2;
    })) {
      throw Error("Detected a cycle between flags ".concat(path));
    }
    var traversal = parentTraversal(parentKey2, available, path);
    if (traversal) {
      result.push.apply(result, __spreadArray([], __read(traversal), false));
    }
  };
  try {
    for (var _b = __values(flag.dependencies), _c = _b.next(); !_c.done; _c = _b.next()) {
      var parentKey = _c.value;
      _loop_1(parentKey);
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  result.push(flag);
  path.pop();
  delete available[flag.key];
  return result;
};
const version = "3.7.5";
const VERSION = version;
const _hasatob = typeof atob === "function";
const _hasbtoa = typeof btoa === "function";
const _hasBuffer = typeof Buffer === "function";
const _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
const _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
const _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
const btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
const _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
const _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
const cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
const utob = (u) => u.replace(re_utob, cb_utob);
const _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
const encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
const encodeURI = (src) => encode(src, true);
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
const btou = (b) => b.replace(re_btou, cb_btou);
const atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
const _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
const _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
const toUint8Array = (a) => _toUint8Array(_unURI(a));
const _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
const decode = (src) => _decode(_unURI(src));
const isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
const _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
const extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
const extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
const extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
const gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI,
  encodeURL: encodeURI,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};
var SdkEvaluationApi = (
  /** @class */
  function() {
    function SdkEvaluationApi2(deploymentKey, serverUrl, httpClient) {
      this.deploymentKey = deploymentKey;
      this.serverUrl = serverUrl;
      this.httpClient = httpClient;
    }
    SdkEvaluationApi2.prototype.getVariants = function(user, options) {
      return __awaiter(this, void 0, void 0, function() {
        var userJsonBase64, headers, response;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              userJsonBase64 = gBase64.encodeURL(JSON.stringify(user));
              headers = {
                Authorization: "Api-Key ".concat(this.deploymentKey),
                "X-Amp-Exp-User": userJsonBase64
              };
              if (options === null || options === void 0 ? void 0 : options.flagKeys) {
                headers["X-Amp-Exp-Flag-Keys"] = gBase64.encodeURL(JSON.stringify(options.flagKeys));
              }
              if (options === null || options === void 0 ? void 0 : options.trackingOption) {
                headers["X-Amp-Exp-Track"] = options.trackingOption;
              }
              return [4, this.httpClient.request({
                requestUrl: "".concat(this.serverUrl, "/sdk/v2/vardata?v=0"),
                method: "GET",
                headers,
                timeoutMillis: options === null || options === void 0 ? void 0 : options.timeoutMillis
              })];
            case 1:
              response = _a.sent();
              if (response.status != 200) {
                throw Error("Fetch error response: status=".concat(response.status));
              }
              return [2, JSON.parse(response.body)];
          }
        });
      });
    };
    return SdkEvaluationApi2;
  }()
);
var SdkFlagApi = (
  /** @class */
  function() {
    function SdkFlagApi2(deploymentKey, serverUrl, httpClient) {
      this.deploymentKey = deploymentKey;
      this.serverUrl = serverUrl;
      this.httpClient = httpClient;
    }
    SdkFlagApi2.prototype.getFlags = function(options) {
      return __awaiter(this, void 0, void 0, function() {
        var headers, response, flagsArray;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              headers = {
                Authorization: "Api-Key ".concat(this.deploymentKey)
              };
              if ((options === null || options === void 0 ? void 0 : options.libraryName) && (options === null || options === void 0 ? void 0 : options.libraryVersion)) {
                headers["X-Amp-Exp-Library"] = "".concat(options.libraryName, "/").concat(options.libraryVersion);
              }
              return [4, this.httpClient.request({
                requestUrl: "".concat(this.serverUrl, "/sdk/v2/flags"),
                method: "GET",
                headers,
                timeoutMillis: options === null || options === void 0 ? void 0 : options.timeoutMillis
              })];
            case 1:
              response = _a.sent();
              if (response.status != 200) {
                throw Error("Flags error response: status=".concat(response.status));
              }
              flagsArray = JSON.parse(response.body);
              return [2, flagsArray.reduce(function(map, flag) {
                map[flag.key] = flag;
                return map;
              }, {})];
          }
        });
      });
    };
    return SdkFlagApi2;
  }()
);
var safeGlobal = typeof globalThis !== "undefined" ? globalThis : global || self;
var Poller = (
  /** @class */
  function() {
    function Poller2(action, ms) {
      this.poller = void 0;
      this.action = action;
      this.ms = ms;
    }
    Poller2.prototype.start = function() {
      if (this.poller) {
        return;
      }
      this.poller = safeGlobal.setInterval(this.action, this.ms);
      void this.action();
    };
    Poller2.prototype.stop = function() {
      if (!this.poller) {
        return;
      }
      safeGlobal.clearInterval(this.poller);
      this.poller = void 0;
    };
    return Poller2;
  }()
);
exports.EvaluationEngine = EvaluationEngine;
exports.EvaluationOperator = EvaluationOperator;
exports.Poller = Poller;
exports.SdkEvaluationApi = SdkEvaluationApi;
exports.SdkFlagApi = SdkFlagApi;
exports.safeGlobal = safeGlobal;
exports.topologicalSort = topologicalSort;
//# sourceMappingURL=experiment-core.esm.cjs.map
