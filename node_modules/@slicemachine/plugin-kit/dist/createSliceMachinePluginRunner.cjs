"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const path = require("node:path");
const node_module = require("node:module");
const defu = require("defu");
const createSliceMachineContext = require("./createSliceMachineContext.cjs");
const createSliceMachineHookSystem = require("./createSliceMachineHookSystem.cjs");
const createSliceMachineActions = require("./createSliceMachineActions.cjs");
const createSliceMachineHelpers = require("./createSliceMachineHelpers.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
const REQUIRED_ADAPTER_HOOKS = [
  "slice:create",
  "slice:read",
  "slice:rename",
  "slice:delete",
  "slice:update",
  "slice:asset:update",
  "slice:asset:read",
  "slice:asset:delete",
  "slice-library:read",
  "custom-type:create",
  "custom-type:read",
  "custom-type:rename",
  "custom-type:delete",
  "custom-type:update",
  "custom-type:asset:update",
  "custom-type:asset:read",
  "custom-type:asset:delete",
  "custom-type-library:read"
];
const ADAPTER_ONLY_HOOKS = [
  "slice:read",
  "slice:asset:read",
  "slice-library:read",
  "custom-type:read",
  "custom-type:asset:read",
  "custom-type-library:read",
  "project:environment:read"
];
class SliceMachinePluginRunner {
  constructor({ project, hookSystem, nativePlugins = {} }) {
    __publicField(this, "_project");
    __publicField(this, "_hookSystem");
    __publicField(this, "_nativePlugins");
    /**
     * Slice Machine actions provided to hooks.
     *
     * IMPORTANT: Prefer creating your own abstraction over using `rawActions`
     * directly to prevent code breakage if this internal API changes.
     *
     * @internal
     */
    __publicField(this, "rawActions");
    /**
     * Slice Machine helpers provided to hooks.
     *
     * IMPORTANT: Prefer creating your own abstraction over using `rawHelpers`
     * directly to prevent code breakage if this internal API changes.
     *
     * @internal
     */
    __publicField(this, "rawHelpers");
    // Methods forwarded to the plugin runner's hook system.
    __publicField(this, "callHook");
    __publicField(this, "hooksForOwner");
    __publicField(this, "hooksForType");
    __publicField(this, "createScope");
    this._project = project;
    this._hookSystem = hookSystem;
    this._nativePlugins = nativePlugins;
    this.rawActions = createSliceMachineActions.createSliceMachineActions(this._project, this._hookSystem);
    this.rawHelpers = createSliceMachineHelpers.createSliceMachineHelpers(this._project);
    this.callHook = this._hookSystem.callHook.bind(this._hookSystem);
    this.hooksForOwner = this._hookSystem.hooksForOwner.bind(this._hookSystem);
    this.hooksForType = this._hookSystem.hooksForType.bind(this._hookSystem);
    this.createScope = this._hookSystem.createScope.bind(this._hookSystem);
  }
  async _loadPlugin(pluginRegistration) {
    const { resolve, options = {} } = typeof pluginRegistration === "object" && "resolve" in pluginRegistration ? pluginRegistration : { resolve: pluginRegistration };
    let plugin = void 0;
    if (typeof resolve === "string") {
      try {
        const raw = await node_module.createRequire(path__namespace.resolve(this._project.root, "noop.js"))(resolve);
        plugin = raw.default || raw;
      } catch (error) {
      }
      if (!plugin) {
        plugin = this._nativePlugins[resolve];
      }
      if (!plugin) {
        throw new Error(`Could not resolve plugin \`${resolve}\`. Check that it has been installed.`);
      }
    } else {
      plugin = resolve;
    }
    if (!plugin) {
      throw new Error(`Could not load plugin: \`${resolve}\``);
    }
    const mergedOptions = defu.defu(options, plugin.defaultOptions || {});
    return {
      ...plugin,
      resolve,
      options: mergedOptions
    };
  }
  async _setupPlugin(plugin, as) {
    const context = createSliceMachineContext.createSliceMachineContext({
      actions: this.rawActions,
      helpers: this.rawHelpers,
      project: this._project,
      plugin
    });
    const hookSystemScope = this._hookSystem.createScope(plugin.meta.name, [context]);
    const hook = as === "adapter" ? hookSystemScope.hook : (type, hook2, ...args) => {
      if (ADAPTER_ONLY_HOOKS.includes(type)) {
        return;
      }
      return hookSystemScope.hook(type, hook2, ...args);
    };
    try {
      await plugin.setup({
        ...context,
        hook,
        unhook: hookSystemScope.unhook
      });
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Plugin \`${plugin.meta.name}\` errored during setup: ${error.message}`, { cause: error });
      } else {
        throw new Error(`Plugin \`${plugin.meta.name}\` errored during setup: ${error}`);
      }
    }
  }
  _validateAdapter(adapter) {
    const hooks = this._hookSystem.hooksForOwner(adapter.meta.name);
    const hookTypes = hooks.map((hook) => hook.meta.type);
    const missingHooks = REQUIRED_ADAPTER_HOOKS.filter((requiredHookType) => !hookTypes.includes(requiredHookType));
    if (missingHooks.length) {
      throw new Error(`Adapter \`${adapter.meta.name}\` is missing hooks: \`${missingHooks.join("`, `")}\``);
    }
  }
  async init() {
    const [adapter, ...plugins] = await Promise.all([
      this._project.config.adapter,
      ...this._project.config.plugins ?? []
    ].map((pluginRegistration) => this._loadPlugin(pluginRegistration)));
    await Promise.all([
      this._setupPlugin(adapter, "adapter"),
      ...plugins.map((plugin) => this._setupPlugin(plugin, "plugin"))
    ]);
    this._validateAdapter(adapter);
  }
}
const createSliceMachinePluginRunner = ({ project, nativePlugins }) => {
  const hookSystem = createSliceMachineHookSystem.createSliceMachineHookSystem();
  return new SliceMachinePluginRunner({
    project,
    hookSystem,
    nativePlugins
  });
};
exports.ADAPTER_ONLY_HOOKS = ADAPTER_ONLY_HOOKS;
exports.REQUIRED_ADAPTER_HOOKS = REQUIRED_ADAPTER_HOOKS;
exports.SliceMachinePluginRunner = SliceMachinePluginRunner;
exports.createSliceMachinePluginRunner = createSliceMachinePluginRunner;
//# sourceMappingURL=createSliceMachinePluginRunner.cjs.map
