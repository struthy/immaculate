{"version":3,"file":"readCustomTypeLibrary.cjs","sources":["../../../src/fs/readCustomTypeLibrary.ts"],"sourcesContent":["import * as path from \"node:path\";\n\nimport { checkPathExists } from \"./lib/checkPathExists\";\nimport { isCustomTypeModel } from \"./lib/isCustomTypeModel\";\nimport { readJSONFile } from \"./lib/readJSONFile\";\nimport * as fs from \"./lib/fsLimit\";\n\nimport { CUSTOM_TYPE_MODEL_FILENAME } from \"./constants\";\nimport {\n\tbuildCustomTypeLibraryDirectoryPath,\n\tBuildCustomTypeLibraryDirectoryPathArgs,\n} from \"./buildCustomTypeLibraryDirectoryPath\";\n\nexport type ReadCustomTypeLibraryArgs = BuildCustomTypeLibraryDirectoryPathArgs;\n\nexport type ReadCustomTypeLibraryReturnType = {\n\tids: string[];\n};\n\nexport const readCustomTypeLibrary = async (\n\targs: ReadCustomTypeLibraryArgs,\n): Promise<ReadCustomTypeLibraryReturnType> => {\n\tconst libraryDir = buildCustomTypeLibraryDirectoryPath({\n\t\tabsolute: true,\n\t\thelpers: args.helpers,\n\t});\n\n\tif (!(await checkPathExists(libraryDir))) {\n\t\treturn {\n\t\t\tids: [],\n\t\t};\n\t}\n\n\tconst childDirs = await fs.readdir(libraryDir, { withFileTypes: true });\n\n\t/**\n\t * Paths to models that could not be read due to invalid JSON.\n\t */\n\tconst unreadableModelPaths: string[] = [];\n\n\tconst ids: string[] = [];\n\tawait Promise.all(\n\t\tchildDirs.map(async (childDir) => {\n\t\t\tif (childDir.isDirectory()) {\n\t\t\t\tconst childDirContents = await fs.readdir(\n\t\t\t\t\tpath.join(libraryDir, childDir.name),\n\t\t\t\t\t{\n\t\t\t\t\t\twithFileTypes: true,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tconst isCustomTypeDir = childDirContents.some((entry) => {\n\t\t\t\t\treturn entry.isFile() && entry.name === CUSTOM_TYPE_MODEL_FILENAME;\n\t\t\t\t});\n\n\t\t\t\tif (isCustomTypeDir) {\n\t\t\t\t\tconst modelPath = path.join(\n\t\t\t\t\t\tlibraryDir,\n\t\t\t\t\t\tchildDir.name,\n\t\t\t\t\t\tCUSTOM_TYPE_MODEL_FILENAME,\n\t\t\t\t\t);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst modelContents = await readJSONFile(modelPath);\n\n\t\t\t\t\t\tif (isCustomTypeModel(modelContents)) {\n\t\t\t\t\t\t\tids.push(modelContents.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tunreadableModelPaths.push(modelPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t);\n\n\tif (unreadableModelPaths.length > 0) {\n\t\tconst formattedPaths = unreadableModelPaths.join(\", \");\n\n\t\tthrow new Error(\n\t\t\t`The following custom type models could not be read: [${formattedPaths}]`,\n\t\t);\n\t}\n\n\treturn {\n\t\tids: ids.sort(),\n\t};\n};\n"],"names":["buildCustomTypeLibraryDirectoryPath","checkPathExists","fs.readdir","path","CUSTOM_TYPE_MODEL_FILENAME","readJSONFile","isCustomTypeModel"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAmBa,MAAA,wBAAwB,OACpC,SAC6C;AAC7C,QAAM,aAAaA,oCAAAA,oCAAoC;AAAA,IACtD,UAAU;AAAA,IACV,SAAS,KAAK;AAAA,EAAA,CACd;AAED,MAAI,CAAE,MAAMC,gCAAgB,UAAU,GAAI;AAClC,WAAA;AAAA,MACN,KAAK,CAAE;AAAA,IAAA;AAAA,EAER;AAEK,QAAA,YAAY,MAAMC,gBAAW,YAAY,EAAE,eAAe,MAAM;AAKtE,QAAM,uBAAiC,CAAA;AAEvC,QAAM,MAAgB,CAAA;AACtB,QAAM,QAAQ,IACb,UAAU,IAAI,OAAO,aAAY;AAC5B,QAAA,SAAS,eAAe;AACrB,YAAA,mBAAmB,MAAMA,QAAAA,QAC9BC,gBAAK,KAAK,YAAY,SAAS,IAAI,GACnC;AAAA,QACC,eAAe;AAAA,MAAA,CACf;AAEF,YAAM,kBAAkB,iBAAiB,KAAK,CAAC,UAAS;AACvD,eAAO,MAAM,OAAA,KAAY,MAAM,SAASC,UAAAA;AAAAA,MAAA,CACxC;AAED,UAAI,iBAAiB;AACpB,cAAM,YAAYD,gBAAK,KACtB,YACA,SAAS,MACTC,UAAAA,0BAA0B;AAGvB,YAAA;AACG,gBAAA,gBAAgB,MAAMC,0BAAa,SAAS;AAE9C,cAAAC,kBAAAA,kBAAkB,aAAa,GAAG;AACjC,gBAAA,KAAK,cAAc,EAAE;AAAA,UACzB;AAAA,QAAA,QACA;AACD,+BAAqB,KAAK,SAAS;AAAA,QACnC;AAAA,MACD;AAAA,IACD;AAAA,EACD,CAAA,CAAC;AAGC,MAAA,qBAAqB,SAAS,GAAG;AAC9B,UAAA,iBAAiB,qBAAqB,KAAK,IAAI;AAE/C,UAAA,IAAI,MACT,wDAAwD,iBAAiB;AAAA,EAE1E;AAEM,SAAA;AAAA,IACN,KAAK,IAAI,KAAM;AAAA,EAAA;AAEjB;;"}