{"version":3,"file":"readSliceModel.js","sources":["../../../src/fs/readSliceModel.ts"],"sourcesContent":["import { SharedSlice } from \"@prismicio/types-internal/lib/customtypes\";\nimport * as path from \"node:path\";\n\nimport { SliceMachineHelpers } from \"../createSliceMachineHelpers\";\n\nimport { checkPathExists } from \"./lib/checkPathExists\";\nimport { isSharedSliceModel } from \"./lib/isSharedSliceModel\";\nimport { readJSONFile } from \"./lib/readJSONFile\";\nimport * as fs from \"./lib/fsLimit\";\n\nimport { buildSliceLibraryDirectoryPath } from \"./buildSliceLibraryDirectoryPath\";\nimport { SHARED_SLICE_MODEL_FILENAME } from \"./constants\";\n\nexport type ReadSliceModelArgs = {\n\tlibraryID: string;\n\tsliceID: string;\n\thelpers: SliceMachineHelpers;\n};\n\nexport type ReadSliceModelReturnType = {\n\tmodel: SharedSlice;\n};\n\nexport const readSliceModel = async (\n\targs: ReadSliceModelArgs,\n): Promise<ReadSliceModelReturnType> => {\n\tconst libraryDir = buildSliceLibraryDirectoryPath({\n\t\tlibraryID: args.libraryID,\n\t\tabsolute: true,\n\t\thelpers: args.helpers,\n\t});\n\n\tif (await checkPathExists(libraryDir)) {\n\t\tconst childDirs = await fs.readdir(libraryDir, { withFileTypes: true });\n\n\t\t/**\n\t\t * Paths to models that could not be read due to invalid JSON.\n\t\t */\n\t\tconst unreadableModelPaths: string[] = [];\n\n\t\t// Find the first matching model.\n\t\tconst [model] = (\n\t\t\tawait Promise.all(\n\t\t\t\tchildDirs.map(async (childDir) => {\n\t\t\t\t\tif (childDir.isDirectory()) {\n\t\t\t\t\t\tconst modelPath = path.join(\n\t\t\t\t\t\t\tlibraryDir,\n\t\t\t\t\t\t\tchildDir.name,\n\t\t\t\t\t\t\tSHARED_SLICE_MODEL_FILENAME,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst modelContents = await readJSONFile(modelPath);\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tisSharedSliceModel(modelContents) &&\n\t\t\t\t\t\t\t\tmodelContents.id === args.sliceID\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn modelContents;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tunreadableModelPaths.push(modelPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t)\n\t\t).filter((model): model is NonNullable<typeof model> => Boolean(model));\n\n\t\tif (model) {\n\t\t\treturn {\n\t\t\t\tmodel,\n\t\t\t};\n\t\t} else {\n\t\t\tif (unreadableModelPaths.length > 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Did not find a Slice model with ID \"${args.sliceID}\" in the \"${\n\t\t\t\t\t\targs.libraryID\n\t\t\t\t\t}\" Slice Library. The following Slice models could not be read: [${unreadableModelPaths.join(\n\t\t\t\t\t\t\", \",\n\t\t\t\t\t)}]`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow new Error(\n\t\t`Did not find a Slice model with ID \"${args.sliceID}\" in the \"${args.libraryID}\" Slice Library.`,\n\t);\n};\n"],"names":["fs.readdir","model"],"mappings":";;;;;;;AAuBa,MAAA,iBAAiB,OAC7B,SACsC;AACtC,QAAM,aAAa,+BAA+B;AAAA,IACjD,WAAW,KAAK;AAAA,IAChB,UAAU;AAAA,IACV,SAAS,KAAK;AAAA,EAAA,CACd;AAEG,MAAA,MAAM,gBAAgB,UAAU,GAAG;AAChC,UAAA,YAAY,MAAMA,QAAW,YAAY,EAAE,eAAe,MAAM;AAKtE,UAAM,uBAAiC,CAAA;AAGjC,UAAA,CAAC,KAAK,KACX,MAAM,QAAQ,IACb,UAAU,IAAI,OAAO,aAAY;AAC5B,UAAA,SAAS,eAAe;AAC3B,cAAM,YAAY,KAAK,KACtB,YACA,SAAS,MACT,2BAA2B;AAGxB,YAAA;AACG,gBAAA,gBAAgB,MAAM,aAAa,SAAS;AAElD,cACC,mBAAmB,aAAa,KAChC,cAAc,OAAO,KAAK,SACzB;AACM,mBAAA;AAAA,UACP;AAAA,iBACO;AACR,+BAAqB,KAAK,SAAS;AAAA,QACnC;AAAA,MACD;AAAA,IAAA,CACD,CAAC,GAEF,OAAO,CAACC,WAA8C,QAAQA,MAAK,CAAC;AAEtE,QAAI,OAAO;AACH,aAAA;AAAA,QACN;AAAA,MAAA;AAAA,WAEK;AACF,UAAA,qBAAqB,SAAS,GAAG;AAC9B,cAAA,IAAI,MACT,uCAAuC,KAAK,oBAC3C,KAAK,4EAC6D,qBAAqB,KACvF,IAAI,IACD;AAAA,MAEL;AAAA,IACD;AAAA,EACD;AAED,QAAM,IAAI,MACT,uCAAuC,KAAK,oBAAoB,KAAK,2BAA2B;AAElG;"}