{"version":3,"file":"readSliceLibrary.js","sources":["../../../src/fs/readSliceLibrary.ts"],"sourcesContent":["import * as path from \"node:path\";\n\nimport { checkPathExists } from \"./lib/checkPathExists\";\nimport { isSharedSliceModel } from \"./lib/isSharedSliceModel\";\nimport { readJSONFile } from \"./lib/readJSONFile\";\nimport * as fs from \"./lib/fsLimit\";\n\nimport { SHARED_SLICE_MODEL_FILENAME } from \"./constants\";\nimport {\n\tbuildSliceLibraryDirectoryPath,\n\tBuildSliceLibraryDirectoryPathArgs,\n} from \"./buildSliceLibraryDirectoryPath\";\n\nexport type ReadSliceLibraryArgs = BuildSliceLibraryDirectoryPathArgs;\n\nexport type ReadSliceLibraryReturnType = {\n\tid: string;\n\tsliceIDs: string[];\n};\n\nexport const readSliceLibrary = async (\n\targs: ReadSliceLibraryArgs,\n): Promise<ReadSliceLibraryReturnType> => {\n\tconst libraryDir = buildSliceLibraryDirectoryPath({\n\t\tlibraryID: args.libraryID,\n\t\tabsolute: true,\n\t\thelpers: args.helpers,\n\t});\n\n\tif (!(await checkPathExists(libraryDir))) {\n\t\treturn {\n\t\t\tid: args.libraryID,\n\t\t\tsliceIDs: [],\n\t\t};\n\t}\n\n\tconst childDirs = await fs.readdir(libraryDir, { withFileTypes: true });\n\n\t/**\n\t * Paths to models that could not be read due to invalid JSON.\n\t */\n\tconst unreadableModelPaths: string[] = [];\n\n\tconst sliceIDs: string[] = [];\n\tawait Promise.all(\n\t\tchildDirs.map(async (childDir) => {\n\t\t\tif (childDir.isDirectory()) {\n\t\t\t\tconst childDirContents = await fs.readdir(\n\t\t\t\t\tpath.join(libraryDir, childDir.name),\n\t\t\t\t\t{\n\t\t\t\t\t\twithFileTypes: true,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tconst isSliceDir = childDirContents.some((entry) => {\n\t\t\t\t\treturn entry.isFile() && entry.name === SHARED_SLICE_MODEL_FILENAME;\n\t\t\t\t});\n\n\t\t\t\tif (isSliceDir) {\n\t\t\t\t\tconst modelPath = path.join(\n\t\t\t\t\t\tlibraryDir,\n\t\t\t\t\t\tchildDir.name,\n\t\t\t\t\t\tSHARED_SLICE_MODEL_FILENAME,\n\t\t\t\t\t);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst modelContents = await readJSONFile(modelPath);\n\n\t\t\t\t\t\tif (isSharedSliceModel(modelContents)) {\n\t\t\t\t\t\t\tsliceIDs.push(modelContents.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// JSON could not be read or parsed\n\t\t\t\t\t\tunreadableModelPaths.push(modelPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t);\n\n\tif (unreadableModelPaths.length > 0) {\n\t\tconst formattedPaths = unreadableModelPaths.join(\", \");\n\n\t\tthrow new Error(\n\t\t\t`The following Slice models could not be read: [${formattedPaths}]`,\n\t\t);\n\t}\n\n\treturn {\n\t\tid: args.libraryID,\n\t\tsliceIDs: sliceIDs.sort(),\n\t};\n};\n"],"names":["fs.readdir"],"mappings":";;;;;;;AAoBa,MAAA,mBAAmB,OAC/B,SACwC;AACxC,QAAM,aAAa,+BAA+B;AAAA,IACjD,WAAW,KAAK;AAAA,IAChB,UAAU;AAAA,IACV,SAAS,KAAK;AAAA,EAAA,CACd;AAED,MAAI,CAAE,MAAM,gBAAgB,UAAU,GAAI;AAClC,WAAA;AAAA,MACN,IAAI,KAAK;AAAA,MACT,UAAU,CAAE;AAAA,IAAA;AAAA,EAEb;AAEK,QAAA,YAAY,MAAMA,QAAW,YAAY,EAAE,eAAe,MAAM;AAKtE,QAAM,uBAAiC,CAAA;AAEvC,QAAM,WAAqB,CAAA;AAC3B,QAAM,QAAQ,IACb,UAAU,IAAI,OAAO,aAAY;AAC5B,QAAA,SAAS,eAAe;AACrB,YAAA,mBAAmB,MAAMA,QAC9B,KAAK,KAAK,YAAY,SAAS,IAAI,GACnC;AAAA,QACC,eAAe;AAAA,MAAA,CACf;AAEF,YAAM,aAAa,iBAAiB,KAAK,CAAC,UAAS;AAClD,eAAO,MAAM,OAAA,KAAY,MAAM,SAAS;AAAA,MAAA,CACxC;AAED,UAAI,YAAY;AACf,cAAM,YAAY,KAAK,KACtB,YACA,SAAS,MACT,2BAA2B;AAGxB,YAAA;AACG,gBAAA,gBAAgB,MAAM,aAAa,SAAS;AAE9C,cAAA,mBAAmB,aAAa,GAAG;AAC7B,qBAAA,KAAK,cAAc,EAAE;AAAA,UAC9B;AAAA,QAAA,QACA;AAED,+BAAqB,KAAK,SAAS;AAAA,QACnC;AAAA,MACD;AAAA,IACD;AAAA,EACD,CAAA,CAAC;AAGC,MAAA,qBAAqB,SAAS,GAAG;AAC9B,UAAA,iBAAiB,qBAAqB,KAAK,IAAI;AAE/C,UAAA,IAAI,MACT,kDAAkD,iBAAiB;AAAA,EAEpE;AAEM,SAAA;AAAA,IACN,IAAI,KAAK;AAAA,IACT,UAAU,SAAS,KAAM;AAAA,EAAA;AAE3B;"}