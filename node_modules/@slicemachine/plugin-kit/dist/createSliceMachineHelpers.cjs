"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const path = require("node:path");
const fs = require("node:fs/promises");
const prettier = require("prettier");
const commonTags = require("common-tags");
const decodeSliceMachineConfig = require("./lib/decodeSliceMachineConfig.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
const fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs);
const prettier__namespace = /* @__PURE__ */ _interopNamespaceDefault(prettier);
const createSliceMachineHelpers = (project) => {
  return new SliceMachineHelpers(project);
};
class SliceMachineHelpers {
  constructor(project) {
    /**
     * The Slice Machine project's metadata.
     *
     * @internal
     */
    __publicField(this, "_project");
    __publicField(this, "getProject", async () => {
      const configFilePath = this.joinPathFromRoot("slicemachine.config.json");
      let rawConfig;
      try {
        const contents = await fs__namespace.readFile(configFilePath, "utf8");
        rawConfig = JSON.parse(contents);
      } catch {
      }
      if (!rawConfig) {
        throw new Error("No config found.");
      }
      const { value: sliceMachineConfig, error } = decodeSliceMachineConfig.decodeSliceMachineConfig(rawConfig);
      if (error) {
        throw new Error(`Invalid config. ${error.errors.join(", ")}`);
      }
      return {
        ...this._project,
        config: sliceMachineConfig
      };
    });
    __publicField(this, "updateSliceMachineConfig", async (sliceMachineConfig, options) => {
      const { value: decodedSliceMachineConfig, error } = decodeSliceMachineConfig.decodeSliceMachineConfig(sliceMachineConfig);
      if (error) {
        throw new Error(`Invalid config provided. ${error.errors.join(", ")}`);
      }
      const configFilePath = this.joinPathFromRoot("slicemachine.config.json");
      let content = JSON.stringify(decodedSliceMachineConfig, null, 2);
      if (options == null ? void 0 : options.format) {
        content = await this.format(content, configFilePath);
      }
      await fs__namespace.writeFile(configFilePath, content);
    });
    __publicField(this, "format", async (source, filePath, options) => {
      let formatted = commonTags.stripIndent(source);
      const prettierOptions = await prettier__namespace.resolveConfig(filePath || this._project.root);
      formatted = await prettier__namespace.format(formatted, {
        ...prettierOptions,
        filepath: filePath,
        ...(options == null ? void 0 : options.prettier) ?? {}
      });
      if ((options == null ? void 0 : options.includeNewlineAtEnd) === false) {
        formatted = formatted.replace(/[\r\n]+$/, "");
      }
      return formatted;
    });
    __publicField(this, "joinPathFromRoot", (...paths) => {
      return path__namespace.join(this._project.root, ...paths);
    });
    this._project = project;
  }
}
exports.SliceMachineHelpers = SliceMachineHelpers;
exports.createSliceMachineHelpers = createSliceMachineHelpers;
//# sourceMappingURL=createSliceMachineHelpers.cjs.map
