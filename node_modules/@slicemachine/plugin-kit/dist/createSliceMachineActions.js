var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const createSliceMachineActions = (project, hookSystem) => {
  return new SliceMachineActions(project, hookSystem);
};
class SliceMachineActions {
  constructor(project, hookSystem) {
    /**
     * The Slice Machine project's metadata.
     *
     * @internal
     */
    __publicField(this, "_project");
    /**
     * The actions' hook system used to internally trigger hook calls.
     *
     * @internal
     */
    __publicField(this, "_hookSystem");
    __publicField(this, "readAllSliceModels", async () => {
      const libraryIDs = this._project.config.libraries || [];
      return (await Promise.all(libraryIDs.map(async (libraryID) => {
        const models = await this.readAllSliceModelsForLibrary({
          libraryID
        });
        return models.map((model) => {
          return {
            libraryID,
            ...model
          };
        });
      }))).flat();
    });
    __publicField(this, "readAllSliceModelsForLibrary", async (args) => {
      const { sliceIDs } = await this.readSliceLibrary({
        libraryID: args.libraryID
      });
      return await Promise.all(sliceIDs.map(async (sliceID) => {
        return await this.readSliceModel({
          libraryID: args.libraryID,
          sliceID
        });
      }));
    });
    __publicField(this, "readSliceModel", async (args) => {
      const { data: [model], errors: [cause] } = await this._hookSystem.callHook("slice:read", {
        libraryID: args.libraryID,
        sliceID: args.sliceID
      });
      if (!model) {
        throw new Error(`Slice \`${args.sliceID}\` not found in the \`${args.libraryID}\` library.`, { cause });
      }
      return model;
    });
    __publicField(this, "readSliceLibrary", async (args) => {
      const { data: [library], errors: [cause] } = await this._hookSystem.callHook("slice-library:read", {
        libraryID: args.libraryID
      });
      if (!library) {
        throw new Error(`Slice library \`${args.libraryID}\` not found.`, {
          cause
        });
      }
      return library;
    });
    __publicField(this, "readAllCustomTypeModels", async () => {
      const { ids } = await this.readCustomTypeLibrary();
      return await Promise.all(ids.map(async (id) => {
        return this.readCustomTypeModel({ id });
      }));
    });
    __publicField(this, "readCustomTypeModel", async (args) => {
      const { data: [model], errors: [cause] } = await this._hookSystem.callHook("custom-type:read", {
        id: args.id
      });
      if (!model) {
        throw new Error(`Custom type \`${args.id}\` not found.`, { cause });
      }
      return model;
    });
    __publicField(this, "readCustomTypeLibrary", async () => {
      const { data: [library], errors: [cause] } = await this._hookSystem.callHook("custom-type-library:read", void 0);
      if (!library) {
        throw new Error(`Couldn't read custom type library.`, {
          cause
        });
      }
      return library;
    });
    this._project = project;
    this._hookSystem = hookSystem;
  }
}
export {
  SliceMachineActions,
  createSliceMachineActions
};
//# sourceMappingURL=createSliceMachineActions.js.map
