/**
 * Extends a function arguments with extra ones.
 */
type FnWithExtraArgs<F extends (...args: any[]) => any, TExtraArgs extends any[] = any[]> = (...args: [...args: Parameters<F>, ...extraArgs: TExtraArgs]) => ReturnType<F>;
/**
 * Defines a hook handler.
 */
export type HookFn<TArgs extends any[] = any[], TReturn = any> = (...args: TArgs) => Promise<TReturn> | TReturn;
/**
 * Generic hook metadata.
 */
type HookMeta = Record<string, unknown>;
/**
 * Defines a hook, including its function handler and optional metadata.
 */
export type Hook<THookFn extends HookFn = HookFn, THookMeta extends HookMeta = HookMeta> = {
    fn: THookFn;
    meta?: THookMeta;
};
/**
 * Represents a map of hook types to hook functions and metas.
 */
type Hooks = Record<string, Hook>;
/**
 * Builds hook meta arguments after hook meta requirements.
 */
type HookMetaArg<THookMeta extends Record<string, unknown> | undefined> = THookMeta extends Record<string, unknown> ? [meta: THookMeta] : [meta?: never];
/**
 * Defines the return type of the {@link HookSystem.callHook} functions.
 *
 * @internal
 */
export type CallHookReturnType<THookFn extends HookFn = HookFn> = Promise<{
    data: Awaited<ReturnType<THookFn>>[];
    errors: HookError[];
}>;
/**
 * Defines the return type of the {@link HookSystem.createScope} functions.
 *
 * @internal
 */
export type CreateScopeReturnType<THooks extends Hooks = Record<string, {
    fn: HookFn;
}>, TExtraArgs extends unknown[] = never[]> = {
    hook: <TType extends keyof THooks>(type: TType, hookFn: FnWithExtraArgs<THooks[TType]["fn"], TExtraArgs>, ...[meta]: HookMetaArg<THooks[TType]["meta"]>) => void;
    unhook: HookSystem<{
        [P in keyof THooks]: Omit<THooks[P], "fn"> & {
            fn: FnWithExtraArgs<THooks[P]["fn"], TExtraArgs>;
        };
    }>["unhook"];
};
type RegisteredHookMeta = {
    id: string;
    type: string;
    owner: string;
    external?: HookFn;
};
/**
 * Represents a registered hook.
 */
type RegisteredHook<THook extends Hook = Hook> = {
    fn: THook["fn"];
    meta: THook["meta"] extends Record<string, unknown> ? RegisteredHookMeta & THook["meta"] : RegisteredHookMeta;
};
export declare class HookError<TError = Error | unknown> extends Error {
    type: string;
    owner: string;
    rawMeta: RegisteredHookMeta;
    rawCause: TError;
    constructor(meta: RegisteredHookMeta, cause: TError);
}
/**
 * @internal
 */
export declare class HookSystem<THooks extends Hooks = Hooks> {
    private _registeredHooks;
    hook<TType extends keyof THooks>(owner: string, type: TType, hookFn: THooks[TType]["fn"], ...[meta]: HookMetaArg<THooks[TType]["meta"]>): void;
    unhook<TType extends keyof THooks>(type: TType, hookFn: THooks[TType]["fn"]): void;
    callHook<TType extends Extract<keyof THooks, string>>(typeOrTypeAndHookID: TType | {
        type: TType;
        hookID: string;
    }, ...args: Parameters<THooks[TType]["fn"]>): CallHookReturnType<THooks[TType]["fn"]>;
    /**
     * Returns list of hooks for a given owner
     */
    hooksForOwner(owner: string): RegisteredHook<THooks[string]>[];
    /**
     * Returns list of hooks for a given type
     */
    hooksForType<TType extends keyof THooks>(type: TType): RegisteredHook<THooks[TType]>[];
    createScope<TExtraArgs extends unknown[] = never[]>(owner: string, extraArgs: [...TExtraArgs]): CreateScopeReturnType<THooks, TExtraArgs>;
}
export {};
