"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
class HookError extends Error {
  constructor(meta, cause) {
    super(`Error in \`${meta.owner}\` during \`${meta.type}\` hook: ${cause instanceof Error ? cause.message : String(cause)}`);
    __publicField(this, "type");
    __publicField(this, "owner");
    __publicField(this, "rawMeta");
    __publicField(this, "rawCause");
    this.type = meta.type;
    this.owner = meta.owner;
    this.rawMeta = meta;
    this.rawCause = cause;
    this.cause = cause instanceof Error ? cause : void 0;
  }
}
const uuid = () => {
  return (++uuid.i).toString();
};
uuid.i = 0;
class HookSystem {
  constructor() {
    __publicField(this, "_registeredHooks", {});
  }
  hook(owner, type, hookFn, ...[meta]) {
    const registeredHook = {
      fn: hookFn,
      meta: {
        ...meta,
        owner,
        type,
        id: uuid()
      }
    };
    const registeredHooksForType = this._registeredHooks[type];
    if (registeredHooksForType) {
      registeredHooksForType.push(registeredHook);
    } else {
      this._registeredHooks[type] = [registeredHook];
    }
  }
  unhook(type, hookFn) {
    var _a;
    this._registeredHooks[type] = (_a = this._registeredHooks[type]) == null ? void 0 : _a.filter((registeredHook) => registeredHook.fn !== hookFn);
  }
  async callHook(typeOrTypeAndHookID, ...args) {
    var _a;
    let hooks;
    if (typeof typeOrTypeAndHookID === "string") {
      hooks = this._registeredHooks[typeOrTypeAndHookID] ?? [];
    } else {
      const hookForID = (_a = this._registeredHooks[typeOrTypeAndHookID.type]) == null ? void 0 : _a.find((hook) => hook.meta.id === typeOrTypeAndHookID.hookID);
      if (hookForID) {
        hooks = [hookForID];
      } else {
        throw new Error(`Hook of type \`${typeOrTypeAndHookID.type}\` with ID \`${typeOrTypeAndHookID.hookID}\` not found.`);
      }
    }
    const promises = hooks.map(async (hook) => {
      try {
        return await hook.fn(...args);
      } catch (error) {
        throw new HookError(hook.meta, error);
      }
    });
    const settledPromises = await Promise.allSettled(promises);
    return settledPromises.reduce((acc, settledPromise) => {
      if (settledPromise.status === "fulfilled") {
        acc.data.push(settledPromise.value);
      } else {
        acc.errors.push(settledPromise.reason);
      }
      return acc;
    }, { data: [], errors: [] });
  }
  /**
   * Returns list of hooks for a given owner
   */
  hooksForOwner(owner) {
    const hooks = [];
    for (const hookType in this._registeredHooks) {
      const registeredHooks = this._registeredHooks[hookType];
      if (Array.isArray(registeredHooks)) {
        for (const registeredHook of registeredHooks) {
          if (registeredHook.meta.owner === owner) {
            hooks.push(registeredHook);
          }
        }
      }
    }
    return hooks;
  }
  /**
   * Returns list of hooks for a given type
   */
  hooksForType(type) {
    return this._registeredHooks[type] ?? [];
  }
  createScope(owner, extraArgs) {
    return {
      hook: (type, hookFn, ...[meta]) => {
        const internalHook = (...args) => {
          return hookFn(...args, ...extraArgs);
        };
        const resolvedMeta = {
          ...meta,
          external: hookFn
        };
        return this.hook(
          owner,
          type,
          internalHook,
          // @ts-expect-error - TypeScript fails to assert rest argument.
          resolvedMeta
        );
      },
      unhook: (type, hookFn) => {
        var _a;
        this._registeredHooks[type] = (_a = this._registeredHooks[type]) == null ? void 0 : _a.filter((registeredHook) => registeredHook.meta.external !== hookFn);
      }
    };
  }
}
exports.HookError = HookError;
exports.HookSystem = HookSystem;
//# sourceMappingURL=HookSystem.cjs.map
