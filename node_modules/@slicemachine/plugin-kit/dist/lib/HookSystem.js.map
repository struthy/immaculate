{"version":3,"file":"HookSystem.js","sources":["../../../src/lib/HookSystem.ts"],"sourcesContent":["/**\n * Extends a function arguments with extra ones.\n */\ntype FnWithExtraArgs<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tF extends (...args: any[]) => any,\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTExtraArgs extends any[] = any[],\n> = (\n\t...args: [...args: Parameters<F>, ...extraArgs: TExtraArgs]\n) => ReturnType<F>;\n\n/**\n * Defines a hook handler.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type HookFn<TArgs extends any[] = any[], TReturn = any> = (\n\t...args: TArgs\n) => Promise<TReturn> | TReturn;\n\n/**\n * Generic hook metadata.\n */\ntype HookMeta = Record<string, unknown>;\n\n/**\n * Defines a hook, including its function handler and optional metadata.\n */\nexport type Hook<\n\tTHookFn extends HookFn = HookFn,\n\tTHookMeta extends HookMeta = HookMeta,\n> = {\n\tfn: THookFn;\n\tmeta?: THookMeta;\n};\n\n/**\n * Represents a map of hook types to hook functions and metas.\n */\ntype Hooks = Record<string, Hook>;\n\n/**\n * Builds hook meta arguments after hook meta requirements.\n */\ntype HookMetaArg<THookMeta extends Record<string, unknown> | undefined> =\n\tTHookMeta extends Record<string, unknown>\n\t\t? [meta: THookMeta]\n\t\t: [meta?: never];\n\n/**\n * Defines the return type of the {@link HookSystem.callHook} functions.\n *\n * @internal\n */\nexport type CallHookReturnType<THookFn extends HookFn = HookFn> = Promise<{\n\tdata: Awaited<ReturnType<THookFn>>[];\n\terrors: HookError[];\n}>;\n\n/**\n * Defines the return type of the {@link HookSystem.createScope} functions.\n *\n * @internal\n */\nexport type CreateScopeReturnType<\n\tTHooks extends Hooks = Record<string, { fn: HookFn }>,\n\tTExtraArgs extends unknown[] = never[],\n> = {\n\thook: <TType extends keyof THooks>(\n\t\ttype: TType,\n\t\thookFn: FnWithExtraArgs<THooks[TType][\"fn\"], TExtraArgs>,\n\t\t...[meta]: HookMetaArg<THooks[TType][\"meta\"]>\n\t) => void;\n\tunhook: HookSystem<{\n\t\t[P in keyof THooks]: Omit<THooks[P], \"fn\"> & {\n\t\t\tfn: FnWithExtraArgs<THooks[P][\"fn\"], TExtraArgs>;\n\t\t};\n\t}>[\"unhook\"];\n};\n\ntype RegisteredHookMeta = {\n\tid: string;\n\ttype: string;\n\towner: string;\n\texternal?: HookFn;\n};\n\n/**\n * Represents a registered hook.\n */\ntype RegisteredHook<THook extends Hook = Hook> = {\n\tfn: THook[\"fn\"];\n\tmeta: THook[\"meta\"] extends Record<string, unknown>\n\t\t? RegisteredHookMeta & THook[\"meta\"]\n\t\t: RegisteredHookMeta;\n};\n\nexport class HookError<TError = Error | unknown> extends Error {\n\ttype: string;\n\towner: string;\n\trawMeta: RegisteredHookMeta;\n\trawCause: TError;\n\n\tconstructor(meta: RegisteredHookMeta, cause: TError) {\n\t\tsuper(\n\t\t\t`Error in \\`${meta.owner}\\` during \\`${meta.type}\\` hook: ${\n\t\t\t\tcause instanceof Error ? cause.message : String(cause)\n\t\t\t}`,\n\t\t);\n\n\t\tthis.type = meta.type;\n\t\tthis.owner = meta.owner;\n\t\tthis.rawMeta = meta;\n\t\tthis.rawCause = cause;\n\t\tthis.cause = cause instanceof Error ? cause : undefined;\n\t}\n}\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString();\n};\nuuid.i = 0;\n\n/**\n * @internal\n */\nexport class HookSystem<THooks extends Hooks = Hooks> {\n\tprivate _registeredHooks: {\n\t\t[K in keyof THooks]?: RegisteredHook<THooks[K]>[];\n\t} = {};\n\n\thook<TType extends keyof THooks>(\n\t\towner: string,\n\t\ttype: TType,\n\t\thookFn: THooks[TType][\"fn\"],\n\t\t...[meta]: HookMetaArg<THooks[TType][\"meta\"]>\n\t): void {\n\t\tconst registeredHook = {\n\t\t\tfn: hookFn,\n\t\t\tmeta: {\n\t\t\t\t...meta,\n\t\t\t\towner,\n\t\t\t\ttype,\n\t\t\t\tid: uuid(),\n\t\t\t},\n\t\t} as RegisteredHook<THooks[TType]>;\n\n\t\tconst registeredHooksForType = this._registeredHooks[type];\n\n\t\tif (registeredHooksForType) {\n\t\t\tregisteredHooksForType.push(registeredHook);\n\t\t} else {\n\t\t\tthis._registeredHooks[type] = [registeredHook];\n\t\t}\n\t}\n\n\tunhook<TType extends keyof THooks>(\n\t\ttype: TType,\n\t\thookFn: THooks[TType][\"fn\"],\n\t): void {\n\t\tthis._registeredHooks[type] = this._registeredHooks[type]?.filter(\n\t\t\t(registeredHook) => registeredHook.fn !== hookFn,\n\t\t);\n\t}\n\n\tasync callHook<TType extends Extract<keyof THooks, string>>(\n\t\ttypeOrTypeAndHookID: TType | { type: TType; hookID: string },\n\t\t...args: Parameters<THooks[TType][\"fn\"]>\n\t): CallHookReturnType<THooks[TType][\"fn\"]> {\n\t\tlet hooks: RegisteredHook<THooks[TType]>[];\n\n\t\tif (typeof typeOrTypeAndHookID === \"string\") {\n\t\t\thooks = this._registeredHooks[typeOrTypeAndHookID] ?? [];\n\t\t} else {\n\t\t\tconst hookForID = this._registeredHooks[typeOrTypeAndHookID.type]?.find(\n\t\t\t\t(hook) => hook.meta.id === typeOrTypeAndHookID.hookID,\n\t\t\t);\n\n\t\t\tif (hookForID) {\n\t\t\t\thooks = [hookForID];\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Hook of type \\`${typeOrTypeAndHookID.type}\\` with ID \\`${typeOrTypeAndHookID.hookID}\\` not found.`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst promises = hooks.map(async (hook) => {\n\t\t\ttry {\n\t\t\t\treturn await hook.fn(...args);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new HookError(hook.meta, error);\n\t\t\t}\n\t\t});\n\n\t\tconst settledPromises = await Promise.allSettled(promises);\n\n\t\treturn settledPromises.reduce<{\n\t\t\tdata: Awaited<ReturnType<THooks[TType][\"fn\"]>>[];\n\t\t\terrors: HookError[];\n\t\t}>(\n\t\t\t(acc, settledPromise) => {\n\t\t\t\tif (settledPromise.status === \"fulfilled\") {\n\t\t\t\t\tacc.data.push(settledPromise.value);\n\t\t\t\t} else {\n\t\t\t\t\tacc.errors.push(settledPromise.reason);\n\t\t\t\t}\n\n\t\t\t\treturn acc;\n\t\t\t},\n\t\t\t{ data: [], errors: [] },\n\t\t);\n\t}\n\n\t/**\n\t * Returns list of hooks for a given owner\n\t */\n\thooksForOwner(owner: string): RegisteredHook<THooks[string]>[] {\n\t\tconst hooks: RegisteredHook<THooks[string]>[] = [];\n\n\t\tfor (const hookType in this._registeredHooks) {\n\t\t\tconst registeredHooks = this._registeredHooks[hookType];\n\n\t\t\tif (Array.isArray(registeredHooks)) {\n\t\t\t\tfor (const registeredHook of registeredHooks) {\n\t\t\t\t\tif (registeredHook.meta.owner === owner) {\n\t\t\t\t\t\thooks.push(registeredHook);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn hooks;\n\t}\n\n\t/**\n\t * Returns list of hooks for a given type\n\t */\n\thooksForType<TType extends keyof THooks>(\n\t\ttype: TType,\n\t): RegisteredHook<THooks[TType]>[] {\n\t\treturn this._registeredHooks[type] ?? [];\n\t}\n\n\tcreateScope<TExtraArgs extends unknown[] = never[]>(\n\t\towner: string,\n\t\textraArgs: [...TExtraArgs],\n\t): CreateScopeReturnType<THooks, TExtraArgs> {\n\t\treturn {\n\t\t\thook: (type, hookFn, ...[meta]) => {\n\t\t\t\tconst internalHook = ((\n\t\t\t\t\t...args: Parameters<THooks[typeof type][\"fn\"]>\n\t\t\t\t) => {\n\t\t\t\t\treturn hookFn(...args, ...extraArgs);\n\t\t\t\t}) as THooks[typeof type][\"fn\"];\n\n\t\t\t\tconst resolvedMeta = {\n\t\t\t\t\t...meta,\n\t\t\t\t\texternal: hookFn,\n\t\t\t\t} as HookMetaArg<THooks[typeof type][\"meta\"]>[0];\n\n\t\t\t\treturn this.hook(\n\t\t\t\t\towner,\n\t\t\t\t\ttype,\n\t\t\t\t\tinternalHook,\n\t\t\t\t\t// @ts-expect-error - TypeScript fails to assert rest argument.\n\t\t\t\t\tresolvedMeta,\n\t\t\t\t);\n\t\t\t},\n\t\t\tunhook: (type, hookFn) => {\n\t\t\t\tthis._registeredHooks[type] = this._registeredHooks[type]?.filter(\n\t\t\t\t\t(registeredHook) => registeredHook.meta.external !== hookFn,\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;AAiGM,MAAO,kBAA4C,MAAK;AAAA,EAM7D,YAAY,MAA0B,OAAa;AAEjD,UAAA,cAAc,KAAK,oBAAoB,KAAK,gBAC3C,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,GACpD;AATJ;AACA;AACA;AACA;AASC,SAAK,OAAO,KAAK;AACjB,SAAK,QAAQ,KAAK;AAClB,SAAK,UAAU;AACf,SAAK,WAAW;AACX,SAAA,QAAQ,iBAAiB,QAAQ,QAAQ;AAAA,EAC/C;AACA;AAED,MAAM,OAAO,MAAa;AACjB,UAAA,EAAE,KAAK,GAAG,SAAQ;AAC3B;AACA,KAAK,IAAI;MAKI,WAAU;AAAA;AACd,4CAEJ,CAAA;AAAA;AAAA,EAEJ,KACC,OACA,MACA,WACG,CAAC,IAAI,GAAqC;AAE7C,UAAM,iBAAiB;AAAA,MACtB,IAAI;AAAA,MACJ,MAAM;AAAA,QACL,GAAG;AAAA,QACH;AAAA,QACA;AAAA,QACA,IAAI,KAAM;AAAA,MACV;AAAA,IAAA;AAGI,UAAA,yBAAyB,KAAK,iBAAiB,IAAI;AAEzD,QAAI,wBAAwB;AAC3B,6BAAuB,KAAK,cAAc;AAAA,IAAA,OACpC;AACN,WAAK,iBAAiB,IAAI,IAAI,CAAC,cAAc;AAAA,IAC7C;AAAA,EACF;AAAA,EAEA,OACC,MACA,QAA2B;AA7DvB;AA+DJ,SAAK,iBAAiB,IAAI,KAAI,UAAK,iBAAiB,IAAI,MAA1B,mBAA6B,OAC1D,CAAC,mBAAmB,eAAe,OAAO;AAAA,EAE5C;AAAA,EAEA,MAAM,SACL,wBACG,MAAqC;AAtEpC;AAwEA,QAAA;AAEA,QAAA,OAAO,wBAAwB,UAAU;AAC5C,cAAQ,KAAK,iBAAiB,mBAAmB,KAAK,CAAA;AAAA,IAAA,OAChD;AACN,YAAM,aAAY,UAAK,iBAAiB,oBAAoB,IAAI,MAA9C,mBAAiD,KAClE,CAAC,SAAS,KAAK,KAAK,OAAO,oBAAoB;AAGhD,UAAI,WAAW;AACd,gBAAQ,CAAC,SAAS;AAAA,MAAA,OACZ;AACN,cAAM,IAAI,MACT,kBAAkB,oBAAoB,oBAAoB,oBAAoB,qBAAqB;AAAA,MAEpG;AAAA,IACD;AAED,UAAM,WAAW,MAAM,IAAI,OAAO,SAAQ;AACrC,UAAA;AACH,eAAO,MAAM,KAAK,GAAG,GAAG,IAAI;AAAA,eACpB;AACR,cAAM,IAAI,UAAU,KAAK,MAAM,KAAK;AAAA,MACpC;AAAA,IAAA,CACD;AAED,UAAM,kBAAkB,MAAM,QAAQ,WAAW,QAAQ;AAEzD,WAAO,gBAAgB,OAItB,CAAC,KAAK,mBAAkB;AACnB,UAAA,eAAe,WAAW,aAAa;AACtC,YAAA,KAAK,KAAK,eAAe,KAAK;AAAA,MAAA,OAC5B;AACF,YAAA,OAAO,KAAK,eAAe,MAAM;AAAA,MACrC;AAEM,aAAA;AAAA,IACR,GACA,EAAE,MAAM,CAAA,GAAI,QAAQ,CAAA,EAAI,CAAA;AAAA,EAE1B;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc,OAAa;AAC1B,UAAM,QAA0C,CAAA;AAErC,eAAA,YAAY,KAAK,kBAAkB;AACvC,YAAA,kBAAkB,KAAK,iBAAiB,QAAQ;AAElD,UAAA,MAAM,QAAQ,eAAe,GAAG;AACnC,mBAAW,kBAAkB,iBAAiB;AACzC,cAAA,eAAe,KAAK,UAAU,OAAO;AACxC,kBAAM,KAAK,cAAc;AAAA,UACzB;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAEM,WAAA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,aACC,MAAW;AAEX,WAAO,KAAK,iBAAiB,IAAI,KAAK,CAAA;AAAA,EACvC;AAAA,EAEA,YACC,OACA,WAA0B;AAEnB,WAAA;AAAA,MACN,MAAM,CAAC,MAAM,WAAW,CAAC,IAAI,MAAK;AAC3B,cAAA,eAAgB,IAClB,SACA;AACH,iBAAO,OAAO,GAAG,MAAM,GAAG,SAAS;AAAA,QAAA;AAGpC,cAAM,eAAe;AAAA,UACpB,GAAG;AAAA,UACH,UAAU;AAAA,QAAA;AAGX,eAAO,KAAK;AAAA,UACX;AAAA,UACA;AAAA,UACA;AAAA;AAAA,UAEA;AAAA,QAAA;AAAA,MAEF;AAAA,MACA,QAAQ,CAAC,MAAM,WAAU;AA5KtB;AA6KF,aAAK,iBAAiB,IAAI,KAAI,UAAK,iBAAiB,IAAI,MAA1B,mBAA6B,OAC1D,CAAC,mBAAmB,eAAe,KAAK,aAAa;AAAA,MAEvD;AAAA,IAAA;AAAA,EAEF;AACA;"}