var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as path from "node:path";
import * as fs from "node:fs/promises";
import * as prettier from "prettier";
import { stripIndent } from "common-tags";
import { decodeSliceMachineConfig } from "./lib/decodeSliceMachineConfig.js";
const createSliceMachineHelpers = (project) => {
  return new SliceMachineHelpers(project);
};
class SliceMachineHelpers {
  constructor(project) {
    /**
     * The Slice Machine project's metadata.
     *
     * @internal
     */
    __publicField(this, "_project");
    __publicField(this, "getProject", async () => {
      const configFilePath = this.joinPathFromRoot("slicemachine.config.json");
      let rawConfig;
      try {
        const contents = await fs.readFile(configFilePath, "utf8");
        rawConfig = JSON.parse(contents);
      } catch {
      }
      if (!rawConfig) {
        throw new Error("No config found.");
      }
      const { value: sliceMachineConfig, error } = decodeSliceMachineConfig(rawConfig);
      if (error) {
        throw new Error(`Invalid config. ${error.errors.join(", ")}`);
      }
      return {
        ...this._project,
        config: sliceMachineConfig
      };
    });
    __publicField(this, "updateSliceMachineConfig", async (sliceMachineConfig, options) => {
      const { value: decodedSliceMachineConfig, error } = decodeSliceMachineConfig(sliceMachineConfig);
      if (error) {
        throw new Error(`Invalid config provided. ${error.errors.join(", ")}`);
      }
      const configFilePath = this.joinPathFromRoot("slicemachine.config.json");
      let content = JSON.stringify(decodedSliceMachineConfig, null, 2);
      if (options == null ? void 0 : options.format) {
        content = await this.format(content, configFilePath);
      }
      await fs.writeFile(configFilePath, content);
    });
    __publicField(this, "format", async (source, filePath, options) => {
      let formatted = stripIndent(source);
      const prettierOptions = await prettier.resolveConfig(filePath || this._project.root);
      formatted = await prettier.format(formatted, {
        ...prettierOptions,
        filepath: filePath,
        ...(options == null ? void 0 : options.prettier) ?? {}
      });
      if ((options == null ? void 0 : options.includeNewlineAtEnd) === false) {
        formatted = formatted.replace(/[\r\n]+$/, "");
      }
      return formatted;
    });
    __publicField(this, "joinPathFromRoot", (...paths) => {
      return path.join(this._project.root, ...paths);
    });
    this._project = project;
  }
}
export {
  SliceMachineHelpers,
  createSliceMachineHelpers
};
//# sourceMappingURL=createSliceMachineHelpers.js.map
