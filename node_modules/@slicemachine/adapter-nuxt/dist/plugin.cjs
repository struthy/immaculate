"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const path = require("node:path");
const node_url = require("node:url");
const pluginKit = require("@slicemachine/plugin-kit");
const fs = require("@slicemachine/plugin-kit/fs");
const rejectIfNecessary = require("./lib/rejectIfNecessary.cjs");
const upsertSliceLibraryIndexFile = require("./lib/upsertSliceLibraryIndexFile.cjs");
const _package = require("./package.json.cjs");
const constants = require("./constants.cjs");
const documentationRead = require("./hooks/documentation-read.cjs");
const projectInit = require("./hooks/project-init.cjs");
const sliceCreate = require("./hooks/slice-create.cjs");
const snippetRead = require("./hooks/snippet-read.cjs");
const index = require("./sliceTemplates/Hero/index.cjs");
const index$3 = require("./sliceTemplates/CallToAction/index.cjs");
const index$2 = require("./sliceTemplates/AlternateGrid/index.cjs");
const index$1 = require("./sliceTemplates/CustomerLogos/index.cjs");
const plugin = pluginKit.defineSliceMachinePlugin({
  meta: {
    name: _package.name
  },
  defaultOptions: {
    format: true,
    lazyLoadSlices: true
  },
  setup({ hook }) {
    hook("project:init", projectInit.projectInit);
    hook("project:environment:update", async (data, context) => {
      await fs.writeProjectEnvironment({
        variableName: constants.PRISMIC_ENVIRONMENT_ENVIRONMENT_VARIABLE_NAME,
        environment: data.environment,
        filename: context.options.environmentVariableFilePath || constants.DEFAULT_ENVIRONMENT_VARIABLE_FILE_PATH,
        helpers: context.helpers
      });
    });
    hook("project:environment:read", async (_data, context) => {
      const projectEnvironment = await fs.readProjectEnvironment({
        variableName: constants.PRISMIC_ENVIRONMENT_ENVIRONMENT_VARIABLE_NAME,
        filenames: [
          ...constants.ENVIRONMENT_VARIABLE_PATHS,
          context.options.environmentVariableFilePath
        ].filter((filename) => Boolean(filename)),
        helpers: context.helpers
      });
      return {
        environment: projectEnvironment.environment
      };
    });
    hook("slice:create", sliceCreate.sliceCreate);
    hook("slice:update", async (data, context) => {
      await fs.writeSliceModel({
        libraryID: data.libraryID,
        model: data.model,
        ...context
      });
      await fs.upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("slice:rename", async (data, context) => {
      await fs.renameSlice({
        libraryID: data.libraryID,
        model: data.model,
        format: context.options.format,
        ...context
      });
      rejectIfNecessary.rejectIfNecessary(await Promise.allSettled([
        upsertSliceLibraryIndexFile.upsertSliceLibraryIndexFile({
          libraryID: data.libraryID,
          ...context
        }),
        fs.upsertGlobalTypeScriptTypes({
          filename: context.options.generatedTypesFilePath,
          format: context.options.format,
          ...context
        })
      ]));
    });
    hook("slice:delete", async (data, context) => {
      await fs.deleteSliceDirectory({
        libraryID: data.libraryID,
        model: data.model,
        ...context
      });
      rejectIfNecessary.rejectIfNecessary(await Promise.allSettled([
        upsertSliceLibraryIndexFile.upsertSliceLibraryIndexFile({
          libraryID: data.libraryID,
          ...context
        }),
        fs.upsertGlobalTypeScriptTypes({
          filename: context.options.generatedTypesFilePath,
          format: context.options.format,
          ...context
        })
      ]));
    });
    hook("slice:read", async (data, context) => {
      return await fs.readSliceModel({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        ...context
      });
    });
    hook("slice:asset:update", async (data, context) => {
      await fs.writeSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.asset.id,
        contents: data.asset.data,
        ...context
      });
    });
    hook("slice:asset:delete", async (data, context) => {
      await fs.deleteSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.assetID,
        ...context
      });
    });
    hook("slice:asset:read", async (data, context) => {
      const file = await fs.readSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.assetID,
        ...context
      });
      return {
        data: file
      };
    });
    hook("slice-library:read", async (data, context) => {
      return await fs.readSliceLibrary({
        libraryID: data.libraryID,
        ...context
      });
    });
    hook("slice-template-library:read", async (data, context) => {
      return await fs.readSliceTemplateLibrary({
        ...data,
        ...context,
        dirName: path.dirname(node_url.fileURLToPath(new URL(typeof document === "undefined" ? require("url").pathToFileURL(__filename).href : document.currentScript && document.currentScript.src || new URL("plugin.cjs", document.baseURI).href))),
        templates: [index, index$1, index$2, index$3],
        componentFileNames: {
          js: "javascript.vue",
          ts: "typescript.vue"
        }
      });
    });
    hook("custom-type:create", async (data, context) => {
      await fs.writeCustomTypeModel({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await fs.upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:update", async (data, context) => {
      await fs.writeCustomTypeModel({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await fs.upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:rename", async (data, context) => {
      await fs.renameCustomType({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await fs.upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:delete", async (data, context) => {
      await fs.deleteCustomTypeDirectory({
        customTypeID: data.model.id,
        ...context
      });
      await fs.upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:read", async (data, context) => {
      return await fs.readCustomTypeModel({
        customTypeID: data.id,
        ...context
      });
    });
    hook("custom-type:asset:update", async (data, context) => {
      await fs.writeCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.asset.id,
        contents: data.asset.data,
        ...context
      });
    });
    hook("custom-type:asset:delete", async (data, context) => {
      await fs.deleteCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.assetID,
        ...context
      });
    });
    hook("custom-type:asset:read", async (data, context) => {
      const file = await fs.readCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.assetID,
        ...context
      });
      return {
        data: file
      };
    });
    hook("custom-type-library:read", async (_data, context) => {
      return await fs.readCustomTypeLibrary({
        helpers: context.helpers
      });
    });
    hook("snippet:read", snippetRead.snippetRead);
    hook("documentation:read", documentationRead.documentationRead);
  }
});
exports.plugin = plugin;
//# sourceMappingURL=plugin.cjs.map
