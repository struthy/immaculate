import path__default from "node:path";
import { fileURLToPath } from "node:url";
import { defineSliceMachinePlugin } from "@slicemachine/plugin-kit";
import { writeProjectEnvironment, readProjectEnvironment, writeSliceModel, upsertGlobalTypeScriptTypes, renameSlice, deleteSliceDirectory, readSliceModel, writeSliceFile, deleteSliceFile, readSliceFile, readSliceLibrary, readSliceTemplateLibrary, writeCustomTypeModel, renameCustomType, deleteCustomTypeDirectory, readCustomTypeModel, writeCustomTypeFile, deleteCustomTypeFile, readCustomTypeFile, readCustomTypeLibrary } from "@slicemachine/plugin-kit/fs";
import { rejectIfNecessary } from "./lib/rejectIfNecessary.js";
import { upsertSliceLibraryIndexFile } from "./lib/upsertSliceLibraryIndexFile.js";
import { name } from "./package.json.js";
import { PRISMIC_ENVIRONMENT_ENVIRONMENT_VARIABLE_NAME, DEFAULT_ENVIRONMENT_VARIABLE_FILE_PATH, ENVIRONMENT_VARIABLE_PATHS } from "./constants.js";
import { documentationRead } from "./hooks/documentation-read.js";
import { projectInit } from "./hooks/project-init.js";
import { sliceCreate } from "./hooks/slice-create.js";
import { snippetRead } from "./hooks/snippet-read.js";
import * as index from "./sliceTemplates/Hero/index.js";
import * as index$3 from "./sliceTemplates/CallToAction/index.js";
import * as index$2 from "./sliceTemplates/AlternateGrid/index.js";
import * as index$1 from "./sliceTemplates/CustomerLogos/index.js";
const plugin = defineSliceMachinePlugin({
  meta: {
    name
  },
  defaultOptions: {
    format: true,
    lazyLoadSlices: true
  },
  setup({ hook }) {
    hook("project:init", projectInit);
    hook("project:environment:update", async (data, context) => {
      await writeProjectEnvironment({
        variableName: PRISMIC_ENVIRONMENT_ENVIRONMENT_VARIABLE_NAME,
        environment: data.environment,
        filename: context.options.environmentVariableFilePath || DEFAULT_ENVIRONMENT_VARIABLE_FILE_PATH,
        helpers: context.helpers
      });
    });
    hook("project:environment:read", async (_data, context) => {
      const projectEnvironment = await readProjectEnvironment({
        variableName: PRISMIC_ENVIRONMENT_ENVIRONMENT_VARIABLE_NAME,
        filenames: [
          ...ENVIRONMENT_VARIABLE_PATHS,
          context.options.environmentVariableFilePath
        ].filter((filename) => Boolean(filename)),
        helpers: context.helpers
      });
      return {
        environment: projectEnvironment.environment
      };
    });
    hook("slice:create", sliceCreate);
    hook("slice:update", async (data, context) => {
      await writeSliceModel({
        libraryID: data.libraryID,
        model: data.model,
        ...context
      });
      await upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("slice:rename", async (data, context) => {
      await renameSlice({
        libraryID: data.libraryID,
        model: data.model,
        format: context.options.format,
        ...context
      });
      rejectIfNecessary(await Promise.allSettled([
        upsertSliceLibraryIndexFile({
          libraryID: data.libraryID,
          ...context
        }),
        upsertGlobalTypeScriptTypes({
          filename: context.options.generatedTypesFilePath,
          format: context.options.format,
          ...context
        })
      ]));
    });
    hook("slice:delete", async (data, context) => {
      await deleteSliceDirectory({
        libraryID: data.libraryID,
        model: data.model,
        ...context
      });
      rejectIfNecessary(await Promise.allSettled([
        upsertSliceLibraryIndexFile({
          libraryID: data.libraryID,
          ...context
        }),
        upsertGlobalTypeScriptTypes({
          filename: context.options.generatedTypesFilePath,
          format: context.options.format,
          ...context
        })
      ]));
    });
    hook("slice:read", async (data, context) => {
      return await readSliceModel({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        ...context
      });
    });
    hook("slice:asset:update", async (data, context) => {
      await writeSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.asset.id,
        contents: data.asset.data,
        ...context
      });
    });
    hook("slice:asset:delete", async (data, context) => {
      await deleteSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.assetID,
        ...context
      });
    });
    hook("slice:asset:read", async (data, context) => {
      const file = await readSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.assetID,
        ...context
      });
      return {
        data: file
      };
    });
    hook("slice-library:read", async (data, context) => {
      return await readSliceLibrary({
        libraryID: data.libraryID,
        ...context
      });
    });
    hook("slice-template-library:read", async (data, context) => {
      return await readSliceTemplateLibrary({
        ...data,
        ...context,
        dirName: path__default.dirname(fileURLToPath(new URL(import.meta.url))),
        templates: [index, index$1, index$2, index$3],
        componentFileNames: {
          js: "javascript.vue",
          ts: "typescript.vue"
        }
      });
    });
    hook("custom-type:create", async (data, context) => {
      await writeCustomTypeModel({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:update", async (data, context) => {
      await writeCustomTypeModel({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:rename", async (data, context) => {
      await renameCustomType({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:delete", async (data, context) => {
      await deleteCustomTypeDirectory({
        customTypeID: data.model.id,
        ...context
      });
      await upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:read", async (data, context) => {
      return await readCustomTypeModel({
        customTypeID: data.id,
        ...context
      });
    });
    hook("custom-type:asset:update", async (data, context) => {
      await writeCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.asset.id,
        contents: data.asset.data,
        ...context
      });
    });
    hook("custom-type:asset:delete", async (data, context) => {
      await deleteCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.assetID,
        ...context
      });
    });
    hook("custom-type:asset:read", async (data, context) => {
      const file = await readCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.assetID,
        ...context
      });
      return {
        data: file
      };
    });
    hook("custom-type-library:read", async (_data, context) => {
      return await readCustomTypeLibrary({
        helpers: context.helpers
      });
    });
    hook("snippet:read", snippetRead);
    hook("documentation:read", documentationRead);
  }
});
export {
  plugin
};
//# sourceMappingURL=plugin.js.map
