import * as path from "node:path";
import { checkHasProjectFile, writeProjectFile, readProjectFile, deleteProjectFile } from "@slicemachine/plugin-kit/fs";
import { stripIndent } from "common-tags";
import { loadFile, builders, writeFile } from "magicast";
import { rejectIfNecessary } from "../lib/rejectIfNecessary.js";
import { checkIsTypeScriptProject } from "../lib/checkIsTypeScriptProject.js";
import { checkHasSrcDirectory } from "../lib/checkHasSrcDirectory.js";
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
const NUXT_PRISMIC = "@nuxtjs/prismic";
const installDependencies = async ({ installDependencies: installDependencies2 }) => {
  try {
    await installDependencies2({
      dependencies: {
        [NUXT_PRISMIC]: "^3.0.0"
      },
      dev: true
    });
  } catch (error) {
    await installDependencies2({
      dependencies: {
        [NUXT_PRISMIC]: "rc"
      },
      dev: true
    });
  }
};
const configurePrismicModule = async ({ helpers }) => {
  let nuxtConfigFilename = "nuxt.config.js";
  if (!await checkHasProjectFile({ filename: nuxtConfigFilename, helpers })) {
    nuxtConfigFilename = "nuxt.config.ts";
    if (!await checkHasProjectFile({ filename: nuxtConfigFilename, helpers })) {
      return;
    }
  }
  const nuxtConfigPath = helpers.joinPathFromRoot(nuxtConfigFilename);
  const mod = await loadFile(nuxtConfigPath);
  const config = mod.exports.default.$type === "function-call" ? mod.exports.default.$args[0] : mod.exports.default;
  let hasInlinedConfiguration = false;
  const hasPrismicModuleRegistered = (config.modules || []).find((registration) => {
    if (typeof registration === "string") {
      return registration === NUXT_PRISMIC;
    } else if (Array.isArray(registration)) {
      hasInlinedConfiguration = !!registration[1];
      return registration[0] === NUXT_PRISMIC;
    }
    return false;
  });
  if (!hasPrismicModuleRegistered) {
    config.modules || (config.modules = []);
    config.modules.push(NUXT_PRISMIC);
  }
  if (!hasInlinedConfiguration) {
    mod.imports.$add({
      from: "./slicemachine.config.json",
      imported: "apiEndpoint"
    });
    mod.imports.$add({
      from: "./slicemachine.config.json",
      imported: "repositoryName"
    });
    config.prismic || (config.prismic = {});
    config.prismic.endpoint = builders.raw("apiEndpoint || repositoryName");
  }
  await writeFile(mod, nuxtConfigPath);
};
const createSliceSimulatorPage = async ({ helpers, options }) => {
  const isTypeScriptProject = await checkIsTypeScriptProject({
    helpers,
    options
  });
  const srcPagesDirectoryExists = await checkHasProjectFile({
    filename: "src/pages",
    helpers
  });
  const filename = path.join(srcPagesDirectoryExists ? "src/pages" : "pages", "slice-simulator.vue");
  if (await checkHasProjectFile({ filename, helpers })) {
    return;
  }
  const scriptAttributes = ["setup"];
  if (isTypeScriptProject) {
    scriptAttributes.push('lang="ts"');
  }
  const contents = stripIndent(_a || (_a = __template(['\n		<template>\n			<SliceSimulator #default="{ slices }">\n				<SliceZone :slices="slices" :components="components" />\n			</SliceSimulator>\n		</template>\n\n		<script ', '>\n		import { SliceSimulator } from "@slicemachine/adapter-nuxt/simulator";\n		import { components } from "~/slices";\n		<\/script>\n	'])), scriptAttributes.join(" "));
  await writeProjectFile({
    filename,
    contents,
    format: options.format,
    helpers
  });
};
const moveOrDeleteAppVue = async ({ helpers, options }) => {
  const srcDirectoryExists = await checkHasProjectFile({
    filename: "src",
    helpers
  });
  const filenameAppVue = path.join(srcDirectoryExists ? "src" : "", "app.vue");
  if (!await checkHasProjectFile({ filename: filenameAppVue, helpers })) {
    return;
  }
  const filecontentAppVue = await readProjectFile({
    filename: filenameAppVue,
    helpers,
    encoding: "utf-8"
  });
  if (!filecontentAppVue.includes("<NuxtWelcome")) {
    return;
  }
  const srcPagesDirectoryExists = await checkHasProjectFile({
    filename: "src/pages",
    helpers
  });
  const filenameIndexVue = path.join(srcPagesDirectoryExists ? "src/pages" : "pages", "index.vue");
  if (!await checkHasProjectFile({ filename: filenameIndexVue, helpers })) {
    await writeProjectFile({
      filename: filenameIndexVue,
      contents: filecontentAppVue,
      format: options.format,
      helpers
    });
  }
  await deleteProjectFile({
    filename: filenameAppVue,
    helpers
  });
};
const modifySliceMachineConfig = async ({ helpers, options, actions }) => {
  var _a2;
  const hasSrcDirectory = await checkHasSrcDirectory({ helpers });
  const project = await helpers.getProject();
  (_a2 = project.config).localSliceSimulatorURL || (_a2.localSliceSimulatorURL = "http://localhost:3000/slice-simulator");
  if (hasSrcDirectory && project.config.libraries && JSON.stringify(project.config.libraries) === JSON.stringify(["./slices"])) {
    const sliceLibrary = await actions.readSliceLibrary({
      libraryID: project.config.libraries[0]
    });
    if (sliceLibrary.sliceIDs.length < 1) {
      project.config.libraries = ["./src/slices"];
    }
  }
  await helpers.updateSliceMachineConfig(project.config, {
    format: options.format
  });
};
const projectInit = async ({ installDependencies: _installDependencies }, context) => {
  rejectIfNecessary(await Promise.allSettled([
    installDependencies({ installDependencies: _installDependencies }),
    configurePrismicModule(context),
    createSliceSimulatorPage(context),
    moveOrDeleteAppVue(context),
    modifySliceMachineConfig(context)
  ]));
};
export {
  projectInit
};
//# sourceMappingURL=project-init.js.map
