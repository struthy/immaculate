{"version":3,"file":"client.cjs","sources":["../../src/client.ts"],"sourcesContent":["import type * as prismic from \"@prismicio/client\";\n\nimport type { AbortSignalLike, FetchLike, RequestInitLike } from \"./types\";\n\nimport {\n\tBulkTransactionConfirmationError,\n\tBulkTransactionLimitError,\n\tConflictError,\n\tForbiddenError,\n\tInvalidPayloadError,\n\tMissingFetchError,\n\tNotFoundError,\n\tPrismicError,\n\tUnauthorizedError,\n} from \"./errors\";\n\nimport { BulkOperation, BulkTransaction } from \"./bulk\";\n\n/**\n * The default endpoint for the Prismic Custom Types API.\n */\nconst DEFAULT_CUSTOM_TYPES_API_ENDPOINT = \"https://customtypes.prismic.io\";\n\n/**\n * Configuration for creating a `CustomTypesClient`.\n */\nexport type CustomTypesClientConfig = {\n\t/**\n\t * Name of the Prismic repository.\n\t */\n\trepositoryName: string;\n\n\t/**\n\t * The Prismic Custom Types API endpoint for the repository. The standard\n\t * Custom Types API endpoint will be used if no value is provided.\n\t */\n\tendpoint?: string;\n\n\t/**\n\t * The secure token for accessing the Prismic Custom Types API. This is\n\t * required to call any Custom Type API methods.\n\t */\n\ttoken: string;\n\n\t/**\n\t * The function used to make network requests to the Prismic Custom Types API.\n\t * In environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetch?: FetchLike;\n\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike;\n};\n\n/**\n * Parameters for `CustomTypesClient` methods. Values provided here will\n * override the client's default values, if present.\n */\nexport type CustomTypesClientMethodParams = Partial<\n\tPick<CustomTypesClientConfig, \"repositoryName\" | \"endpoint\" | \"token\">\n>;\n\n/**\n * Parameters for client methods that use `fetch()`.\n */\ntype FetchParams = {\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike;\n\n\t/**\n\t * An `AbortSignal` provided by an `AbortController`. This allows the network\n\t * request to be cancelled if necessary.\n\t *\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}\n\t */\n\tsignal?: AbortSignalLike;\n};\n\n/**\n * Parameters for the `bulk()` client method.\n */\ntype BulkParams = {\n\t/**\n\t * Determines if the method stops a bulk request if the changes require\n\t * deleting Prismic documents.\n\t *\n\t * @defaultValue false\n\t */\n\tdeleteDocuments?: boolean;\n};\n\n/**\n * Create a `RequestInit` object for a POST `fetch` request. The provided body\n * will be run through `JSON.stringify`.\n *\n * @param body - The request's body.\n *\n * @returns The `RequestInit` object with the given body.\n */\nconst createPostFetchRequestInit = <T>(body: T): RequestInitLike => {\n\treturn {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify(body),\n\t};\n};\n\n/**\n * Create a client for the Prismic Custom Types API.\n */\nexport const createClient = (\n\t...args: ConstructorParameters<typeof CustomTypesClient>\n): CustomTypesClient => new CustomTypesClient(...args);\n\n/**\n * A client for the Prismic Custom Types API.\n *\n * @see Custom Types API documentation: {@link https://prismic.io/docs/technologies/custom-types-api}\n */\nexport class CustomTypesClient {\n\t/**\n\t * Name of the Prismic repository.\n\t */\n\trepositoryName: string;\n\n\t/**\n\t * The Prismic Custom Types API endpoint for the repository. The standard\n\t * Custom Types API endpoint will be used if no value is provided.\n\t *\n\t * @defaultValue `https://customtypes.prismic.io`\n\t */\n\tendpoint: string;\n\n\t/**\n\t * The secure token for accessing the Prismic Custom Types API. This is\n\t * required to call any Custom Type API methods.\n\t */\n\ttoken: string;\n\n\t/**\n\t * The function used to make network requests to the Prismic Custom Types API.\n\t * In environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetchFn: FetchLike;\n\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike;\n\n\t/**\n\t * Create a client for the Prismic Custom Types API.\n\t */\n\tconstructor(config: CustomTypesClientConfig) {\n\t\tthis.repositoryName = config.repositoryName;\n\t\tthis.endpoint = config.endpoint || DEFAULT_CUSTOM_TYPES_API_ENDPOINT;\n\t\tthis.token = config.token;\n\t\tthis.fetchOptions = config.fetchOptions;\n\n\t\t// TODO: Remove the following `if` statement in v2.\n\t\t//\n\t\t// v1 erroneously assumed `/customtypes` would be part of\n\t\t// `this.endpoint`, forcing all custom endpoints to include\n\t\t// `/customtypes`.\n\t\t//\n\t\t// The client no longer assumes `/customtypes`. This `if`\n\t\t// statement ensures backwards compatibility with existing\n\t\t// custom endpoints that includes `/customtypes`.\n\t\tif (/\\/customtypes\\/?$/.test(this.endpoint)) {\n\t\t\tthis.endpoint = this.endpoint.replace(/\\/customtypes\\/?$/, \"\");\n\t\t}\n\n\t\tif (typeof config.fetch === \"function\") {\n\t\t\tthis.fetchFn = config.fetch;\n\t\t} else if (typeof globalThis.fetch === \"function\") {\n\t\t\tthis.fetchFn = globalThis.fetch;\n\t\t} else {\n\t\t\tthrow new MissingFetchError(\n\t\t\t\t\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` config parameter.\",\n\t\t\t);\n\t\t}\n\n\t\t// If the global fetch function is used, we must bind it to the global scope.\n\t\tif (this.fetchFn === globalThis.fetch) {\n\t\t\tthis.fetchFn = this.fetchFn.bind(globalThis);\n\t\t}\n\t}\n\n\t/**\n\t * Returns all Custom Types models from the Prismic repository.\n\t *\n\t * @typeParam TCustomType - The Custom Type returned from the API.\n\t *\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns All Custom Type models from the Prismic repository.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t */\n\tasync getAllCustomTypes<TCustomType extends prismic.CustomTypeModel>(\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TCustomType[]> {\n\t\treturn await this.fetch<TCustomType[]>(\"./customtypes\", params);\n\t}\n\n\t/**\n\t * Returns a Custom Type model with a given ID from the Prismic repository.\n\t *\n\t * @typeParam TCustomType - The Custom Type returned from the API.\n\t *\n\t * @param id - ID of the Custom Type.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The Custom Type model from the Prismic repository.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link NotFoundError} Thrown if a Custom Type with the given ID\n\t *   cannot be found.\n\t */\n\tasync getCustomTypeByID<TCustomType extends prismic.CustomTypeModel>(\n\t\tid: string,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TCustomType> {\n\t\treturn await this.fetch<TCustomType>(`./customtypes/${id}`, params);\n\t}\n\n\t/**\n\t * Inserts a Custom Type model to the Prismic repository.\n\t *\n\t * @typeParam TCustomType - The Custom Type to insert.\n\t *\n\t * @param customType - The Custom Type to insert.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The inserted Custom Type.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link InvalidPayloadError} Thrown if an invalid Custom Type is\n\t *   provided.\n\t * @throws {@link ConflictError} Thrown if a Custom Type with the given ID\n\t *   already exists.\n\t */\n\tasync insertCustomType<TCustomType extends prismic.CustomTypeModel>(\n\t\tcustomType: TCustomType,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TCustomType> {\n\t\tawait this.fetch<undefined>(\n\t\t\t\"./customtypes/insert\",\n\t\t\tparams,\n\t\t\tcreatePostFetchRequestInit(customType),\n\t\t);\n\n\t\treturn customType;\n\t}\n\n\t/**\n\t * Updates a Custom Type model from the Prismic repository.\n\t *\n\t * @typeParam TCustomType - The updated Custom Type.\n\t *\n\t * @param customType - The updated Custom Type.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The updated Custom Type.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link InvalidPayloadError} Thrown if an invalid Custom Type is\n\t *   provided.\n\t * @throws {@link NotFoundError} Thrown if a Custom Type with the given ID\n\t *   cannot be found.\n\t */\n\tasync updateCustomType<TCustomType extends prismic.CustomTypeModel>(\n\t\tcustomType: TCustomType,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TCustomType> {\n\t\tawait this.fetch<undefined>(\n\t\t\t\"./customtypes/update\",\n\t\t\tparams,\n\t\t\tcreatePostFetchRequestInit(customType),\n\t\t);\n\n\t\treturn customType;\n\t}\n\n\t/**\n\t * Removes a Custom Type model from the Prismic repository.\n\t *\n\t * @typeParam TCustomTypeID - The ID of the Custom Type.\n\t *\n\t * @param id - The ID of the Custom Type to remove.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The ID of the removed Custom Type.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t */\n\tasync removeCustomType<TCustomTypeID extends string>(\n\t\tid: TCustomTypeID,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TCustomTypeID> {\n\t\tawait this.fetch<undefined>(`./customtypes/${id}`, params, {\n\t\t\tmethod: \"DELETE\",\n\t\t});\n\n\t\treturn id;\n\t}\n\n\t/**\n\t * Returns all Shared Slice models from the Prismic repository.\n\t *\n\t * @typeParam TSharedSliceModel - The Shared Slice model returned from the\n\t *   API.\n\t *\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns All Shared Slice models from the Prismic repository.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t */\n\tasync getAllSharedSlices<TSharedSliceModel extends prismic.SharedSliceModel>(\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TSharedSliceModel[]> {\n\t\treturn await this.fetch<TSharedSliceModel[]>(\"./slices\", params);\n\t}\n\n\t/**\n\t * Returns a Shared Slice model with a given ID from the Prismic repository.\n\t *\n\t * @typeParam TSharedSliceModel - The Shared Slice model returned from the\n\t *   API.\n\t *\n\t * @param id - ID of the Shared Slice.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The Shared Slice model from the Prismic repository.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link NotFoundError} Thrown if a Shared Slice with the given ID\n\t *   cannot be found.\n\t */\n\tasync getSharedSliceByID<TSharedSliceModel extends prismic.SharedSliceModel>(\n\t\tid: string,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TSharedSliceModel> {\n\t\treturn await this.fetch<TSharedSliceModel>(`./slices/${id}`, params);\n\t}\n\n\t/**\n\t * Inserts a Shared Slice model to the Prismic repository.\n\t *\n\t * @typeParam TSharedSliceModel - The Shared Slice model to insert.\n\t *\n\t * @param slice - The Shared Slice model to insert.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The inserted Shared Slice model.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link InvalidPayloadError} Thrown if an invalid Shared Slice model\n\t *   is provided.\n\t * @throws {@link ConflictError} Thrown if a Shared Slice with the given ID\n\t *   already exists.\n\t */\n\tasync insertSharedSlice<TSharedSliceModel extends prismic.SharedSliceModel>(\n\t\tslice: TSharedSliceModel,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TSharedSliceModel> {\n\t\tawait this.fetch(\n\t\t\t\"./slices/insert\",\n\t\t\tparams,\n\t\t\tcreatePostFetchRequestInit(slice),\n\t\t);\n\n\t\treturn slice;\n\t}\n\n\t/**\n\t * Updates a Shared Slice model from the Prismic repository.\n\t *\n\t * @typeParam TSharedSliceModel - The updated Shared Slice model.\n\t *\n\t * @param slice - The updated Shared Slice model.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The updated Shared Slice model.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link InvalidPayloadError} Thrown if an invalid Shared Slice model\n\t *   is provided.\n\t * @throws {@link NotFoundError} Thrown if a Shared Slice with the given ID\n\t *   cannot be found.\n\t */\n\tasync updateSharedSlice<TSharedSliceModel extends prismic.SharedSliceModel>(\n\t\tslice: TSharedSliceModel,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TSharedSliceModel> {\n\t\tawait this.fetch(\n\t\t\t\"./slices/update\",\n\t\t\tparams,\n\t\t\tcreatePostFetchRequestInit(slice),\n\t\t);\n\n\t\treturn slice;\n\t}\n\n\t/**\n\t * Removes a Shared Slice model from the Prismic repository.\n\t *\n\t * @typeParam TSharedSliceID - The ID of the Shared Slice.\n\t *\n\t * @param id - The ID of the Shared Slice to remove.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The ID of the removed Shared Slice.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t */\n\tasync removeSharedSlice<TSharedSliceID extends string>(\n\t\tid: TSharedSliceID,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TSharedSliceID> {\n\t\tawait this.fetch(`./slices/${id}`, params, {\n\t\t\tmethod: \"DELETE\",\n\t\t});\n\n\t\treturn id;\n\t}\n\n\t/**\n\t * Performs multiple insert, update, and/or delete operations in a single\n\t * transaction.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const bulkTransaction = createBulkTransaction();\n\t * bulkTransaction.insertCustomType(myCustomType);\n\t * bulkTransaction.deleteSlice(mySlice);\n\t *\n\t * await client.bulk(bulkTransaction);\n\t * ```\n\t *\n\t * @param operations - A `BulkTransaction` containing all operations or an\n\t *   array of objects describing an operation.\n\t * @param params - Parameters that determine how the method behaves and for\n\t *   overriding the client's default configuration.\n\t *\n\t * @returns An array of objects describing the operations.\n\t */\n\tasync bulk(\n\t\toperations: BulkTransaction | BulkOperation[],\n\t\tparams?: BulkParams & CustomTypesClientMethodParams & FetchParams,\n\t): Promise<BulkOperation[]> {\n\t\tconst resolvedOperations =\n\t\t\toperations instanceof BulkTransaction\n\t\t\t\t? operations.operations\n\t\t\t\t: operations;\n\n\t\tawait this.fetch(\n\t\t\t\"./bulk\",\n\t\t\tparams,\n\t\t\tcreatePostFetchRequestInit({\n\t\t\t\tconfirmDeleteDocuments: params?.deleteDocuments ?? false,\n\t\t\t\tchanges: resolvedOperations,\n\t\t\t}),\n\t\t);\n\n\t\treturn resolvedOperations;\n\t}\n\n\t/**\n\t * Performs a network request using the configured `fetch` function. It\n\t * assumes all successful responses will have a JSON content type. It also\n\t * normalizes unsuccessful network requests.\n\t *\n\t * @typeParam T - The JSON response.\n\t *\n\t * @param path - URL to the resource to fetch.\n\t * @param params - Parameters to override the client's default configuration.\n\t * @param requestInit - `RequestInit` overrides for the `fetch` request.\n\t *\n\t * @returns The response from the network request, if any.\n\t *\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link InvalidPayloadError} Thrown if the given body is invalid.\n\t * @throws {@link ConflictError} Thrown if an entity with the given ID already\n\t *   exists.\n\t * @throws {@link NotFoundError} Thrown if the requested entity could not be\n\t *   found.\n\t */\n\tprivate async fetch<T = unknown>(\n\t\tpath: string,\n\t\tparams: Partial<CustomTypesClientMethodParams> & FetchParams = {},\n\t\trequestInit: RequestInitLike = {},\n\t): Promise<T> {\n\t\tconst endpoint = params.endpoint || this.endpoint;\n\t\tconst url = new URL(\n\t\t\tpath,\n\t\t\tendpoint.endsWith(\"/\") ? endpoint : `${endpoint}/`,\n\t\t).toString();\n\n\t\tconst res = await this.fetchFn(url, {\n\t\t\t...this.fetchOptions,\n\t\t\t...requestInit,\n\t\t\t...params.fetchOptions,\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\trepository: params.repositoryName || this.repositoryName,\n\t\t\t\tAuthorization: `Bearer ${params.token || this.token}`,\n\t\t\t\t...this.fetchOptions?.headers,\n\t\t\t\t...requestInit.headers,\n\t\t\t\t...params.fetchOptions?.headers,\n\t\t\t},\n\t\t\tsignal:\n\t\t\t\tparams.fetchOptions?.signal ||\n\t\t\t\tparams.signal ||\n\t\t\t\trequestInit.signal ||\n\t\t\t\tthis.fetchOptions?.signal,\n\t\t});\n\n\t\tswitch (res.status) {\n\t\t\t// Successful\n\t\t\t// - Successfully get one or more Custom Types\n\t\t\t// - Successfully get one or more Shared Slices\n\t\t\tcase 200: {\n\t\t\t\treturn await res.json();\n\t\t\t}\n\n\t\t\t// Created\n\t\t\t// - Successfully insert a Custom Type\n\t\t\t// - Successfully insert a Shared Slice\n\t\t\tcase 201:\n\t\t\t// No Content\n\t\t\t// - Successfully update a Custom Type\n\t\t\t// - Successfully delete a Custom Type\n\t\t\t// - Successfully update a Shared Slice\n\t\t\t// - Successfully delete a Shared Slice\n\t\t\tcase 204: {\n\t\t\t\t// We use `any` since we don't have a concrete value we can return. We\n\t\t\t\t// let the call site define what the return type is with the `T` generic.\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\treturn undefined as any;\n\t\t\t}\n\n\t\t\t// Accepted\n\t\t\t// - Soft limit reached for bulk request (requires confirmation)\n\t\t\tcase 202: {\n\t\t\t\tconst json = await res.json();\n\n\t\t\t\tthrow new BulkTransactionConfirmationError(\n\t\t\t\t\t\"The bulk transaction will delete documents. Confirm before trying again.\",\n\t\t\t\t\t{ url, response: json },\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Bad Request\n\t\t\t// - Invalid body sent\n\t\t\tcase 400: {\n\t\t\t\tconst text = await res.text();\n\n\t\t\t\tthrow new InvalidPayloadError(text, { url, response: text });\n\t\t\t}\n\n\t\t\t// Unauthorized\n\t\t\t// - User does not have access to requested repository\n\t\t\tcase 401: {\n\t\t\t\tconst text = await res.text();\n\n\t\t\t\tthrow new UnauthorizedError(text, { url, response: text });\n\t\t\t}\n\n\t\t\t// Forbidden\n\t\t\t// - Missing token\n\t\t\t// - Incorrect token\n\t\t\t// - Hard limit reached for bulk request (cannot process)\n\t\t\tcase 403: {\n\t\t\t\tconst json = await res.json();\n\n\t\t\t\tif (\"details\" in json) {\n\t\t\t\t\tthrow new BulkTransactionLimitError(\n\t\t\t\t\t\t\"The bulk transaction reached or surpassed the limit of allowed commands.\",\n\t\t\t\t\t\t{ url, response: json },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new ForbiddenError(json.message, { url, response: json });\n\t\t\t}\n\n\t\t\t// Conflict\n\t\t\t// - Insert a Custom Type with same ID as an existing Custom Type\n\t\t\t// - Insert a Shared Slice with same ID as an existing Shared Slice\n\t\t\tcase 409: {\n\t\t\t\tthrow new ConflictError(\n\t\t\t\t\t\"The provided ID is already used. A unique ID must be provided.\",\n\t\t\t\t\t{ url },\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Not Found\n\t\t\t// - Get a Custom Type with no matching ID\n\t\t\t// - Get a Shared Slice with no matching ID\n\t\t\tcase 404:\n\t\t\t// Unprocessable Entity\n\t\t\t// - Update a Custom Type with no matching ID\n\t\t\t// - Update a Shared Slice with no matching ID\n\t\t\tcase 422: {\n\t\t\t\tthrow new NotFoundError(\n\t\t\t\t\t\"An entity with a matching ID could not be found.\",\n\t\t\t\t\t{ url },\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthrow new PrismicError(\"An invalid API response was returned\", { url });\n\t}\n}\n"],"names":["MissingFetchError","BulkTransaction","BulkTransactionConfirmationError","InvalidPayloadError","UnauthorizedError","BulkTransactionLimitError","ForbiddenError","ConflictError","NotFoundError","PrismicError"],"mappings":"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"}