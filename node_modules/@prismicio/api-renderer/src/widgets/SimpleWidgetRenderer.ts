import {
	isBooleanContent,
	isColorContent,
	isDateContent,
	isEmbedContent,
	isGeoPointContent,
	isImageContent,
	isIntegrationFieldContent,
	isLinkContent,
	isNumberContent,
	isRangeContent,
	isRichTextContent,
	isSelectContent,
	isSeparatorContent,
	isTextContent,
	isTimestampContent,
	isUIDContent,
	NestableContent,
} from "@prismicio/types-internal/lib/content"
import type {
	Color,
	Date as DateDef,
	NestableWidget,
	Number as NumberDef,
	Range,
	Select,
	Text,
	Timestamp,
} from "@prismicio/types-internal/lib/customtypes"

import type { RenderContext } from "../models"
import { DocRelation, DocRelationType, Field, SimpleField, SimpleFieldType } from "../models/fetch"
import { withObjectRenderers } from "../object"
import {
	BooleanRenderer,
	EmbedRenderer,
	FieldRenderer,
	GeoPointRenderer,
	ImageRenderer,
	IntegrationFieldsRenderer,
	LinkRenderer,
	SeparatorRenderer,
	StructuredTextRenderer,
} from "./nestable"
import UIDRenderer from "./UIDRenderer"

function extractSimpleFieldIfAny(field: Field | undefined): SimpleField | undefined {
	if (field !== undefined && field.TYPE === SimpleFieldType) {
		return field
	} else {
		return undefined
	}
}

function extractFetchDocRelationIfAny(field: Field | undefined): DocRelation | undefined {
	if (field !== undefined && field.TYPE === DocRelationType) {
		return field
	} else {
		return undefined
	}
}

const SimpleWidgetRenderer = (ctx: RenderContext) =>
	withObjectRenderers<NestableWidget, NestableContent, Field>({
		renderV1(content, fetch) {
			if (isRichTextContent(content)) {
				return StructuredTextRenderer(ctx).renderV1(content, extractSimpleFieldIfAny(fetch))
			} else if (isImageContent(content)) {
				return ImageRenderer(ctx).renderV1(content)
			} else if (
				// We should split the renderers of each
				isRangeContent(content) ||
				isNumberContent(content) ||
				isTimestampContent(content) ||
				isDateContent(content) ||
				isTextContent(content) ||
				isColorContent(content) ||
				isSelectContent(content)
			) {
				return FieldRenderer.renderV1(content)
			} else if (isLinkContent(content)) {
				return LinkRenderer(ctx).renderV1(content, extractFetchDocRelationIfAny(fetch))
			} else if (isEmbedContent(content)) {
				return EmbedRenderer.renderV1(content)
			} else if (isGeoPointContent(content)) {
				return GeoPointRenderer.renderV1(content)
			} else if (isUIDContent(content)) {
				return UIDRenderer.renderV1(content)
			} else if (isIntegrationFieldContent(content)) {
				return IntegrationFieldsRenderer(ctx).renderV1(content)
			} else if (isSeparatorContent(content)) {
				return SeparatorRenderer.renderV1(content)
			} else if (isBooleanContent(content)) {
				return BooleanRenderer.renderV1(content)
			} else {
				return null
			}
		},

		renderV2(def, content, fetch) {
			if (def.type === "StructuredText" && isRichTextContent(content)) {
				return StructuredTextRenderer(ctx).renderV2(def, content, extractSimpleFieldIfAny(fetch))
			} else if (def.type === "Image" && isImageContent(content)) {
				return ImageRenderer(ctx).renderV2(def, content)
			} else if (def.type === "Link" && isLinkContent(content)) {
				return LinkRenderer(ctx).renderV2(def, content, extractFetchDocRelationIfAny(fetch))
			} else if (def.type === "Embed" && isEmbedContent(content)) {
				return EmbedRenderer.renderV2(def, content)
			} else if (def.type === "GeoPoint" && isGeoPointContent(content)) {
				return GeoPointRenderer.renderV2(def, content)
			} else if (def.type === "IntegrationFields" && isIntegrationFieldContent(content)) {
				return IntegrationFieldsRenderer(ctx).renderV2(def, content)
			} else if (def.type === "Separator" && isSeparatorContent(content)) {
				return SeparatorRenderer.renderV2(def, content)
			} else if (def.type === "Boolean" && isBooleanContent(content)) {
				return BooleanRenderer.renderV2(def, content)
			} else if (
				isRangeContent(content) ||
				isNumberContent(content) ||
				isTimestampContent(content) ||
				isDateContent(content) ||
				isTextContent(content) ||
				isColorContent(content) ||
				isSelectContent(content)
			) {
				// TODO: because of an old bug, we have to cast the type here to maintain backward compatibility
				// We should check that `def.type` is matching FieldDef or fallback to the null case.
				return FieldRenderer.renderV2(def as Color | NumberDef | DateDef | Timestamp | Select | Text | Range, content)
			} else {
				return null
			}
		},

		renderDefault(def) {
			if (def.type === "Link") {
				return LinkRenderer(ctx).renderDefault(def)
			} else if (def.type === "Embed") {
				return EmbedRenderer.renderDefault(def)
			} else if (def.type === "GeoPoint") {
				return GeoPointRenderer.renderDefault(def)
			} else if (def.type === "StructuredText") {
				return StructuredTextRenderer(ctx).renderDefault(def)
			} else if (def.type === "Image") {
				return ImageRenderer(ctx).renderDefault(def)
			} else if (def.type === "Separator") {
				return SeparatorRenderer.renderDefault(def)
			} else if (def.type === "Boolean") {
				return BooleanRenderer.renderDefault(def)
			} else if (def.type === "IntegrationFields") {
				return IntegrationFieldsRenderer(ctx).renderDefault(def)
			} else {
				return FieldRenderer.renderDefault(def)
			}
		},

		renderMocks(def, content) {
			if (def.type === "StructuredText" && isRichTextContent(content)) {
				return StructuredTextRenderer(ctx).renderMocks(def, content)
			} else if (def.type === "Image" && isImageContent(content)) {
				return ImageRenderer(ctx).renderMocks(def, content)
			} else if (def.type === "Link" && isLinkContent(content)) {
				return LinkRenderer(ctx).renderMocks(def, content)
			} else if (def.type === "Embed" && isEmbedContent(content)) {
				return EmbedRenderer.renderMocks(def, content)
			} else if (def.type === "GeoPoint" && isGeoPointContent(content)) {
				return GeoPointRenderer.renderMocks(def, content)
			} else if (def.type === "IntegrationFields" && isIntegrationFieldContent(content)) {
				return IntegrationFieldsRenderer(ctx).renderMocks(def, content)
			} else if (def.type === "Separator" && isSeparatorContent(content)) {
				return SeparatorRenderer.renderMocks(def, content)
			} else if (def.type === "Boolean" && isBooleanContent(content)) {
				return BooleanRenderer.renderMocks(def, content)
			} else if (
				(isRangeContent(content) && def.type === "Range") ||
				(isNumberContent(content) && def.type === "Number") ||
				(isTimestampContent(content) && def.type === "Timestamp") ||
				(isDateContent(content) && def.type === "Date") ||
				(isTextContent(content) && def.type === "Text") ||
				(isColorContent(content) && def.type === "Color") ||
				(isSelectContent(content) && def.type === "Select")
			) {
				return FieldRenderer.renderMocks(def, content)
			} else {
				return null
			}
		},
	})

export default SimpleWidgetRenderer
