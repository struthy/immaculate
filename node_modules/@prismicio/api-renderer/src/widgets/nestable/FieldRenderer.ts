import type { FieldContent } from "@prismicio/types-internal/lib/content"
import type {
	Color,
	Date as DateDef,
	Number as NumberDef,
	Range,
	Select,
	Text,
	Timestamp,
} from "@prismicio/types-internal/lib/customtypes"

import type { Renderer } from "../../models"
import { filterDouble, formatDate, formatDateTime } from "../../utils"

type FieldDef = Color | NumberDef | DateDef | Timestamp | Select | Text | Range
const TIMESTAMP_INPUT_REGEX =
	/^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(?:(?:[+-]{1}[0-9]{2}:?[0-9]{2})|Z)$/
const DATE_INPUT_REGEX = /^(\d{1,4})-([0-9]{1,2})-([0-9]{1,2})$/
function DATE_INPUT_REFORMATER(v: RegExpExecArray): string {
	const [year, month, day] = [v[1], v[2], v[3]]
	/* eslint-disable  @typescript-eslint/no-non-null-assertion */
	return `${year!.padStart(4, "0")}-${month!.padStart(2, "0")}-${day!.padStart(2, "0")}T00:00:00.000+0000`
}

const FieldRenderer: Renderer<FieldDef, FieldContent> = {
	renderV1(content: FieldContent): unknown {
		const partialResult = { type: content.type, value: null }
		switch (content.type) {
			case "Number": {
				const number = filterDouble(content.value)
				return {
					...partialResult,
					value: number,
				}
			}
			case "Date":
				try {
					const maybeInputDate = DATE_INPUT_REGEX.exec(content.value)
					if (maybeInputDate) {
						const date = new Date(DATE_INPUT_REFORMATER(maybeInputDate))
						return {
							...partialResult,
							value: formatDate(date),
						}
					}

					return partialResult
				} catch (e) {
					console.warn(`Unable to render Date value with ${content.value}: ${(e as Error).toString()}`)
					return partialResult
				}
			case "Timestamp":
				try {
					if (TIMESTAMP_INPUT_REGEX.test(content.value)) {
						const date = new Date(content.value)
						return {
							...partialResult,
							value: formatDateTime(date),
						}
					}
					return partialResult
				} catch (e) {
					console.warn(`Unable to render Timestamp value with ${content.value}: ${(e as Error).toString()}`)
					return partialResult
				}
			default:
				return {
					...partialResult,
					value: content.value,
				}
		}
	},

	renderV2(_def: FieldDef, content: FieldContent): unknown {
		switch (content.type) {
			case "Number":
				return filterDouble(content.value)
			case "Date":
				try {
					const maybeInputDate = DATE_INPUT_REGEX.exec(content.value)
					if (maybeInputDate) {
						const date = new Date(DATE_INPUT_REFORMATER(maybeInputDate))
						return formatDate(date)
					}
					return null
				} catch (e) {
					console.warn(`Unable to render Date value with ${content.value}: ${(e as Error).toString()}`)
					return null
				}
			case "Timestamp":
				try {
					if (TIMESTAMP_INPUT_REGEX.test(content.value)) {
						const date = new Date(content.value)
						return formatDateTime(date)
					}
					return null
				} catch (e) {
					console.warn(`Unable to render Timestamp value with ${content.value}: ${(e as Error).toString()}`)
					return null
				}
			default:
				return content.value
		}
	},

	renderDefault(_def: FieldDef): unknown {
		return null
	},

	renderMocks(def: FieldDef, content: FieldContent): unknown {
		return this.renderV2(def, content)
	},
}

export default FieldRenderer
