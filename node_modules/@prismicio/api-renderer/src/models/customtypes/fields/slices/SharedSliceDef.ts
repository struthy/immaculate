import { SharedSlice, Variation } from "@prismicio/types-internal/lib/customtypes"
import { either } from "fp-ts"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import { hasType, isFieldDef, WithKey } from "../../utils"
import { GroupDef } from "../GroupDef"
import { NestableDef } from "../nestable/NestableDef"

const variationCodec = t.strict({
	id: t.string,
	primary: t.array(t.union([GroupDef, NestableDef])),
	items: t.array(NestableDef),
	version: t.string,
})

export const VariationDef = new t.Type<Variation>(
	"VariationDef",
	(u: unknown): u is Variation => hasType(u) && Variation.is(u),
	(u: unknown) => {
		return pipe(
			variationCodec.decode(u),
			either.map((v) => {
				return {
					id: v.id,
					name: v.id,
					description: v.id,
					imageUrl: "",
					docURL: "",
					version: v.version,
					primary: v.primary.reduce((acc, { key, def }) => ({ ...acc, [key]: def }), {}),
					items: v.items.reduce((acc, { key, def }) => ({ ...acc, [key]: def }), {}),
				}
			}),
		)
	},
	(v) => v,
)

const LegacyPath = t.string
const VariationId = t.string

const sliceCodec = t.intersection([
	t.strict({
		name: t.string,
		variations: t.array(VariationDef),
	}),
	t.partial({
		legacyPaths: t.record(LegacyPath, VariationId),
	}),
])

export const SharedSliceDef = new t.Type<WithKey<SharedSlice>>(
	"SharedSliceDef",
	(u: unknown): u is WithKey<SharedSlice> => isFieldDef(u) && SharedSlice.is(u.def),
	(u: unknown) => {
		return pipe(
			sliceCodec.decode(u),
			either.map(
				({ name, variations, legacyPaths }): WithKey<SharedSlice> => ({
					key: name,
					def: {
						id: name,
						name,
						type: "SharedSlice",
						variations,
						...(legacyPaths ? { legacyPaths } : {}),
					},
				}),
			),
		)
	},
	(s) => s,
)
