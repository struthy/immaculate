const DOC_SEPARATOR = "%%"
export function encodeDocId(documentId: string, maybeAdditionalData: string | undefined): string {
	return `${documentId}${DOC_SEPARATOR}${maybeAdditionalData ?? ""}`
}
export function decodeDocId(id: string, handlerType: string): [string, string?] {
	const [docId, maybeAdditionalData] = id.split(DOC_SEPARATOR)

	if (docId && maybeAdditionalData) {
		return [docId, maybeAdditionalData]
	} else if (docId) {
		return [docId]
	} else {
		throw new Error(`Unable to read from for extension ${handlerType} with encoded api key ${id}`)
	}
}

export interface IDEncoder {
	encode: (strId: string) => string
}

export function IDEncoder(prefix: string): IDEncoder {
	const BYTES_SIZE_LENGTH = 3
	return {
		encode: (strId: string): string => {
			const idLength = strId.length

			if (Buffer.byteLength(idLength.toString(), "utf8") <= BYTES_SIZE_LENGTH) {
				const length = `${idLength}`.padStart(BYTES_SIZE_LENGTH, "0") // util.format(`%0${BYTES_SIZE_LENGTH}d`, idLength)
				return prefix + length + strId
			} else {
				throw new Error(`ID is too long. Its size is ${idLength} and should be inferior to 1000`)
			}
		},
	}
}

export const IDEncoders = {
	documentLinks: IDEncoder("=&="),
	documentUrls: IDEncoder(">&<"),
	integrationFields: IDEncoder("%!%"),
}
