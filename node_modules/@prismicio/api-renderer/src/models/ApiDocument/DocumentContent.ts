import type { WidgetKey } from "@prismicio/types-internal/lib/common"
import {
	defaultCtx,
	Document,
	FieldOrSliceType,
	isSlicesContent,
	migrateDocument,
	migrateSliceItem,
	traverseSlices,
	WidgetContent,
	WidgetLegacy,
} from "@prismicio/types-internal/lib/content"
import { DocumentLegacy } from "@prismicio/types-internal/lib/content"
import { StaticSlices } from "@prismicio/types-internal/lib/customtypes"
import { isLeft, isRight } from "fp-ts/lib/Either"

import type { CustomTypeDef } from "../customtypes"

export class DocumentContent {
	fieldTypes: Map<WidgetKey, FieldOrSliceType>
	widgets: Partial<Record<WidgetKey, unknown>> = {}
	slugs: ReadonlyArray<string>
	uid: string | undefined
	customType?: CustomTypeDef | undefined

	// cached parsed Widgets
	// TODO: should use memoization in parseAll and get rid of this
	private parsed: Document = {}

	constructor(data: { [p: string]: unknown }, customType?: CustomTypeDef | undefined) {
		const { widgets, types, slugs, uid } = DocumentLegacy.extractMetadata(data)
		this.fieldTypes = types
		this.slugs = slugs
		this.uid = uid
		this.widgets = widgets
		this.customType = customType
	}

	getWidget(key: string): WidgetContent | undefined {
		const cachedWidget = this.parsed[key]
		if (cachedWidget) return cachedWidget

		const unparsedWidget = this.widgets[key]
		const parsedWidget = (() => {
			const parsed = WidgetLegacy(defaultCtx(key, this.fieldTypes)).decode(unparsedWidget)

			if (!parsed || isLeft(parsed)) return
			if (!this.customType) return parsed.right

			const fieldDef = this.customType.fields[key]
			// apply the slice migration in case we match a slicezone.
			if (isSlicesContent(parsed.right) && StaticSlices.is(fieldDef)) {
				return traverseSlices({
					path: [
						{ key: this.customType.customTypeId, type: "CustomType" },
						{ key, type: "Widget" },
					],
					key,
					model: fieldDef,
					content: parsed.right,
				})({
					transformSlice: migrateSliceItem,
				})
			}

			return parsed.right
		})()

		if (!parsedWidget) return
		this.parsed[key] = parsedWidget
		return parsedWidget
	}

	parseAll(): Document {
		const parsed = DocumentLegacy._codec(this.fieldTypes).decode(this.widgets)
		const result = isRight(parsed) ? parsed.right : {}
		// This should not happen but we don't want to break the API in case something is missing, worst case we just don't apply the migration
		const migratedResult = this.customType ? migrateDocument(result, this.customType) : result
		this.parsed = migratedResult
		return migratedResult
	}
}
