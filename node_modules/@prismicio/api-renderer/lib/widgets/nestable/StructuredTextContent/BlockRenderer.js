"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const content_1 = require("@prismicio/types-internal/lib/content");
const E = tslib_1.__importStar(require("fp-ts/lib/Either"));
const models_1 = require("../../../models");
const models_2 = require("../../../models");
const utils_1 = require("../../../utils");
const Link_1 = tslib_1.__importDefault(require("../Link"));
function linkType(link) {
    if ((0, content_1.isLinkContent)(link)) {
        switch (link.value.__TYPE__) {
            case "DocumentLink":
                return "document";
            case "ExternalLink":
                return "web";
            case "FileLink":
                return "media";
            case "ImageLink":
                return "media";
            default:
                return null;
        }
    }
    throw new Error(`[UNREACHABLE] unknown Link type for ${JSON.stringify(link)}`);
}
function renderStructuredTextLink(link, apiVersion, ctx) {
    if (apiVersion === models_1.ApiVersion.v1) {
        return (0, Link_1.default)(ctx).renderV1(link, undefined);
    }
    else if (apiVersion === models_1.ApiVersion.v2) {
        return (0, Link_1.default)(ctx).renderV2((0, models_2.defaultLink)(linkType(link)), link, undefined);
    }
    else if (apiVersion === models_1.ApiVersion.mocks) {
        return (0, Link_1.default)(ctx).renderMocks((0, models_2.defaultLink)(linkType(link)), link);
    }
}
const BlockRenderer = (ctx) => ({
    renderBlock(block) {
        return (apiVersion) => {
            if ((0, content_1.checkImageBlock)(block)) {
                const linkTo = (() => {
                    if (block.data.linkTo) {
                        const content = {
                            __TYPE__: "LinkContent",
                            value: block.data.linkTo,
                        };
                        return {
                            linkTo: renderStructuredTextLink(content, apiVersion, ctx),
                        };
                    }
                    return {};
                })();
                const label = block.label ? { label: block.label } : {};
                const direction = block.direction ? { direction: block.direction } : {};
                const contentV2 = apiVersion === models_1.ApiVersion.v2
                    ? {
                        id: block.data.origin.id,
                        edit: {
                            x: block.data.edit.crop.x,
                            y: block.data.edit.crop.y,
                            zoom: block.data.edit.zoom,
                            background: block.data.edit.background,
                        },
                    }
                    : {};
                return {
                    type: "image",
                    url: ctx.urlRewriter.rewriteImageUrl(block.data),
                    alt: (0, utils_1.writeEmptyStringOrNull)(block.data.alt, ctx.emptyStringInsteadOfNull),
                    copyright: (0, utils_1.writeEmptyStringOrNull)(block.data.credits, ctx.emptyStringInsteadOfNull),
                    dimensions: {
                        width: block.data.width,
                        height: block.data.height,
                    },
                    ...contentV2,
                    ...linkTo,
                    ...label,
                    ...direction,
                };
            }
            else if ((0, content_1.checkEmbedBlock)(block)) {
                const label = block.label ? { label: block.label } : {};
                const direction = block.direction ? { direction: block.direction } : {};
                return {
                    type: "embed",
                    oembed: block.data.all,
                    ...label,
                    ...direction,
                };
            }
            else {
                // TextBlock
                const label = block.label ? { label: block.label } : {};
                const direction = block.direction ? { direction: block.direction } : {};
                const spans = (block.content.spans || []).map((m) => {
                    const partial = {
                        start: m.start,
                        end: m.end,
                        type: m.type,
                    };
                    if (m.type === "hyperlink") {
                        const asMaybeLink = content_1.Link.decode(m.data);
                        const asLink = (() => {
                            if (E.isRight(asMaybeLink)) {
                                const content = {
                                    __TYPE__: "LinkContent",
                                    value: asMaybeLink.right,
                                };
                                return renderStructuredTextLink(content, apiVersion, ctx);
                            }
                            return {};
                        })();
                        return {
                            ...partial,
                            data: asLink,
                        };
                    }
                    else if (m.type === "label") {
                        return {
                            ...partial,
                            data: { label: typeof m.data === "string" ? m.data : "" },
                        };
                    }
                    else {
                        return partial;
                    }
                });
                return {
                    type: block.type,
                    text: block.content.text,
                    ...label,
                    spans,
                    ...direction,
                };
            }
        };
    },
});
exports.default = BlockRenderer;
