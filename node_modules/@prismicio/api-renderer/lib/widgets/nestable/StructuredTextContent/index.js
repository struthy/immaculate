"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const function_1 = require("fp-ts/lib/function");
const O = tslib_1.__importStar(require("fp-ts/lib/Option"));
const models_1 = require("../../../models");
const BlockRenderer_1 = tslib_1.__importDefault(require("./BlockRenderer"));
function renderSummaryJson(text, renderer) {
    const firstBlock = (0, function_1.pipe)(O.fromNullable(text.value.find((block) => block.type.startsWith("heading"))), O.alt(() => O.fromNullable(text.value.find((block) => block.type !== "embed" && block.type !== "image"))), O.map((block) => [block]), O.getOrElse(() => []));
    return renderer({
        __TYPE__: "StructuredTextContent",
        value: firstBlock,
    });
}
const StructuredTextRenderer = (ctx) => ({
    renderV1(content, fetch) {
        //TODO: factorize that
        const renderedBlocks = content.value.map((block) => (0, BlockRenderer_1.default)(ctx).renderBlock(block)(models_1.ApiVersion.v1));
        if (fetch !== undefined && fetch.legacy) {
            return renderSummaryJson(content, (text) => text.value.map((block) => (0, BlockRenderer_1.default)(ctx).renderBlock(block)(models_1.ApiVersion.v1)));
        }
        return {
            type: "StructuredText",
            value: renderedBlocks,
        };
    },
    renderV2(def, content, fetch) {
        if (fetch != undefined && fetch.legacy) {
            return renderSummaryJson(content, (text) => this.renderV2(def, text, undefined));
        }
        return content.value.map((block) => (0, BlockRenderer_1.default)(ctx).renderBlock(block)(models_1.ApiVersion.v2));
    },
    renderDefault(_def) {
        return [];
    },
    renderMocks(_def, content) {
        return content.value.map((block) => (0, BlockRenderer_1.default)(ctx).renderBlock(block)(models_1.ApiVersion.mocks));
    },
});
exports.default = StructuredTextRenderer;
