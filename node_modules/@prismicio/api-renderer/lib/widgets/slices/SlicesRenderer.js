"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const content_1 = require("@prismicio/types-internal/lib/content");
const function_1 = require("fp-ts/function");
const Array_1 = require("fp-ts/lib/Array");
const O = tslib_1.__importStar(require("fp-ts/Option"));
const uuid_1 = require("uuid");
const utils_1 = require("../../utils");
const SliceWidgetRenderer_1 = tslib_1.__importDefault(require("./SliceWidgetRenderer"));
function sliceId(sliceKey, sliceName) {
    const IdRegexp = new RegExp(`^(${sliceName})\\$\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}$`);
    if (sliceKey.match(IdRegexp))
        return sliceKey;
    return `${sliceName}$${(0, uuid_1.v4)()}`;
}
function renderItemAndFilterOutEmptyOne(slicesContent, sliceFetch, ctx) {
    const fetchRecord = sliceFetch === null || sliceFetch === void 0 ? void 0 : sliceFetch.slices;
    return (0, Array_1.compact)(slicesContent.value.map((item) => {
        return (0, function_1.pipe)((0, utils_1.renderIfNoFetchOrFetchDefined)(fetchRecord, item.key, (f) => (0, SliceWidgetRenderer_1.default)(ctx).renderV1(item.widget, f)), //TODO: add fetch
        O.map((renderedItem) => [item, renderedItem]));
    }));
}
function renderContent(slice, sliceFetch, ctx, slicesDefs) {
    if ("__TYPE__" in slice.widget && slice.widget.__TYPE__ === content_1.EmptyContentType) {
        return O.none;
    }
    else if (!(slice.name in slicesDefs)) {
        return O.none;
    }
    else {
        const def = slicesDefs[slice.name];
        if (!def)
            return O.none;
        return (0, function_1.pipe)((0, SliceWidgetRenderer_1.default)(ctx).renderV2(def, slice.widget, sliceFetch), O.map((render) => {
            var _a;
            return ({
                //TODO: clean type here, must case because of unknown coming from the renderer
                ...render,
                id: sliceId(slice.key, slice.name),
                slice_type: slice.name,
                slice_label: (_a = slice.maybeLabel) !== null && _a !== void 0 ? _a : null,
            });
        }));
    }
}
const SlicesRenderer = (ctx) => ({
    renderV1(content, fetch) {
        return {
            type: "SliceZone",
            value: renderItemAndFilterOutEmptyOne(content, fetch, ctx).map(([item, renderedItem]) => {
                var _a;
                return {
                    ...renderedItem,
                    id: sliceId(item.key, item.name),
                    slice_type: item.name,
                    slice_label: (_a = item.maybeLabel) !== null && _a !== void 0 ? _a : null,
                    type: "Slice",
                };
            }),
        };
    },
    renderV2(def, content, fetch) {
        var _a;
        const keyToSliceDef = Object.fromEntries(Object.entries(((_a = def.config) === null || _a === void 0 ? void 0 : _a.choices) || {}).map(([name, slice]) => [name, slice]));
        const fetchRecord = fetch === null || fetch === void 0 ? void 0 : fetch.slices;
        return (0, Array_1.compact)(content.value.map((contentValue) => {
            return (0, utils_1.renderIfNoFetchOrFetchDefined)(fetchRecord, contentValue.name, (f) => renderContent(contentValue, f, ctx, keyToSliceDef));
        }));
    },
    renderDefault(_def) {
        return [];
    },
    renderMocks(def, content) {
        return this.renderV2(def, content);
    },
});
exports.default = SlicesRenderer;
