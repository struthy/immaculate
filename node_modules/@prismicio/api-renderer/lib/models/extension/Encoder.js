"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IDEncoders = exports.IDEncoder = exports.decodeDocId = exports.encodeDocId = void 0;
const DOC_SEPARATOR = "%%";
function encodeDocId(documentId, maybeAdditionalData) {
    return `${documentId}${DOC_SEPARATOR}${maybeAdditionalData !== null && maybeAdditionalData !== void 0 ? maybeAdditionalData : ""}`;
}
exports.encodeDocId = encodeDocId;
function decodeDocId(id, handlerType) {
    const [docId, maybeAdditionalData] = id.split(DOC_SEPARATOR);
    if (docId && maybeAdditionalData) {
        return [docId, maybeAdditionalData];
    }
    else if (docId) {
        return [docId];
    }
    else {
        throw new Error(`Unable to read from for extension ${handlerType} with encoded api key ${id}`);
    }
}
exports.decodeDocId = decodeDocId;
function IDEncoder(prefix) {
    const BYTES_SIZE_LENGTH = 3;
    return {
        encode: (strId) => {
            const idLength = strId.length;
            if (Buffer.byteLength(idLength.toString(), "utf8") <= BYTES_SIZE_LENGTH) {
                const length = `${idLength}`.padStart(BYTES_SIZE_LENGTH, "0"); // util.format(`%0${BYTES_SIZE_LENGTH}d`, idLength)
                return prefix + length + strId;
            }
            else {
                throw new Error(`ID is too long. Its size is ${idLength} and should be inferior to 1000`);
            }
        },
    };
}
exports.IDEncoder = IDEncoder;
exports.IDEncoders = {
    documentLinks: IDEncoder("=&="),
    documentUrls: IDEncoder(">&<"),
    integrationFields: IDEncoder("%!%"),
};
