"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractSliceFetchIfAny = exports.extractGroupOrFieldIfAny = exports.DocRelationType = exports.Docs = exports.Doc = exports.DocType = exports.Simple = exports.DocRelationC = exports.GroupType = exports.Slice = exports.SharedSlice = exports.SharedSliceType = exports.CompositeSlice = exports.CompositeSliceType = exports.VariationC = exports.SliceZone = exports.SliceZoneType = exports.FieldC = exports.GroupOrFieldC = exports.Group = exports.SimpleField = exports.SimpleFieldType = void 0;
const tslib_1 = require("tslib");
const t = tslib_1.__importStar(require("io-ts"));
exports.SimpleFieldType = "SimpleField";
exports.SimpleField = t.strict({
    TYPE: t.literal(exports.SimpleFieldType),
    name: t.string,
    legacy: t.boolean,
});
exports.Group = t.recursion("Group", () => t.strict({
    TYPE: t.literal(exports.GroupType),
    name: t.string,
    fields: t.record(t.string, exports.GroupOrFieldC),
}));
exports.GroupOrFieldC = t.recursion("GroupOrField", () => t.union([exports.Simple, exports.Group]));
exports.FieldC = t.recursion("Field", () => t.union([exports.GroupOrFieldC, exports.SliceZone]));
exports.SliceZoneType = "SliceZone";
exports.SliceZone = t.recursion("SliceZone", () => t.strict({
    TYPE: t.literal(exports.SliceZoneType),
    name: t.string,
    slices: t.record(t.string, t.union([exports.GroupOrFieldC, exports.Slice])),
}));
exports.VariationC = t.recursion("Variation", () => t.strict({
    TYPE: t.literal("Variation"),
    nonRepeat: t.strict({
        fields: t.record(t.string, exports.GroupOrFieldC),
    }),
    repeat: t.strict({
        fields: t.record(t.string, exports.FieldC),
    }),
}));
exports.CompositeSliceType = "CompositeSlice";
exports.CompositeSlice = t.strict({
    TYPE: t.literal(exports.CompositeSliceType),
    nonRepeat: t.strict({
        fields: t.record(t.string, exports.GroupOrFieldC),
        TYPE: t.literal("NonRepeat"),
    }),
    repeat: t.strict({
        fields: t.record(t.string, exports.GroupOrFieldC),
        TYPE: t.literal("Repeat"),
    }),
});
exports.SharedSliceType = "SharedSlice";
exports.SharedSlice = t.strict({
    TYPE: t.literal(exports.SharedSliceType),
    variations: t.record(t.string, exports.VariationC),
});
exports.Slice = t.union([exports.SharedSlice, exports.CompositeSlice]);
exports.GroupType = "Group";
exports.DocRelationC = t.recursion("DocRelation", () => {
    return t.strict({
        TYPE: t.literal(exports.DocRelationType),
        name: t.string,
        uuid: t.string,
        fields: t.record(t.string, t.record(t.string, exports.FieldC)),
    });
});
exports.Simple = t.union([exports.DocRelationC, exports.SimpleField]);
exports.DocType = "Doc";
exports.Doc = t.recursion("Field", () => t.strict({
    TYPE: t.literal("Doc"),
    typ: t.string,
    fields: t.record(t.string, exports.FieldC),
}));
exports.Docs = t.recursion("Field", () => 
// TODO: handle proper typing for this kind of recursive codec
/* eslint-disable  @typescript-eslint/ban-ts-comment */
// @ts-ignore
t.strict({
    docs: t.record(t.string, t.union([exports.DocRelationC, exports.SimpleField, exports.Group, exports.SliceZone])),
    docRelationsMap: t.record(t.string, exports.DocRelationC),
}));
exports.DocRelationType = "DocRelation";
function extractGroupOrFieldIfAny(fetchOpt) {
    if (fetchOpt !== undefined &&
        (fetchOpt.TYPE === exports.SimpleFieldType || fetchOpt.TYPE === exports.DocRelationType || fetchOpt.TYPE === exports.GroupType)) {
        return fetchOpt;
    }
    else {
        return undefined;
    }
}
exports.extractGroupOrFieldIfAny = extractGroupOrFieldIfAny;
function extractSliceFetchIfAny(fetchOpt) {
    if (fetchOpt !== undefined && fetchOpt.TYPE === exports.SliceZoneType) {
        return fetchOpt;
    }
    return undefined;
}
exports.extractSliceFetchIfAny = extractSliceFetchIfAny;
