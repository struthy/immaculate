import * as t from "io-ts";
export declare const SimpleFieldType = "SimpleField";
export declare const SimpleField: t.ExactC<t.TypeC<{
    TYPE: t.LiteralC<"SimpleField">;
    name: t.StringC;
    legacy: t.BooleanC;
}>>;
export type SimpleField = t.TypeOf<typeof SimpleField>;
export interface Group {
    TYPE: typeof GroupType;
    name: string;
    fields: {
        [key: string]: GroupOrField;
    };
}
export declare const Group: t.Type<Group>;
export type GroupOrField = Simple | Group;
export declare const GroupOrFieldC: t.Type<GroupOrField>;
export type Field = GroupOrField | SliceZone;
export declare const FieldC: t.Type<Field>;
export declare const SliceZoneType = "SliceZone";
export interface SliceZone {
    TYPE: typeof SliceZoneType;
    name: string;
    slices: {
        [key: string]: GroupOrField | Slice;
    };
}
export declare const SliceZone: t.Type<SliceZone>;
export interface Variation {
    TYPE: "Variation";
    nonRepeat: {
        fields: {
            [key: string]: GroupOrField;
        };
    };
    repeat: {
        fields: {
            [key: string]: Field;
        };
    };
}
export declare const VariationC: t.Type<Variation>;
export declare const CompositeSliceType = "CompositeSlice";
export declare const CompositeSlice: t.ExactC<t.TypeC<{
    TYPE: t.LiteralC<"CompositeSlice">;
    nonRepeat: t.ExactC<t.TypeC<{
        fields: t.RecordC<t.StringC, t.Type<GroupOrField, GroupOrField, unknown>>;
        TYPE: t.LiteralC<"NonRepeat">;
    }>>;
    repeat: t.ExactC<t.TypeC<{
        fields: t.RecordC<t.StringC, t.Type<GroupOrField, GroupOrField, unknown>>;
        TYPE: t.LiteralC<"Repeat">;
    }>>;
}>>;
export type CompositeSlice = t.TypeOf<typeof CompositeSlice>;
export declare const SharedSliceType = "SharedSlice";
export declare const SharedSlice: t.ExactC<t.TypeC<{
    TYPE: t.LiteralC<"SharedSlice">;
    variations: t.RecordC<t.StringC, t.Type<Variation, Variation, unknown>>;
}>>;
export type SharedSlice = t.TypeOf<typeof SharedSlice>;
export declare const Slice: t.UnionC<[t.ExactC<t.TypeC<{
    TYPE: t.LiteralC<"SharedSlice">;
    variations: t.RecordC<t.StringC, t.Type<Variation, Variation, unknown>>;
}>>, t.ExactC<t.TypeC<{
    TYPE: t.LiteralC<"CompositeSlice">;
    nonRepeat: t.ExactC<t.TypeC<{
        fields: t.RecordC<t.StringC, t.Type<GroupOrField, GroupOrField, unknown>>;
        TYPE: t.LiteralC<"NonRepeat">;
    }>>;
    repeat: t.ExactC<t.TypeC<{
        fields: t.RecordC<t.StringC, t.Type<GroupOrField, GroupOrField, unknown>>;
        TYPE: t.LiteralC<"Repeat">;
    }>>;
}>>]>;
export type Slice = t.TypeOf<typeof Slice>;
export declare const GroupType = "Group";
export interface DocRelation {
    TYPE: typeof DocRelationType;
    name: string;
    uuid: string;
    fields: {
        [keyA: string]: {
            [keyB: string]: Field;
        };
    };
}
export declare const DocRelationC: t.Type<DocRelation>;
export type Simple = DocRelation | SimpleField;
export declare const Simple: t.UnionC<[t.Type<DocRelation, DocRelation, unknown>, t.ExactC<t.TypeC<{
    TYPE: t.LiteralC<"SimpleField">;
    name: t.StringC;
    legacy: t.BooleanC;
}>>]>;
export declare const DocType = "Doc";
export interface Doc {
    TYPE: typeof DocType;
    typ: string;
    fields: Record<string, Field>;
}
export declare const Doc: t.Type<Doc>;
export declare const Docs: t.RecursiveType<t.Type<unknown, unknown, unknown>, unknown, unknown, unknown>;
export type Docs = t.TypeOf<typeof Docs>;
export declare const DocRelationType = "DocRelation";
export declare function extractGroupOrFieldIfAny(fetchOpt: Field | undefined): GroupOrField | undefined;
export declare function extractSliceFetchIfAny(fetchOpt: Field | undefined): SliceZone | undefined;
