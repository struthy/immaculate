"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentContent = void 0;
const content_1 = require("@prismicio/types-internal/lib/content");
const content_2 = require("@prismicio/types-internal/lib/content");
const customtypes_1 = require("@prismicio/types-internal/lib/customtypes");
const Either_1 = require("fp-ts/lib/Either");
class DocumentContent {
    constructor(data, customType) {
        Object.defineProperty(this, "fieldTypes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "widgets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "slugs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "uid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "customType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // cached parsed Widgets
        // TODO: should use memoization in parseAll and get rid of this
        Object.defineProperty(this, "parsed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        const { widgets, types, slugs, uid } = content_2.DocumentLegacy.extractMetadata(data);
        this.fieldTypes = types;
        this.slugs = slugs;
        this.uid = uid;
        this.widgets = widgets;
        this.customType = customType;
    }
    getWidget(key) {
        const cachedWidget = this.parsed[key];
        if (cachedWidget)
            return cachedWidget;
        const unparsedWidget = this.widgets[key];
        const parsedWidget = (() => {
            const parsed = (0, content_1.WidgetLegacy)((0, content_1.defaultCtx)(key, this.fieldTypes)).decode(unparsedWidget);
            if (!parsed || (0, Either_1.isLeft)(parsed))
                return;
            if (!this.customType)
                return parsed.right;
            const fieldDef = this.customType.fields[key];
            // apply the slice migration in case we match a slicezone.
            if ((0, content_1.isSlicesContent)(parsed.right) && customtypes_1.StaticSlices.is(fieldDef)) {
                return (0, content_1.traverseSlices)({
                    path: [
                        { key: this.customType.customTypeId, type: "CustomType" },
                        { key, type: "Widget" },
                    ],
                    key,
                    model: fieldDef,
                    content: parsed.right,
                })({
                    transformSlice: content_1.migrateSliceItem,
                });
            }
            return parsed.right;
        })();
        if (!parsedWidget)
            return;
        this.parsed[key] = parsedWidget;
        return parsedWidget;
    }
    parseAll() {
        const parsed = content_2.DocumentLegacy._codec(this.fieldTypes).decode(this.widgets);
        const result = (0, Either_1.isRight)(parsed) ? parsed.right : {};
        // This should not happen but we don't want to break the API in case something is missing, worst case we just don't apply the migration
        const migratedResult = this.customType ? (0, content_1.migrateDocument)(result, this.customType) : result;
        this.parsed = migratedResult;
        return migratedResult;
    }
}
exports.DocumentContent = DocumentContent;
