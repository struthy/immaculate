"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const content_1 = require("@prismicio/types-internal/lib/content");
const customtypes_1 = require("@prismicio/types-internal/lib/customtypes");
const models_1 = require("./models");
const utils_1 = require("./utils");
const widgets_1 = require("./widgets");
const SlicesRenderer_1 = tslib_1.__importDefault(require("./widgets/slices/SlicesRenderer"));
const DEPRECATED_ARRAY_REGEX = /(\w+)\[\d+]/;
function isStaticWidgetContent(content) {
    return (0, content_1.isGroupContent)(content) || (0, content_1.isNestableContent)(content);
}
function i18nWriter(doc) {
    const result = {
        id: doc.id,
        type: doc.typ,
        lang: doc.language,
    };
    if (doc.uid) {
        return {
            ...result,
            uid: doc.uid,
        };
    }
    return result;
}
function renderWidgetV1(ctx) {
    return (content, fetchOpt) => {
        if ((0, content_1.isEmptyContent)(content)) {
            return undefined;
        }
        else if ((0, content_1.isUIDContent)(content)) {
            return widgets_1.UIDRenderer.renderV1(content);
        }
        else if (isStaticWidgetContent(content) && !content_1.EmptyContent.is(content)) {
            return (0, widgets_1.StaticWidgetRenderer)(ctx).renderV1(content, models_1.Fetch.extractGroupOrFieldIfAny(fetchOpt));
        }
        else {
            return (0, SlicesRenderer_1.default)(ctx).renderV1(content, models_1.Fetch.extractSliceFetchIfAny(fetchOpt));
        }
    };
}
function renderWidgetsV1(ctx) {
    return (doc, content, fetch) => {
        const renderedContent = {};
        for (const [key, widgetContent] of content) {
            if (!(0, content_1.isUIDContent)(widgetContent)) {
                const deprecatedArray = key.match(DEPRECATED_ARRAY_REGEX);
                const isDeprecatedArray = deprecatedArray && deprecatedArray[1];
                // we cast to string since the TS compiler doesn't understand than if `deprecatedArray` exists, the regexp matched so `deprecatedArray[1]` is defined.
                const newKey = (isDeprecatedArray ? deprecatedArray[1] : key);
                const maybeContent = isDeprecatedArray ? renderedContent[newKey] : undefined;
                if (fetch !== undefined) {
                    const field = fetch.fields[key];
                    if (field !== undefined) {
                        if (isDeprecatedArray) {
                            renderedContent[newKey] = Array.isArray(maybeContent)
                                ? [...maybeContent, renderWidgetV1(ctx)(widgetContent, field)]
                                : [renderWidgetV1(ctx)(widgetContent, field)];
                        }
                        else {
                            renderedContent[newKey] = renderWidgetV1(ctx)(widgetContent, field);
                        }
                    }
                }
                else {
                    if (isDeprecatedArray) {
                        renderedContent[newKey] = Array.isArray(maybeContent)
                            ? [...maybeContent, renderWidgetV1(ctx)(widgetContent, undefined)]
                            : [renderWidgetV1(ctx)(widgetContent, undefined)];
                    }
                    else {
                        renderedContent[newKey] = renderWidgetV1(ctx)(widgetContent, undefined);
                    }
                }
            }
        }
        return { [doc.type]: renderedContent };
    };
}
function renderV1(ctx) {
    return (doc, content, masterLang, searchURL, i18n, withMeta, brokenRoute, linkResolver, fetchDoc) => {
        var _a, _b;
        const relatedDocs = (i18n[doc.groupLangId] || [])
            .filter((relatedDocument) => relatedDocument.id !== doc.id)
            .map((relatedDocument) => i18nWriter(relatedDocument));
        const widgets = renderWidgetsV1(ctx)(doc, content, fetchDoc);
        return {
            id: doc.id,
            uid: (_a = doc.data.uid) !== null && _a !== void 0 ? _a : null,
            url: (_b = ctx.LinkResolver.buildUrl({
                linkResolver: linkResolver,
                pageType: doc.type,
                masterLang,
                brokenRoute,
                doc,
            })) !== null && _b !== void 0 ? _b : null,
            type: doc.type,
            href: ctx.urlRewriter.enforceCDN(searchURL),
            tags: doc.tags,
            first_publication_date: doc.first_publication_date ? (0, utils_1.formatDateTime)(doc.first_publication_date) : null,
            last_publication_date: doc.last_publication_date ? (0, utils_1.formatDateTime)(doc.last_publication_date) : null,
            slugs: doc.data.slugs,
            linked_documents: [],
            lang: doc.language,
            alternate_languages: relatedDocs,
            data: widgets,
            ...(withMeta ? doc.metadata : {}),
        };
    };
}
function renderWidgetV2(ctx) {
    return (mask, content, fetchOpt) => {
        if ((0, content_1.isSlicesContent)(content) && mask.type === "Slices") {
            return (0, SlicesRenderer_1.default)(ctx).renderV2(mask, content, models_1.Fetch.extractSliceFetchIfAny(fetchOpt));
        }
        else if ((0, content_1.isGroupContent)(content) && mask.type === "Group") {
            return (0, widgets_1.StaticWidgetRenderer)(ctx).renderV2(mask, content, models_1.Fetch.extractGroupOrFieldIfAny(fetchOpt));
        }
        else if ((0, content_1.isUIDContent)(content) && mask.type === "UID") {
            return widgets_1.UIDRenderer.renderV2(mask, content);
        }
        else if ((0, content_1.isNestableContent)(content) && customtypes_1.NestableWidget.is(mask)) {
            return (0, widgets_1.StaticWidgetRenderer)(ctx).renderV2(mask, content, models_1.Fetch.extractGroupOrFieldIfAny(fetchOpt));
        }
        else {
            return renderDefaultWidget(ctx)(mask);
        }
    };
}
function renderV2(ctx) {
    return (mask, doc, masterLang, content, searchURL, i18n, withMeta, brokenRoute, linkResolver, fetchDoc) => {
        var _a, _b;
        const widgets = Object.entries(mask.fields)
            .map(([apiId, widgetDef]) => {
            if (widgetDef.type === "UID")
                return;
            const correspondingContent = content.find(([id]) => id === apiId);
            const fetchField = fetchDoc === null || fetchDoc === void 0 ? void 0 : fetchDoc.fields[apiId];
            const deprecatedArray = apiId.match(DEPRECATED_ARRAY_REGEX);
            const isDeprecatedArray = Boolean(deprecatedArray && deprecatedArray[1]);
            const newKey = (isDeprecatedArray ? deprecatedArray[1] : apiId);
            if (correspondingContent) {
                const [, contentValue] = correspondingContent;
                if ((0, content_1.isUIDContent)(contentValue))
                    return;
                if (fetchDoc === undefined || fetchField !== undefined) {
                    return [newKey, renderWidgetV2(ctx)(widgetDef, contentValue, fetchField), isDeprecatedArray];
                }
                else {
                    return undefined;
                }
            }
            else {
                //TODO: not sure about that
                if (fetchDoc === undefined || fetchField !== undefined) {
                    return [newKey, renderDefaultWidget(ctx)(widgetDef), isDeprecatedArray];
                }
                else {
                    return undefined;
                }
            }
        })
            .reduce((acc, maybeWidget) => {
            if (maybeWidget) {
                const [key, widget, isDeprecatedArray] = maybeWidget;
                if (isDeprecatedArray) {
                    const maybeContent = acc[key];
                    if (maybeContent) {
                        if (Array.isArray(maybeContent)) {
                            return {
                                ...acc,
                                [key]: [...maybeContent, widget],
                            };
                        }
                        else {
                            throw new Error(`[UNEXPECTED ERROR] ${JSON.stringify(maybeContent)} should be an Array`);
                        }
                    }
                    return {
                        ...acc,
                        [key]: [widget],
                    };
                }
                return {
                    ...acc,
                    [key]: widget,
                };
            }
            return acc;
        }, {});
        const relatedDocs = (i18n[doc.groupLangId] || [])
            .filter((relatedDocument) => relatedDocument.id !== doc.id)
            .map((relatedDocument) => i18nWriter(relatedDocument));
        return {
            id: doc.id,
            uid: (_a = doc.data.uid) !== null && _a !== void 0 ? _a : null,
            url: (_b = ctx.LinkResolver.buildUrl({
                linkResolver: linkResolver,
                pageType: doc.type,
                masterLang,
                brokenRoute,
                doc,
            })) !== null && _b !== void 0 ? _b : null,
            type: doc.type,
            href: ctx.urlRewriter.enforceCDN(searchURL),
            tags: doc.tags,
            first_publication_date: doc.first_publication_date ? (0, utils_1.formatDateTime)(doc.first_publication_date) : null,
            last_publication_date: doc.last_publication_date ? (0, utils_1.formatDateTime)(doc.last_publication_date) : null,
            slugs: doc.data.slugs,
            linked_documents: [],
            lang: doc.language,
            alternate_languages: relatedDocs,
            data: widgets,
            ...(withMeta ? doc.metadata : {}),
        };
    };
}
function renderWidgetMocks(ctx) {
    return (mask, content) => {
        if (content.__TYPE__ === "SliceContentType" && mask.type === "Slices") {
            return (0, SlicesRenderer_1.default)(ctx).renderMocks(mask, content);
        }
        else if ((0, content_1.isGroupContent)(content) && mask.type === "Group") {
            return (0, widgets_1.StaticWidgetRenderer)(ctx).renderMocks(mask, content);
        }
        else if ((0, content_1.isNestableContent)(content) && customtypes_1.NestableWidget.is(mask)) {
            return (0, widgets_1.StaticWidgetRenderer)(ctx).renderMocks(mask, content);
        }
        else {
            return renderDefaultWidget(ctx)(mask);
        }
    };
}
function renderMocks(ctx) {
    return (mask, content) => {
        const uid = content.reduce((_acc, [, widget]) => {
            if (content_1.UIDContent.is(widget))
                return widget.value;
            return;
        }, undefined);
        const widgets = Object.entries(mask.fields)
            .map(([apiId, widgetDef]) => {
            if (widgetDef.type === "UID")
                return;
            const correspondingContent = content.find(([id]) => id === apiId);
            const deprecatedArray = apiId.match(DEPRECATED_ARRAY_REGEX);
            const isDeprecatedArray = Boolean(deprecatedArray && deprecatedArray[1]);
            const newKey = (isDeprecatedArray ? deprecatedArray[1] : apiId);
            if (correspondingContent) {
                return [newKey, renderWidgetMocks(ctx)(widgetDef, correspondingContent[1]), isDeprecatedArray];
            }
            else {
                return [newKey, renderDefaultWidget(ctx)(widgetDef), isDeprecatedArray];
            }
        })
            .reduce((acc, maybeWidget) => {
            if (maybeWidget) {
                const [key, widget, isDeprecatedArray] = maybeWidget;
                if (isDeprecatedArray) {
                    const maybeContent = acc[key];
                    if (maybeContent) {
                        if (Array.isArray(maybeContent)) {
                            return {
                                ...acc,
                                [key]: [...maybeContent, widget],
                            };
                        }
                        else {
                            throw new Error(`[UNEXPECTED ERROR] ${JSON.stringify(maybeContent)} should be an Array`);
                        }
                    }
                    return {
                        ...acc,
                        [key]: [widget],
                    };
                }
                return {
                    ...acc,
                    [key]: widget,
                };
            }
            return acc;
        }, {});
        return {
            id: "mock-doc-id",
            uid,
            url: uid ? `/${uid}` : null,
            type: mask.customTypeId,
            href: null,
            tags: [],
            first_publication_date: "1970-01-01T00:00:01+0000",
            last_publication_date: "1970-01-01T00:00:01+0000",
            slugs: [],
            linked_documents: [],
            lang: "en-us",
            alternate_languages: [],
            data: widgets,
        };
    };
}
function renderDefaultWidget(ctx) {
    return (widgetDef) => {
        switch (widgetDef.type) {
            case "Choice":
            case "Slices":
                return (0, SlicesRenderer_1.default)(ctx).renderDefault(widgetDef);
            case "UID":
                return;
            default:
                return (0, widgets_1.StaticWidgetRenderer)(ctx).renderDefault(widgetDef);
        }
    };
}
const DocumentRenderer = (ctx) => {
    return {
        renderV1: renderV1(ctx),
        renderWidgetV1: renderWidgetV1(ctx),
        renderWidgetV2: renderWidgetV2(ctx),
        renderV2: renderV2(ctx),
        renderMocks: renderMocks(ctx),
        renderDefaultWidget: renderDefaultWidget(ctx),
    };
};
exports.default = DocumentRenderer;
