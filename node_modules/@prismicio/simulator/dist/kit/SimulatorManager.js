var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { throttle } from "../lib/throttle.js";
import { ClientRequestType } from "../types.js";
import { StateEventType } from "./types.js";
import { SimulatorAPI } from "../SimulatorAPI.js";
import { ResponseError } from "../channel/errors.js";
import "statuses";
import "../channel/types.js";
import { State } from "./State.js";
import { getSliceZoneDOM, getSimulatorDOM, getSimulatorRootDOM } from "./domHelpers.js";
import { sliceSimulatorAccessedDirectly } from "./messages.js";
class SimulatorManager {
  constructor(args) {
    __publicField(this, "state");
    __publicField(this, "_api");
    __publicField(this, "_initialized");
    this.state = new State(args);
    this._api = null;
    this._initialized = false;
  }
  async init() {
    if (this._initialized) {
      return;
    } else {
      this._initialized = true;
    }
    await this.state.init();
    try {
      await this._initAPI();
    } catch (error) {
      if (error instanceof Error && error.message === "Receiver is currently not embedded as an iframe" && !this.state.slices.length) {
        this.state.message = sliceSimulatorAccessedDirectly;
      }
      console.error(error);
      return;
    }
    this._initListeners();
  }
  async _initAPI() {
    this._api = new SimulatorAPI({
      [ClientRequestType.SetSliceZone]: (req, res) => {
        this.state.setSliceZone(req.data);
        return res.success();
      },
      [ClientRequestType.ScrollToSlice]: (req, res) => {
        var _a;
        if (req.data.sliceIndex < 0) {
          return res.error("`sliceIndex` must be > 0", 400);
        } else if (req.data.sliceIndex >= this.state.slices.length) {
          return res.error(`\`sliceIndex\` must be < ${this.state.slices.length} (\`<SliceZone />\` current length)`, 400);
        }
        const $sliceZone = getSliceZoneDOM(this.state.slices.length);
        if (!$sliceZone) {
          return res.error("Failed to find `<SliceZone />`", 500);
        }
        this.state.activeSlice = null;
        const $slice = $sliceZone.children[req.data.sliceIndex];
        if (!$slice) {
          return res.error(`Failed fo find slice at index $\`{req.data.sliceIndex}\` in \`<SliceZone />\``, 500);
        }
        $slice.scrollIntoView({
          behavior: req.data.behavior,
          block: req.data.block,
          inline: req.data.inline
        });
        ((_a = this._api) == null ? void 0 : _a.options.activeSliceAPI) && setTimeout(this.state.setActiveSlice, 750);
        return res.success();
      }
    });
    await this._api.ready();
  }
  _initListeners() {
    var _a, _b;
    if ((_a = this._api) == null ? void 0 : _a.options.activeSliceAPI) {
      window.addEventListener("mousemove", () => {
        this.state.setActiveSlice();
      });
      window.addEventListener("resize", () => {
        this.state.setActiveSlice();
      });
      window.addEventListener("mousewheel", () => {
        setTimeout(this.state.setActiveSlice, 200);
      });
      this.state.on(StateEventType.Slices, () => {
        this.state.setActiveSlice();
      });
      this.state.on(StateEventType.ActiveSlice, async (activeSlice) => {
        if (this._api) {
          try {
            await this._api.setActiveSlice(activeSlice);
          } catch (error) {
            if (error instanceof ResponseError && error.response.status === 400) {
              console.error(error.response);
            } else {
              throw error;
            }
          }
        }
      });
    }
    if ((_b = this._api) == null ? void 0 : _b.options.sliceZoneSizeAPI) {
      const resizeObserver = new ResizeObserver(throttle(async (entries) => {
        const [entry] = entries;
        if (this._api && entry) {
          try {
            await this._api.setSliceZoneSize({ rect: entry.contentRect });
          } catch (error) {
            if (error instanceof ResponseError && error.response.status === 400) {
              console.error(error.response);
            } else {
              throw error;
            }
          }
        }
      }, 16));
      const observeSimulatorRoot = () => {
        const simulatorRootDOM = getSimulatorRootDOM();
        resizeObserver.disconnect();
        if (simulatorRootDOM) {
          resizeObserver.observe(simulatorRootDOM);
        }
      };
      const mutationObserver = new MutationObserver(observeSimulatorRoot);
      mutationObserver.observe(getSimulatorDOM(), {
        subtree: false,
        childList: true
      });
    }
  }
}
export {
  SimulatorManager
};
//# sourceMappingURL=SimulatorManager.js.map
