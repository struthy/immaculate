var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { InternalReceiverRequestType, InternalEmitterRequestType } from "./types.js";
import { ChannelNotSetError, ConnectionTimeoutError, NotReadyError } from "./errors.js";
import { ChannelNetwork } from "./ChannelNetwork.js";
import { validateMessage, isRequestMessage, createErrorResponseMessage, createSuccessResponseMessage } from "./messages.js";
const channelEmitterDefaultOptions = {
  connectTimeout: 2e4,
  requestIDPrefix: "emitter-"
};
class ChannelEmitter extends ChannelNetwork {
  constructor(target, requestHandlers, options) {
    super(requestHandlers, { ...channelEmitterDefaultOptions, ...options });
    __publicField(this, "_target");
    __publicField(this, "_channel", null);
    __publicField(this, "_receiverReady", "");
    __publicField(this, "_receiverReadyCallback", null);
    __publicField(this, "_connected", false);
    this._target = target;
    window.addEventListener("message", (event) => {
      this._onPublicMessage(event);
    });
  }
  get channel() {
    if (!this._channel) {
      throw new ChannelNotSetError();
    }
    return this._channel;
  }
  set channel(channel) {
    this._channel = channel;
    if (this._channel) {
      this.port = this._channel.port1;
    } else {
      this.port = null;
    }
  }
  get connected() {
    return this._connected;
  }
  /**
   * Initiates connection to receiver
   *
   * @param receiverOptions - Options to configure the receiver with
   * @param newOrigin - Indicates to the emitter that we're connecting to a new
   *   origin
   *
   * @returns Success connect message
   */
  connect(receiverOptions = {}, newOrigin = false) {
    this.disconnect();
    if (newOrigin) {
      this._receiverReady = "";
    }
    return new Promise((resolve, reject) => {
      this._target.addEventListener("load", () => {
        if (!this._target.contentWindow) {
          return reject(new Error("Target window is not available"));
        }
        const receiverReadyTimeout = setTimeout(() => {
          reject(new ConnectionTimeoutError());
        }, this.options.connectTimeout);
        const receiverReadyCallback = async () => {
          clearTimeout(receiverReadyTimeout);
          this.channel = new MessageChannel();
          const request = this.createRequestMessage(InternalEmitterRequestType.Connect, receiverOptions);
          const response = await this.postRequest(request, (request2) => {
            this._target.contentWindow.postMessage(request2, "*", [
              this.channel.port2
            ]);
          });
          this.postResponse(createSuccessResponseMessage(this._receiverReady, void 0), (response2) => {
            this._target.contentWindow.postMessage(response2, "*");
          });
          this._connected = true;
          resolve(response);
        };
        if (this._receiverReady) {
          receiverReadyCallback();
        } else {
          this._receiverReadyCallback = receiverReadyCallback;
        }
      }, { once: true });
    });
  }
  /**
   * Destroys current connection to receiver if any
   */
  disconnect() {
    this._connected = false;
    this.channel = null;
  }
  /**
   * Handles public messages
   */
  async _onPublicMessage(event) {
    if (event.source !== this._target.contentWindow) {
      return;
    }
    try {
      const message = validateMessage(event.data);
      if (isRequestMessage(message)) {
        if (this.options.debug) {
          console.debug(event.data);
        }
        switch (message.type) {
          case InternalReceiverRequestType.Ready:
            this._receiverReady = message.requestID;
            if (this._receiverReadyCallback) {
              const receiverReadyCallbackPromise = this._receiverReadyCallback();
              this._receiverReadyCallback = null;
              await receiverReadyCallbackPromise;
            }
            break;
          default:
            this.postResponse(createErrorResponseMessage(message.requestID, void 0), (response) => {
              event.source.postMessage(response, event.origin);
            });
            break;
        }
      } else {
      }
    } catch (error) {
      if (error instanceof TypeError)
        ;
      else {
        throw error;
      }
    }
  }
  postFormattedRequest(type, data, options = {}) {
    if (!this._connected) {
      throw new NotReadyError("Emitter is not connected, use `ChannelEmitter.connect()` first");
    }
    return this.postRequest(this.createRequestMessage(type, data), void 0, options);
  }
}
export {
  ChannelEmitter,
  channelEmitterDefaultOptions
};
//# sourceMappingURL=ChannelEmitter.js.map
