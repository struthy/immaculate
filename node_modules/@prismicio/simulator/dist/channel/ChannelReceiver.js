var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { InternalReceiverRequestType, InternalEmitterRequestType } from "./types.js";
import { NotReadyError } from "./errors.js";
import { ChannelNetwork } from "./ChannelNetwork.js";
import { validateMessage, isRequestMessage, createErrorResponseMessage, createSuccessResponseMessage } from "./messages.js";
const channelReceiverDefaultOptions = {
  readyTimeout: 2e4,
  requestIDPrefix: "receiver-"
};
class ChannelReceiver extends ChannelNetwork {
  constructor(requestHandlers, options) {
    super(requestHandlers, { ...channelReceiverDefaultOptions, ...options });
    __publicField(this, "_ready", false);
    window.addEventListener("message", (event) => {
      this._onPublicMessage(event);
    });
  }
  /**
   * Tells the emitter that receiver is ready
   */
  async ready() {
    if (window.parent === window) {
      throw new Error("Receiver is currently not embedded as an iframe");
    }
    this._ready = false;
    const request = this.createRequestMessage(InternalReceiverRequestType.Ready, void 0);
    const response = await this.postRequest(request, (request2) => {
      window.parent.postMessage(request2, "*");
    }, {
      timeout: this.options.readyTimeout
    });
    this._ready = true;
    return response;
  }
  /**
   * Handles public messages
   */
  _onPublicMessage(event) {
    try {
      const message = validateMessage(event.data);
      if (isRequestMessage(message)) {
        if (this.options.debug) {
          console.debug(event.data);
        }
        switch (message.type) {
          case InternalEmitterRequestType.Connect:
            this.port = event.ports[0];
            const { data } = message;
            this.options = {
              ...this.options,
              ...data,
              // Ensure core options remain the same
              debug: this.options.debug,
              requestIDPrefix: this.options.requestIDPrefix,
              readyTimeout: this.options.readyTimeout
            };
            const response = createSuccessResponseMessage(message.requestID, void 0);
            this.postResponse(response);
            break;
          default:
            this.postResponse(createErrorResponseMessage(message.requestID, void 0), (response2) => {
              event.source.postMessage(response2, event.origin);
            });
            break;
        }
      } else {
        if (!this._ready) {
          this.onMessage(event);
        }
      }
    } catch (error) {
      if (error instanceof TypeError)
        ;
      else {
        throw error;
      }
    }
  }
  postFormattedRequest(type, data, options = {}) {
    if (!this._ready) {
      throw new NotReadyError("Receiver is not ready, use `ChannelReceiver.ready()` first");
    }
    return this.postRequest(this.createRequestMessage(type, data), void 0, options);
  }
}
export {
  ChannelReceiver,
  channelReceiverDefaultOptions
};
//# sourceMappingURL=ChannelReceiver.js.map
