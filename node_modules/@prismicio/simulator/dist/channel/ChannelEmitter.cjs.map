{"version":3,"file":"ChannelEmitter.cjs","sources":["../../../src/channel/ChannelEmitter.ts"],"sourcesContent":["import {\n\tExtractSuccessResponseMessage,\n\tInternalEmitterRequestType,\n\tInternalEmitterTransactions,\n\tInternalReceiverRequestType,\n\tSuccessResponseMessage,\n\tTransactionsHandlers,\n\tUnknownRequestMessage,\n\tUnknownResponseMessage,\n\tUnknownTransaction,\n} from \"./types\";\n\nimport {\n\tChannelNotSetError,\n\tConnectionTimeoutError,\n\tNotReadyError,\n} from \"./errors\";\n\nimport {\n\tChannelNetwork,\n\tChannelNetworkOptions,\n\tPostRequestOptions,\n} from \"./ChannelNetwork\";\nimport { AllChannelReceiverOptions } from \"./ChannelReceiver\";\nimport {\n\tcreateErrorResponseMessage,\n\tcreateSuccessResponseMessage,\n\tisRequestMessage,\n\tvalidateMessage,\n} from \"./messages\";\n\nexport type ChannelEmitterOptions = {\n\tconnectTimeout: number;\n};\n\nexport const channelEmitterDefaultOptions: ChannelEmitterOptions &\n\tPartial<ChannelNetworkOptions> = {\n\tconnectTimeout: 20000,\n\trequestIDPrefix: \"emitter-\",\n};\n\nexport type AllChannelEmitterOptions = ChannelEmitterOptions &\n\tChannelNetworkOptions;\n\nexport abstract class ChannelEmitter<\n\tTReceiverTransactions extends Record<string, UnknownTransaction> = Record<\n\t\tstring,\n\t\tnever\n\t>,\n\tTOptions extends Record<string, unknown> = Record<string, unknown>,\n\tTReceiverOptions extends Record<string, unknown> = Record<string, unknown>,\n> extends ChannelNetwork<\n\tTReceiverTransactions,\n\tChannelEmitterOptions & TOptions\n> {\n\tprivate _target: HTMLIFrameElement;\n\tprivate _channel: MessageChannel | null = null;\n\tprotected get channel(): MessageChannel {\n\t\tif (!this._channel) {\n\t\t\tthrow new ChannelNotSetError();\n\t\t}\n\n\t\treturn this._channel;\n\t}\n\tprotected set channel(channel: MessageChannel | null) {\n\t\tthis._channel = channel;\n\n\t\t// Update port automatically\n\t\tif (this._channel) {\n\t\t\tthis.port = this._channel.port1;\n\t\t} else {\n\t\t\tthis.port = null;\n\t\t}\n\t}\n\tprivate _receiverReady = \"\";\n\tprivate _receiverReadyCallback: (() => Promise<void>) | null = null;\n\tprivate _connected = false;\n\tpublic get connected(): boolean {\n\t\treturn this._connected;\n\t}\n\n\tconstructor(\n\t\ttarget: HTMLIFrameElement,\n\t\trequestHandlers: TransactionsHandlers<TReceiverTransactions>,\n\t\toptions: Partial<AllChannelEmitterOptions> & TOptions,\n\t) {\n\t\tsuper(requestHandlers, { ...channelEmitterDefaultOptions, ...options });\n\n\t\tthis._target = target;\n\n\t\twindow.addEventListener(\"message\", (event) => {\n\t\t\tthis._onPublicMessage(event);\n\t\t});\n\t}\n\n\t/**\n\t * Initiates connection to receiver\n\t *\n\t * @param receiverOptions - Options to configure the receiver with\n\t * @param newOrigin - Indicates to the emitter that we're connecting to a new\n\t *   origin\n\t *\n\t * @returns Success connect message\n\t */\n\tconnect(\n\t\treceiverOptions: InternalEmitterTransactions<\n\t\t\tAllChannelReceiverOptions & TReceiverOptions\n\t\t>[\"connect\"][\"request\"][\"data\"] = {},\n\t\tnewOrigin = false,\n\t): Promise<SuccessResponseMessage> {\n\t\t// Disconnect first\n\t\tthis.disconnect();\n\t\t// If changing origin we'll need to wait for receiver to be ready again\n\t\tif (newOrigin) {\n\t\t\tthis._receiverReady = \"\";\n\t\t}\n\n\t\t// Handshake promise\n\t\treturn new Promise<SuccessResponseMessage>((resolve, reject) => {\n\t\t\t// Wait for target to be loaded\n\t\t\tthis._target.addEventListener(\n\t\t\t\t\"load\",\n\t\t\t\t() => {\n\t\t\t\t\t// Throw if target doesn't allow access to content window\n\t\t\t\t\tif (!this._target.contentWindow) {\n\t\t\t\t\t\treturn reject(new Error(\"Target window is not available\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst receiverReadyTimeout = setTimeout(() => {\n\t\t\t\t\t\treject(new ConnectionTimeoutError());\n\t\t\t\t\t}, this.options.connectTimeout);\n\n\t\t\t\t\t// Connect to target once ready\n\t\t\t\t\tconst receiverReadyCallback = async (): Promise<void> => {\n\t\t\t\t\t\t// Clear receiver ready timeout\n\t\t\t\t\t\tclearTimeout(receiverReadyTimeout);\n\n\t\t\t\t\t\t// Create new message channel (set up port automatically)\n\t\t\t\t\t\t// This is done here to prevent transferable objects neutering\n\t\t\t\t\t\t// when calling `connect()` multiple times\n\t\t\t\t\t\tthis.channel = new MessageChannel();\n\n\t\t\t\t\t\t// Conclude handshake by sending message channel port to target\n\t\t\t\t\t\tconst request = this.createRequestMessage(\n\t\t\t\t\t\t\tInternalEmitterRequestType.Connect,\n\t\t\t\t\t\t\treceiverOptions,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst response = await this.postRequest<\n\t\t\t\t\t\t\tInternalEmitterTransactions<\n\t\t\t\t\t\t\t\tAllChannelReceiverOptions & TReceiverOptions\n\t\t\t\t\t\t\t>[\"connect\"][\"request\"],\n\t\t\t\t\t\t\tInternalEmitterTransactions<\n\t\t\t\t\t\t\t\tAllChannelReceiverOptions & TReceiverOptions\n\t\t\t\t\t\t\t>[\"connect\"][\"response\"]\n\t\t\t\t\t\t>(request, (request) => {\n\t\t\t\t\t\t\t// Target content window is checked in previous statement\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t\t\t\t\tthis._target.contentWindow!.postMessage(request, \"*\", [\n\t\t\t\t\t\t\t\tthis.channel.port2,\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Finish by aknowledging ready\n\t\t\t\t\t\tthis.postResponse(\n\t\t\t\t\t\t\tcreateSuccessResponseMessage(this._receiverReady, undefined),\n\t\t\t\t\t\t\t(response) => {\n\t\t\t\t\t\t\t\t// Target content window is checked in previous statement\n\t\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t\t\t\t\t\tthis._target.contentWindow!.postMessage(response, \"*\");\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// If post request succeed, we're connected\n\t\t\t\t\t\tthis._connected = true;\n\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t};\n\n\t\t\t\t\tif (this._receiverReady) {\n\t\t\t\t\t\t// If receiver is already ready, send port immediately\n\t\t\t\t\t\treceiverReadyCallback();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Else wait for receiver to be ready\n\t\t\t\t\t\tthis._receiverReadyCallback = receiverReadyCallback;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{ once: true },\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Destroys current connection to receiver if any\n\t */\n\tdisconnect(): void {\n\t\tthis._connected = false;\n\t\tthis.channel = null;\n\t}\n\n\t/**\n\t * Handles public messages\n\t */\n\tprivate async _onPublicMessage(event: MessageEvent<unknown>): Promise<void> {\n\t\t// Return is event is not from target\n\t\tif (event.source !== this._target.contentWindow) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst message = validateMessage(event.data);\n\n\t\t\tif (isRequestMessage(message)) {\n\t\t\t\tif (this.options.debug) {\n\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\tconsole.debug(event.data);\n\t\t\t\t}\n\n\t\t\t\tswitch (message.type) {\n\t\t\t\t\tcase InternalReceiverRequestType.Ready:\n\t\t\t\t\t\tthis._receiverReady = message.requestID;\n\n\t\t\t\t\t\t// If emitter is waiting for receiver to be ready\n\t\t\t\t\t\tif (this._receiverReadyCallback) {\n\t\t\t\t\t\t\t// We don't await the promise directly as we need to clear the callback first\n\t\t\t\t\t\t\tconst receiverReadyCallbackPromise =\n\t\t\t\t\t\t\t\tthis._receiverReadyCallback();\n\n\t\t\t\t\t\t\tthis._receiverReadyCallback = null;\n\n\t\t\t\t\t\t\tawait receiverReadyCallbackPromise;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis.postResponse(\n\t\t\t\t\t\t\tcreateErrorResponseMessage(message.requestID, undefined),\n\t\t\t\t\t\t\t(response) => {\n\t\t\t\t\t\t\t\t(event.source as WindowProxy).postMessage(\n\t\t\t\t\t\t\t\t\tresponse,\n\t\t\t\t\t\t\t\t\tevent.origin,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No response messages are expected on public channel\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (error instanceof TypeError) {\n\t\t\t\t// Ignore unknown messages\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected postFormattedRequest<\n\t\tTRequest extends UnknownRequestMessage,\n\t\tTResponse extends UnknownResponseMessage,\n\t>(\n\t\ttype: TRequest[\"type\"],\n\t\tdata?: TRequest[\"data\"],\n\t\toptions: PostRequestOptions = {},\n\t): Promise<ExtractSuccessResponseMessage<TResponse>> {\n\t\tif (!this._connected) {\n\t\t\tthrow new NotReadyError(\n\t\t\t\t\"Emitter is not connected, use `ChannelEmitter.connect()` first\",\n\t\t\t);\n\t\t}\n\n\t\treturn this.postRequest(\n\t\t\tthis.createRequestMessage(type, data),\n\t\t\tundefined,\n\t\t\toptions,\n\t\t);\n\t}\n}\n"],"names":["ChannelNetwork","ChannelNotSetError","ConnectionTimeoutError","InternalEmitterRequestType","request","createSuccessResponseMessage","response","validateMessage","isRequestMessage","InternalReceiverRequestType","createErrorResponseMessage","NotReadyError"],"mappings":"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"}