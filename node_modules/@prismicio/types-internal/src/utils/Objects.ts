import { isRight } from "fp-ts/lib/Either"
import * as t from "io-ts"

export function zipObjects<A, B = A>(
	objLeft?: Partial<Record<string, A>> | undefined,
	objRight?: Partial<Record<string, B>> | undefined,
): Partial<Record<string, { left?: A | undefined; right?: B | undefined }>> {
	const allKeys = [
		...new Set(Object.keys(objLeft || {}).concat(Object.keys(objRight || {}))),
	]

	return allKeys.reduce<
		Record<string, { left?: A | undefined; right?: B | undefined }>
	>((acc, key) => {
		const left = objLeft?.[key]
		const right = objRight?.[key]
		return {
			...acc,
			[key]: { left, right },
		}
	}, {})
}

export function isNotEmpty<A extends object>(obj: A): boolean {
	return Boolean(Object.keys(obj).length)
}

export function withOptionals<T extends object>(
	object: T,
	optionals: Array<[keyof T, T[keyof T] | null | undefined]>,
): T {
	return {
		...object,
		...optionals.reduce((acc, [key, value]) => {
			return value ? { ...acc, [key]: value } : acc
		}, {}),
	}
}

const recordCodec = t.record(t.string, t.unknown)
export function isObject(value: unknown): value is Record<string, unknown> {
	return isRight(recordCodec.decode(value))
}

export function mapValues<T, O>(
	record: Record<string, T>,
	fn: (value: T, key: string) => O,
): Record<string, O> {
	return Object.entries<T>(record).reduce<Record<string, O>>(
		(acc, [key, value]) => ({ ...acc, [key]: fn(value, key) }),
		{},
	)
}
