import { either } from "fp-ts"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import { withCustomError } from "./function"

export const String = withCustomError(
	t.string,
	() => "The value must be a string",
)
export const StringOrNull = withCustomError(
	t.union([t.string, t.null]),
	() => "The value must be a string or null",
)
export const Number = withCustomError(
	t.number,
	() => "The value must be a number",
)
export const NumberOrNull = withCustomError(
	t.union([t.number, t.null]),
	() => "The value must be a number or null",
)
export const Boolean = withCustomError(
	t.boolean,
	() => "The value must be a boolean",
)

export const EmptyObject = t.UnknownRecord.pipe(
	new t.Type(
		"emptyObject",
		(u: unknown): u is Record<never, never> => t.UnknownRecord.is(u),
		(u: Record<string, unknown>, c: t.Context) => {
			if (Object.keys(u).length > 0)
				return t.failure(u, c, "The object is not empty.")
			return t.success({})
		},
		t.identity,
	),
)

export const EmptyArray = new t.Type<never[], never[], unknown>(
	"emptyArray",
	(u: unknown): u is [] => t.UnknownArray.is(u) && u.length === 0,
	(u: unknown, c: t.Context) => {
		return pipe(
			t.UnknownArray.decode(u),
			either.chain((parsedArray) => {
				if (parsedArray.length > 0)
					return t.failure(u, c, "The array is not empty.")
				return t.success(new Array<never>())
			}),
		)
	},
	() => [],
)
