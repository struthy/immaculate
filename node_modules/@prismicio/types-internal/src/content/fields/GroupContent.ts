import { either } from "fp-ts"
import { isLeft } from "fp-ts/lib/Either"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import type {
	ContentPath,
	TraverseWidgetContentFn,
} from "../../_internal/utils"
import {
	type Group,
	type NestableWidget,
	GroupFieldType,
} from "../../customtypes"
import {
	FieldOrSliceType,
	getFieldCtx,
	LegacyContentCtx,
	WithTypes,
} from "../LegacyContentCtx"
import { hasContentType } from "../utils"
import { isNestableContent, NestableContent, NestableLegacy } from "./nestable"
import { repeatableContentWithDefaultNestableContentValues } from "./withDefaultValues"

export const GroupItemContentType = "GroupItemContent" as const
export const GroupContentType = "GroupContentType" as const

export const GroupItemContent: t.Type<GroupItemContent> = t.recursion(
	"GroupItemContent",
	() =>
		t.strict({
			__TYPE__: t.literal(GroupItemContentType),
			value: t.array(
				t.tuple([t.string, t.union([NestableContent, GroupContent])]),
			),
		}),
)
export type GroupItemContent = {
	__TYPE__: typeof GroupItemContentType
	value: [string, NestableContent | GroupContent][]
}

export const GroupContent: t.Type<GroupContent> = t.recursion(
	"GroupContent",
	() =>
		t.strict({
			__TYPE__: t.literal(GroupContentType),
			value: t.array(GroupItemContent),
		}),
)
export type GroupContent = {
	__TYPE__: typeof GroupContentType
	value: GroupItemContent[]
}

export const isGroupContent = GroupContent.is

export const GroupContentDefaultValue: GroupContent = {
	__TYPE__: GroupContentType,
	value: [],
}

const itemLegacyReader = t.record(t.string, t.unknown)
type GroupItemLegacy = t.TypeOf<typeof itemLegacyReader>

export const GroupItemLegacy = (ctx: LegacyContentCtx) => {
	return new t.Type<GroupItemContent, WithTypes<GroupItemLegacy>>(
		"GroupItemLegacy",
		(u): u is GroupItemContent =>
			hasContentType(u) && u.__TYPE__ === GroupItemContentType,
		(u) => {
			const parsed = pipe(
				itemLegacyReader.decode(u),
				either.map((items) => {
					const parsedItems = Object.entries(items).reduce<
						Array<[string, NestableContent | GroupContent]>
					>((acc, [itemKey, itemValue]) => {
						const itemCtx = getFieldCtx(itemKey, ctx)
						const result =
							itemCtx.fieldType === GroupFieldType
								? GroupLegacy(itemCtx).decode(itemValue)
								: NestableLegacy(itemCtx).decode(itemValue)

						if (!result) return acc

						if (isLeft(result)) return acc
						return [...acc, [itemKey, result.right]]
					}, [])

					return {
						value: parsedItems,
						__TYPE__: GroupItemContentType,
					}
				}),
			)
			return parsed
		},
		(item) => {
			return item.value.reduce<WithTypes<GroupItemLegacy>>(
				(acc, [key, value]) => {
					const itemCtx = getFieldCtx(key, ctx)
					const encoded = isGroupContent(value)
						? GroupLegacy(itemCtx).encode(value)
						: NestableLegacy(itemCtx).encode(value)

					if (!encoded) return acc

					return {
						content: { ...acc.content, [key]: encoded.content },
						types: { ...acc.types, ...encoded.types },
					}
				},
				{ content: {}, types: {} },
			)
		},
	)
}

type GroupLegacy = Array<GroupItemLegacy>
export const GroupLegacy = (
	ctx: LegacyContentCtx,
): t.Type<GroupContent, WithTypes<GroupLegacy>, unknown> => {
	const codecDecode = t.array(t.union([t.null, GroupItemLegacy(ctx)]))
	const codecEncode = t.array(GroupItemLegacy(ctx))

	return new t.Type<GroupContent, WithTypes<GroupLegacy>, unknown>(
		"GroupLegacy",
		isGroupContent,
		(items) => {
			return pipe(
				codecDecode.decode(items),
				either.map((parsedItems) => {
					return {
						value: parsedItems.map((i) => {
							if (i === null) {
								return { __TYPE__: GroupItemContentType, value: [] }
							} else return i
						}),
						__TYPE__: GroupContentType,
					}
				}),
			)
		},
		(g: GroupContent) => {
			const res = codecEncode.encode(g.value)
			return {
				content: res.map((block) => block.content),
				types: res.reduce<Record<string, FieldOrSliceType>>(
					(acc, block) => {
						return { ...acc, ...block.types }
					},
					{ [ctx.keyOfType]: GroupFieldType },
				),
			}
		},
	)
}

export function groupContentWithDefaultValues(
	customType: Group,
	content: GroupContent,
): GroupContent {
	const fields = customType.config?.fields
	if (!fields) return content
	return {
		...content,
		value: repeatableContentWithDefaultNestableContentValues(
			fields,
			content.value,
		),
	}
}

export function traverseGroupContent({
	path,
	key,
	apiId,
	model,
	content,
}: {
	path: ContentPath
	key: string
	apiId: string
	content: GroupContent
	model?: Group | undefined
}) {
	return (transform: TraverseWidgetContentFn): GroupContent | undefined => {
		const groupItems = traverseGroupItemsContent({
			path,
			model: model?.config?.fields,
			content: content.value,
		})(transform)

		return transform({
			path,
			key,
			apiId,
			model,
			content: {
				__TYPE__: content.__TYPE__,
				value: groupItems,
			},
		})
	}
}

export function traverseGroupItemsContent({
	path,
	model,
	content,
}: {
	path: ContentPath
	content: Array<GroupItemContent>
	model?: Record<string, Group | NestableWidget> | undefined
}) {
	return (transform: TraverseWidgetContentFn): Array<GroupItemContent> => {
		return content.map((groupItem, index) => {
			const groupItemPath = path.concat([
				{ key: index.toString(), type: "GroupItem" },
			])

			const groupItemFields = groupItem.value.reduce<GroupItemContent["value"]>(
				(acc, [fieldKey, fieldContent]) => {
					const fieldDef = model?.[fieldKey]

					let transformedField
					if (
						(!fieldDef || fieldDef?.type === GroupFieldType) &&
						fieldContent.__TYPE__ === GroupContentType
					) {
						transformedField = traverseGroupContent({
							path: groupItemPath.concat([{ key: fieldKey, type: "Widget" }]),
							key: fieldKey,
							apiId: fieldKey,
							model: fieldDef,
							content: fieldContent,
						})(transform)
					} else {
						transformedField = transform({
							path: groupItemPath.concat([{ key: fieldKey, type: "Widget" }]),
							key: fieldKey,
							apiId: fieldKey,
							model: fieldDef,
							content: fieldContent,
						})
					}

					// Can happen if the transform function returns undefined to filter out a field
					if (
						!transformedField ||
						!(
							isNestableContent(transformedField) ||
							isGroupContent(transformedField)
						)
					)
						return acc

					return acc.concat([[fieldKey, transformedField]])
				},
				[],
			)

			return {
				__TYPE__: groupItem.__TYPE__,
				value: groupItemFields,
			}
		})
	}
}
