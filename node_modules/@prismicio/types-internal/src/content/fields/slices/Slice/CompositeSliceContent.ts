import { either } from "fp-ts"
import { isLeft } from "fp-ts/lib/Either"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import type {
	ContentPath,
	TraverseSliceContentFn,
	TraverseWidgetContentFn,
} from "../../../../_internal/utils"
import type { CompositeSlice, VariationFields } from "../../../../customtypes"
import {
	getFieldCtx,
	LegacyContentCtx,
	WithTypes,
} from "../../../LegacyContentCtx"
import { hasContentType } from "../../../utils"
import { GroupItemContent, traverseGroupItemsContent } from "../../GroupContent"
import {
	isNestableContent,
	NestableContent,
	NestableLegacy,
} from "../../nestable"
import {
	repeatableContentWithDefaultNestableContentValues,
	withDefaultNestableContentValues,
} from "../../withDefaultValues"
import type {
	CompositeSliceItemContent,
	SharedSliceItemContent,
} from "../SliceItem"
import { RepeatableWidgets, RepeatableWidgetsLegacy } from "./RepeatableContent"

export const CompositeSliceContentType = "CompositeSliceContent"

export const isCompositeSliceContent = (
	u: unknown,
): u is CompositeSliceContent =>
	hasContentType(u) && u.__TYPE__ === CompositeSliceContentType

const legacyReader = t.exact(
	t.partial({
		repeat: t.array(t.unknown),
		"non-repeat": t.UnknownRecord,
	}),
)
type CompositeSliceLegacy = t.TypeOf<typeof legacyReader>

export const CompositeSliceLegacy = (ctx: LegacyContentCtx) => {
	return new t.Type<
		CompositeSliceContent,
		WithTypes<CompositeSliceLegacy>,
		unknown
	>(
		"CompositeSliceLegacy",
		isCompositeSliceContent,
		(slice) => {
			return pipe(
				legacyReader.decode(slice),
				either.map((parsedSlice) => {
					const repeat =
						(() => {
							const itemsCtx = getFieldCtx("repeat", ctx)
							const result = RepeatableWidgetsLegacy(itemsCtx).decode(
								parsedSlice.repeat,
							)
							if (!result || isLeft(result)) return
							return result.right
						})() || []

					const nonRepeat = Object.entries(
						parsedSlice["non-repeat"] || {},
					).reduce<Record<string, NestableContent>>((acc, [key, value]) => {
						const fieldCtx = getFieldCtx(key, ctx, ["non-repeat"])
						if (!fieldCtx) return acc

						const result = NestableLegacy(fieldCtx).decode(value)
						if (!result) return acc

						if (isLeft(result)) return acc
						return { ...acc, [key]: result.right }
					}, {})

					return {
						nonRepeat,
						repeat,
						__TYPE__: CompositeSliceContentType,
					}
				}),
			)
		},
		(s: CompositeSliceContent) => {
			const nonRepeat = Object.entries(s.nonRepeat).reduce<
				WithTypes<{ [key: string]: unknown }>
			>(
				(acc, [key, value]) => {
					const FieldCtx = getFieldCtx(key, ctx, ["non-repeat"])

					const result = NestableLegacy(FieldCtx).encode(value)
					if (!result) return acc

					return {
						content: { ...acc.content, [key]: result.content },
						types: { ...acc.types, ...result.types },
					}
				},
				{ content: {}, types: {} },
			)

			const repeat =
				(() => {
					const itemsCtx = getFieldCtx("repeat", ctx)
					const result = RepeatableWidgetsLegacy(itemsCtx).encode(s.repeat)
					return result
				})() || []

			return {
				content: {
					"non-repeat": nonRepeat.content,
					repeat: repeat.map((i) => i.content),
				},
				types: {
					[ctx.keyOfType]: "Slice",
					...nonRepeat.types,
					...repeat.reduce((acc, i) => ({ ...acc, ...i.types }), {}),
				},
			}
		},
	)
}

export const CompositeSliceContent = t.strict({
	__TYPE__: t.literal(CompositeSliceContentType),
	nonRepeat: t.record(t.string, NestableContent),
	repeat: RepeatableWidgets,
})

export type CompositeSliceContent = t.TypeOf<typeof CompositeSliceContent>

export function compositeSliceContentWithDefaultValues(
	customType: CompositeSlice,
	content: CompositeSliceContent,
): CompositeSliceContent {
	const updatedNonRepeatContent = withDefaultNestableContentValues(
		customType["non-repeat"] ?? {},
		content.nonRepeat,
	)
	const updatedRepeatContent =
		repeatableContentWithDefaultNestableContentValues(
			customType.repeat ?? {},
			content.repeat,
		)

	return {
		...content,
		nonRepeat: updatedNonRepeatContent,
		repeat: updatedRepeatContent,
	}
}

export function traverseCompositeSliceContent({
	path,
	sliceKey,
	sliceName,
	model,
	content,
}: {
	path: ContentPath
	sliceKey: string
	sliceName: string
	content: CompositeSliceItemContent
	model?: VariationFields | CompositeSlice | undefined
}) {
	return (
		transformWidget: TraverseWidgetContentFn,
		transformSlice: TraverseSliceContentFn,
	): SharedSliceItemContent | CompositeSliceItemContent | undefined => {
		const primary = Object.entries(content.widget.nonRepeat).reduce<
			CompositeSliceContent["nonRepeat"]
		>((acc, [fieldKey, fieldContent]) => {
			const fieldDef = (() => {
				return model?.type === "SharedSlice"
					? model?.fields?.primary?.[fieldKey]
					: model?.["non-repeat"]?.[fieldKey]
			})()

			const transformedField = transformWidget({
				path: path.concat([
					{ key: "non-repeat", type: "primary" },
					{ key: fieldKey, type: "Widget" },
				]),
				key: fieldKey,
				apiId: sliceName,
				model: fieldDef,
				content: fieldContent,
			})
			// Can happen if the transform function returns undefined to filter out a field
			if (!transformedField) return acc
			if (!isNestableContent(transformedField)) {
				console.warn(
					`Warn: Non nestable content with key [${fieldKey}] detected in a composite slice [${sliceName}] with key [${sliceKey}]`,
				)
				return acc
			}
			return {
				...acc,
				[fieldKey]: transformedField,
			}
		}, {})

		const items = traverseGroupItemsContent({
			path: path.concat([{ key: "repeat", type: "items" }]),
			model:
				model?.type === "SharedSlice" ? model?.fields.items : model?.repeat,
			content: content.widget.repeat,
		})(transformWidget)

		return transformSlice({
			key: sliceKey,
			apiId: sliceName,
			path,
			model,
			content: {
				...content,
				widget: {
					__TYPE__: "CompositeSliceContent",
					repeat: items,
					nonRepeat: primary,
				},
			},
		})
	}
}

export function migrateCompositeSlice(
	model: VariationFields,
	content: CompositeSliceItemContent,
): SharedSliceItemContent {
	const [, sliceUUID] = content.key.split("$")
	return {
		key: `${model.sliceName}$${sliceUUID}`,
		name: model.sliceName,
		maybeLabel: content.maybeLabel,
		widget: {
			__TYPE__: "SharedSliceContent",
			variation: model.variationId,
			primary: Object.entries(content.widget.nonRepeat).reduce(
				(acc, [fieldKey, fieldContent]) => {
					if (!model.fields.primary?.[fieldKey]) {
						console.warn(
							`The widget ${fieldKey} in the non-repeat zone of the composite slice [${model.sliceName}] with key [${content.key}] doesn't exist in the model.`,
						)
						return acc
					}

					return { ...acc, [fieldKey]: fieldContent }
				},
				{},
			),
			items: content.widget.repeat.map((groupItem) => {
				return {
					__TYPE__: "GroupItemContent",
					value: groupItem.value.reduce<GroupItemContent["value"]>(
						(acc, [fieldKey, fieldContent]) => {
							if (!model.fields.items?.[fieldKey]) {
								console.warn(
									`The widget ${fieldKey} in the repeat zone of the composite slice [${model.sliceName}] with key [${content.key}] doesn't exist in the model.`,
								)
								return acc
							}
							return acc.concat([[fieldKey, fieldContent]])
						},
						[],
					),
				}
			}, []),
		},
	}
}
