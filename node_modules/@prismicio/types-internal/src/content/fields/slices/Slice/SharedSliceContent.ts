import { either } from "fp-ts"
import { isLeft } from "fp-ts/lib/Either"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"
import { withFallback } from "io-ts-types"

import type {
	ContentPath,
	TraverseSliceContentFn,
	TraverseWidgetContentFn,
} from "../../../../_internal/utils"
import {
	type SharedSlice,
	type VariationFields,
	GroupFieldType,
} from "../../../../customtypes"
import {
	getFieldCtx,
	LegacyContentCtx,
	WithTypes,
} from "../../../LegacyContentCtx"
import { hasContentType } from "../../../utils"
import {
	isGroupContent,
	traverseGroupContent,
	traverseGroupItemsContent,
} from "../../GroupContent"
import { isNestableContent } from "../../nestable"
import {
	repeatableContentWithDefaultNestableContentValues,
	withDefaultSlicePrimaryContentValues,
} from "../../withDefaultValues"
import type { SharedSliceItemContent } from "../SliceItem"
import { RepeatableWidgets, RepeatableWidgetsLegacy } from "./RepeatableContent"
import {
	isSlicePrimaryContent,
	SlicePrimaryContent,
	SlicePrimaryLegacy,
} from "./SlicePrimaryContent"

export const SharedSliceContentType = "SharedSliceContent"

export const isSharedSliceContent = (u: unknown): u is SharedSliceContent =>
	hasContentType(u) && u.__TYPE__ === SharedSliceContentType

const legacyReader = t.exact(
	t.type({
		variation: t.string,
		items: withFallback(t.array(t.unknown), []),
		primary: withFallback(t.UnknownRecord, {}),
	}),
)
type SharedSliceLegacy = t.TypeOf<typeof legacyReader>

export const SharedSliceLegacy = (ctx: LegacyContentCtx) => {
	return new t.Type<SharedSliceContent, WithTypes<SharedSliceLegacy>, unknown>(
		"SharedSliceLegacy",
		isSharedSliceContent,
		(slice) => {
			return pipe(
				legacyReader.decode(slice),
				either.map((parsedSlice) => {
					const items =
						(() => {
							const itemsCtx = getFieldCtx("items", ctx, [
								"variations",
								parsedSlice.variation,
							])
							const result = RepeatableWidgetsLegacy(itemsCtx).decode(
								parsedSlice.items,
							)
							if (!result || isLeft(result)) return
							return result.right
						})() || []

					const primary = Object.entries(parsedSlice.primary).reduce<
						Record<string, SlicePrimaryContent>
					>((acc, [key, value]) => {
						const FieldCtx = getFieldCtx(key, ctx, [
							"variations",
							parsedSlice.variation,
							"primary",
						])

						const result = SlicePrimaryLegacy(FieldCtx).decode(value)
						if (!result) return acc

						if (isLeft(result)) return acc
						return { ...acc, [key]: result.right }
					}, {})

					return {
						variation: parsedSlice.variation,
						primary,
						items,
						__TYPE__: SharedSliceContentType,
					}
				}),
			)
		},
		(s: SharedSliceContent) => {
			const primary = Object.entries(s.primary).reduce<
				WithTypes<Record<string, unknown>>
			>(
				(acc, [key, value]) => {
					const FieldCtx = getFieldCtx(key, ctx, [
						"variations",
						s.variation,
						"primary",
					])

					const result = SlicePrimaryLegacy(FieldCtx).encode(value)
					if (!result) return acc

					return {
						content: { ...acc.content, [key]: result.content },
						types: { ...acc.types, ...result.types },
					}
				},
				{ content: {}, types: {} },
			)

			const items =
				(() => {
					const itemsCtx = getFieldCtx("items", ctx, [
						"variations",
						s.variation,
					])
					const result = RepeatableWidgetsLegacy(itemsCtx).encode(s.items)
					return result
				})() || []

			return {
				content: {
					primary: primary.content,
					items: items.map((i) => i.content),
					variation: s.variation,
				},
				types: {
					[ctx.keyOfType]: "SharedSlice",
					...primary.types,
					...items.reduce((acc, i) => ({ ...acc, ...i.types }), {}),
				},
			}
		},
	)
}

export const SharedSliceContent = t.strict({
	__TYPE__: t.literal(SharedSliceContentType),
	variation: t.string,
	primary: t.record(t.string, SlicePrimaryContent),
	items: RepeatableWidgets,
})
export type SharedSliceContent = t.TypeOf<typeof SharedSliceContent>

export function sharedSliceContentWithDefaultValues(
	customType: SharedSlice,
	content: SharedSliceContent,
): SharedSliceContent {
	const variationConfig = customType.variations.find(
		(v) => v.id === content.variation,
	)

	const primaryConfig = variationConfig?.primary ?? {}
	const itemsConfig = variationConfig?.items ?? {}

	const updatedPrimaryContent = withDefaultSlicePrimaryContentValues(
		primaryConfig,
		content.primary,
	)
	const updatedItemsContent = repeatableContentWithDefaultNestableContentValues(
		itemsConfig,
		content.items,
	)

	return {
		...content,
		primary: updatedPrimaryContent,
		items: updatedItemsContent,
	}
}

export function traverseSharedSliceContent({
	path,
	sliceKey,
	sliceName,
	model,
	content,
}: {
	path: ContentPath
	sliceKey: string
	sliceName: string
	content: SharedSliceItemContent
	model?: VariationFields | undefined
}) {
	return (
		transformWidget: TraverseWidgetContentFn,
		transformSlice: TraverseSliceContentFn,
	): SharedSliceItemContent | undefined => {
		const primary = Object.entries(content.widget.primary).reduce<
			SharedSliceContent["primary"]
		>((acc, [fieldKey, fieldContent]) => {
			const fieldDef = model?.fields?.primary?.[fieldKey]

			const transformedField = (() => {
				if (isGroupContent(fieldContent)) {
					return traverseGroupContent({
						path: path.concat([
							{ key: "primary", type: "primary" },
							{ key: fieldKey, type: "Widget" },
						]),
						key: fieldKey,
						apiId: fieldKey,
						content: fieldContent,
						model: fieldDef?.type === GroupFieldType ? fieldDef : undefined,
					})(transformWidget)
				} else if (isNestableContent(fieldContent)) {
					return transformWidget({
						path: path.concat([
							{ key: "primary", type: "primary" },
							{ key: fieldKey, type: "Widget" },
						]),
						key: fieldKey,
						apiId: fieldKey,
						model: fieldDef,
						content: fieldContent,
					})
				} else {
					return undefined
				}
			})()

			// Can happen if the transform function returns undefined to filter out a field
			if (!transformedField) return acc
			if (!isSlicePrimaryContent(transformedField)) {
				console.warn(
					`Warn: Non nestable or group content with key [${fieldKey}] detected in a shared slice [${sliceName}] with key [${sliceKey}]`,
				)
			}

			return {
				...acc,
				[fieldKey]: transformedField,
			}
		}, {})

		const items = traverseGroupItemsContent({
			path: path.concat([{ key: "items", type: "items" }]),
			model: model?.fields.items,
			content: content.widget.items,
		})(transformWidget)

		return transformSlice({
			key: sliceKey,
			apiId: sliceName,
			path,
			model: model,
			content: {
				...content,
				widget: {
					__TYPE__: "SharedSliceContent",
					variation: content.widget.variation,
					primary,
					items,
				},
			},
		})
	}
}
