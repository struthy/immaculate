import { either } from "fp-ts"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import { withOptionals } from "../../../utils/Objects"
import { NonEmptyStringOrNull, StringOrNull } from "../../../validators"
import type { LegacyContentCtx, WithTypes } from "../../LegacyContentCtx"
import { hasContentType } from "../../utils"

export const ImageContentType = "ImageContent"

export const isImageContent = (u: unknown): u is ImageContent =>
	hasContentType(u) && u.__TYPE__ === ImageContentType

const originReader = t.exact(
	t.type({
		id: t.string,
		url: t.string,
		width: t.number,
		height: t.number,
	}),
)

export const ImageContentView = t.exact(
	t.intersection([
		t.type({
			origin: originReader,
			width: t.number,
			height: t.number,
			edit: t.type({
				zoom: t.number,
				crop: t.type({
					x: t.number,
					y: t.number,
				}),
				background: t.string,
			}),
		}),
		t.partial({
			url: t.string,
			credits: NonEmptyStringOrNull,
			alt: NonEmptyStringOrNull,
			provider: StringOrNull,
		}),
	]),
)
export type ImageContentView = t.TypeOf<typeof ImageContentView>

const legacyReader = t.intersection([
	ImageContentView,
	t.partial({
		thumbnails: t.record(t.string, ImageContentView),
	}),
])

type ImageLegacy = t.TypeOf<typeof legacyReader>

export const ImageLegacy = (ctx: LegacyContentCtx) =>
	new t.Type<ImageContent, WithTypes<ImageLegacy>, unknown>(
		"ImageLegacy",
		isImageContent,
		(u) => {
			return pipe(
				legacyReader.decode(u),
				either.map((i) =>
					ImageContent.encode({ ...i, __TYPE__: ImageContentType }),
				),
			)
		},

		(i: ImageContent) => {
			return {
				content: withOptionals<ImageLegacy>(
					{
						edit: i.edit,
						height: i.height,
						origin: i.origin,
						width: i.width,
					},
					[
						["alt", i.alt],
						["credits", i.credits],
						["provider", i.provider],
						["thumbnails", i.thumbnails],
						["url", i.url],
					],
				),
				types: { [ctx.keyOfType]: "Image" },
			}
		},
	)

export const ImageContent = t.intersection([
	legacyReader,
	t.strict({
		__TYPE__: t.literal(ImageContentType),
	}),
])

export type ImageContent = t.TypeOf<typeof ImageContent>
