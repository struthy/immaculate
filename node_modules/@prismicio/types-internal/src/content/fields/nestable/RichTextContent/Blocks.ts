import { either } from "fp-ts"
import { isLeft } from "fp-ts/lib/Either"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"
import { withFallback } from "io-ts-types"

import {
	RichTextNodeType,
	RichTextNodeTypeCodec,
} from "../../../../customtypes/widgets/nestable"
import { StringOrNull } from "../../../../validators"
import { nullable, refineType } from "../../../../validators/function"
import {
	EmbedContent,
	EmbedContentLegacy,
	EmbedContentType,
	EmbedLegacy,
} from "../EmbedContent"
import { ImageContentView } from "../ImageContent"
import { Link, LinkLegacy } from "../LinkContent"

const linkSpan = (linkCodec: typeof Link | typeof LinkLegacy) =>
	t.strict({
		data: linkCodec,
		start: t.number,
		end: t.number,
		type: t.literal(RichTextNodeType.hyperlink),
	})

const labelSpan = t.strict({
	data: withFallback(t.string, ""),
	start: t.number,
	end: t.number,
	type: t.literal("label"),
})

const basicSpan = t.strict({
	start: t.number,
	end: t.number,
	type: t.keyof({
		[RichTextNodeType.strong]: null,
		[RichTextNodeType.em]: null,
		"list-item": null, // legacy case that should not happen, we shouldn't support this in new page builder or migration API
	}),
})

export const Span = t.union([linkSpan(Link), labelSpan, basicSpan])
export type Span = t.TypeOf<typeof Span>

export const SpanLegacy = t.union([linkSpan(LinkLegacy), labelSpan, basicSpan])
export type SpanLegacy = t.TypeOf<typeof SpanLegacy>

export const ValidatedSpans = <C extends typeof Span | typeof SpanLegacy>(
	spanCodec: C,
) => {
	type S = t.TypeOf<C>

	return new t.Type<S[], S[], unknown>(
		"ValidatedSpans",
		(spans): spans is S[] => Array.isArray(spans) && spans.every(spanCodec.is),
		(spans: unknown, c) => {
			if (Array.isArray(spans)) {
				const res = spans
					.reduce<Array<S>>((acc, maybeSpan) => {
						const decodedSpan = spanCodec.decode(maybeSpan)
						if (isLeft(decodedSpan)) return acc
						return [...acc, decodedSpan.right]
					}, [])
					.sort((m1: S, m2: S) => m1.start - m2.start)
				return t.success(res)
			} else return t.failure(spans, c)
		},
		(m) => {
			return m.reduce<Array<S>>((acc, meta) => {
				const encoded = <S>spanCodec.encode(meta)
				return [...acc, encoded]
			}, [])
		},
	)
}

// We allow any codec here and let TypeScript infer the resulting codec.
// Typing it more precisely creates conflicts.
//
// Using `t.Mixed` rather than `t.Type<A, O>` causes `data.linkTo` to be
// typed as `any`. It seems to be an issue with the `nullable` helper.
const ImageBlockCodec = <A, O>(linkCodec: t.Type<A, O>) =>
	t.exact(
		t.intersection([
			t.type({
				type: t.literal(RichTextNodeType.image),
				data: t.intersection([
					ImageContentView,
					t.partial({
						linkTo: nullable(linkCodec),
					}),
				]),
			}),
			t.partial({
				label: StringOrNull,
				direction: StringOrNull,
			}),
		]),
	)

export const ImageBlock = ImageBlockCodec(Link)
export type ImageBlock = t.TypeOf<typeof ImageBlock>

const ImageBlockLegacy = ImageBlockCodec(LinkLegacy)
type ImageBlockLegacy = t.TypeOf<typeof ImageBlockLegacy>

export function checkImageBlock(block: Block): block is ImageBlock {
	return block.type === RichTextNodeType.image
}

const embedBlockLegacyCodec = t.exact(
	t.intersection([
		t.type({
			type: t.literal(RichTextNodeType.embed),
			data: t.unknown,
		}),
		t.partial({
			label: StringOrNull,
			direction: StringOrNull,
		}),
	]),
)

type EmbedBlockLegacy = t.TypeOf<typeof embedBlockLegacyCodec>

const EmbedBlockLegacy = new t.Type<EmbedBlock, EmbedBlockLegacy, unknown>(
	"EmbedBlockLegacy",
	(u): u is EmbedBlock => (u as EmbedBlock).type === "embed",
	(block) =>
		pipe(
			embedBlockLegacyCodec.decode(block),
			either.chain((decodedBlock) => {
				return either.map<EmbedLegacy, [EmbedBlockLegacy, EmbedLegacy]>(
					(decodedData: EmbedLegacy) => {
						return [decodedBlock, decodedData]
					},
				)(EmbedContentLegacy.decode(decodedBlock.data))
			}),
			either.map(([block, parsedData]) => {
				return EmbedBlock.encode({
					...block,
					data: {
						...parsedData,
						__TYPE__: EmbedContentType,
						all: block.data,
					},
				})
			}),
		),
	(embedBlock: EmbedBlock): EmbedBlockLegacy => {
		return {
			...embedBlockLegacyCodec.encode(embedBlock),
			data: EmbedContentLegacy.encode(embedBlock.data),
		}
	},
)
export const EmbedBlock = t.exact(
	t.intersection([
		t.type({
			type: t.literal(RichTextNodeType.embed),
			data: EmbedContent,
		}),
		t.partial({
			label: StringOrNull,
			direction: StringOrNull,
		}),
	]),
)
export type EmbedBlock = t.TypeOf<typeof EmbedBlock>
export function checkEmbedBlock(block: Block): block is EmbedBlock {
	return block.type === RichTextNodeType.embed
}

const TextBlockCodec = <C extends typeof Span | typeof SpanLegacy>(
	spanCodec: C,
) =>
	t.exact(
		t.intersection([
			t.type({
				type: refineType(
					RichTextNodeTypeCodec,
					`string which isn't ${RichTextNodeType.image} ${RichTextNodeType.embed}`,
					(s) => s !== RichTextNodeType.image && s !== RichTextNodeType.embed,
				),
				content: t.intersection([
					t.type({
						text: t.string,
					}),
					t.partial({
						spans: ValidatedSpans(spanCodec),
					}),
				]),
			}),
			t.partial({
				label: t.string,
				direction: t.string,
			}),
		]),
	)

/* These Text block will decode codec A and encode from codec B to A */
export const TextBlock = TextBlockCodec(Span)
export type TextBlock = t.TypeOf<typeof TextBlock>

const TextBlockLegacy = TextBlockCodec(SpanLegacy)
type TextBlockLegacy = t.TypeOf<typeof TextBlockLegacy>

const legacyBlockCodec = t.union([
	EmbedBlockLegacy,
	ImageBlockLegacy,
	TextBlockLegacy,
])
type BlockLegacy = t.TypeOf<typeof legacyBlockCodec>

export const BlockLegacy = new t.Type<Block, BlockLegacy, unknown>(
	"BlockLegacy",
	(u): u is Block =>
		EmbedBlockLegacy.is(u) || ImageBlockLegacy.is(u) || TextBlockLegacy.is(u),
	(legacyBlock) => legacyBlockCodec.decode(legacyBlock),
	(block: Block) => {
		return (() => {
			if (ImageBlock.is(block)) return ImageBlockLegacy.encode(block)
			else if (EmbedBlock.is(block)) return EmbedBlockLegacy.encode(block)
			else return TextBlockLegacy.encode(block)
		})() as BlockLegacy
	},
)
export const Block = t.union([ImageBlock, EmbedBlock, TextBlock])
export type Block = t.TypeOf<typeof Block>
