import { either } from "fp-ts"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import type { LegacyContentCtx, WithTypes } from "../../LegacyContentCtx"
import { hasContentType } from "../../utils"

export const IntegrationFieldContentType = "IntegrationFieldsContent"

export const isIntegrationFieldContent = (
	u: unknown,
): u is IntegrationFieldContent =>
	hasContentType(u) && u.__TYPE__ === IntegrationFieldContentType

type IntegrationFieldLegacy = string

export const IntegrationFieldLegacy = (ctx: LegacyContentCtx) =>
	new t.Type<
		IntegrationFieldContent,
		WithTypes<IntegrationFieldLegacy>,
		unknown
	>(
		"IntegrationFieldLegacy",
		isIntegrationFieldContent,
		(u) => {
			return pipe(
				t.string.decode(u),
				either.map((i) =>
					IntegrationFieldContent.encode({
						value: i,
						__TYPE__: IntegrationFieldContentType,
					}),
				),
			)
		},

		(i: IntegrationFieldContent) => {
			return {
				content: i.value,
				types: { [ctx.keyOfType]: "IntegrationFields" },
			}
		},
	)

export const IntegrationFieldContent = t.strict({
	__TYPE__: t.literal(IntegrationFieldContentType),
	value: t.string,
})

export type IntegrationFieldContent = t.TypeOf<typeof IntegrationFieldContent>
