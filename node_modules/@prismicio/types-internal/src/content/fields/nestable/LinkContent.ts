import { either } from "fp-ts"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"
import { withFallback } from "io-ts-types"

import { NonEmptyString, StringOrNull } from "../../../validators"
import { nullable } from "../../../validators/function"
import type { LegacyContentCtx, WithTypes } from "../../LegacyContentCtx"
import { hasContentType } from "../../utils"

export const ImageLinkType = "ImageLink"

const imageLinkLegacyCodec = t.exact(
	t.intersection([
		t.type({
			id: t.string,
			url: t.string,
			height: t.string,
			width: t.string,
			size: t.string,
			name: t.string,
			kind: t.string,
		}),
		t.partial({
			date: StringOrNull,
		}),
	]),
)
type ImageLinkLegacy = t.TypeOf<typeof imageLinkLegacyCodec>
const ImageLinkLegacy = new t.Type<ImageLinkContent, ImageLinkLegacy, unknown>(
	"ImageLink",
	(u): u is ImageLinkContent =>
		hasContentType(u) && u.__TYPE__ === ImageLinkType,
	(image) => {
		return pipe(
			imageLinkLegacyCodec.decode(image),
			either.map((parsedImage) => {
				return ImageLinkContent.encode({
					...parsedImage,
					__TYPE__: ImageLinkType,
				})
			}),
		)
	},
	(image: ImageLinkContent): ImageLinkLegacy => {
		return imageLinkLegacyCodec.encode(image)
	},
)

export const ImageLinkContent = t.intersection([
	t.strict({
		__TYPE__: t.literal(ImageLinkType),
	}),
	imageLinkLegacyCodec,
])
export type ImageLinkContent = t.TypeOf<typeof ImageLinkContent>

export const FileLinkType = "FileLink"

const fileLinkLegacyCodec = t.exact(
	t.intersection([
		t.type({
			id: t.string,
			url: t.string,
			name: t.string,
			kind: t.string,
			size: withFallback(t.string, "0"),
		}),
		t.partial({
			date: nullable(t.string),
		}),
	]),
)
type FileLinkLegacy = t.TypeOf<typeof fileLinkLegacyCodec>
const FileLinkLegacy = new t.Type<FileLinkContent, FileLinkLegacy>(
	"FileLink",
	(u): u is FileLinkContent => hasContentType(u) && u.__TYPE__ === FileLinkType,
	(file) => {
		return pipe(
			fileLinkLegacyCodec.decode(file),
			either.map((parsedFile) => {
				return FileLinkContent.encode({
					...parsedFile,
					__TYPE__: FileLinkType,
				})
			}),
		)
	},
	(file: FileLinkContent): FileLinkLegacy => {
		return fileLinkLegacyCodec.encode(file)
	},
)

export const FileLinkContent = t.intersection([
	fileLinkLegacyCodec,
	t.exact(
		t.intersection([
			t.type({
				__TYPE__: t.literal(FileLinkType),
			}),
			t.partial({
				size: withFallback(t.string, "0"),
			}),
		]),
	),
])
export type FileLinkContent = t.TypeOf<typeof FileLinkContent>

export const DocumentLinkType = "DocumentLink"

const documentLinkLegacyCodec = t.strict({ id: NonEmptyString })
type DocumentLinkLegacy = t.TypeOf<typeof documentLinkLegacyCodec>
const DocumentLinkLegacy = new t.Type<DocumentLinkContent, DocumentLinkLegacy>(
	"DocumentLink",
	(u): u is DocumentLinkContent =>
		hasContentType(u) && u.__TYPE__ === DocumentLinkType,
	(file) => {
		return pipe(
			documentLinkLegacyCodec.decode(file),
			either.map((parsedDoc) => {
				return DocumentLinkContent.encode({
					...parsedDoc,
					__TYPE__: DocumentLinkType,
				})
			}),
		)
	},
	(doc: DocumentLinkContent): DocumentLinkLegacy => {
		return documentLinkLegacyCodec.encode(doc)
	},
)
export const DocumentLinkContent = t.intersection([
	t.strict({
		__TYPE__: t.literal(DocumentLinkType),
	}),
	documentLinkLegacyCodec,
])
export type DocumentLinkContent = t.TypeOf<typeof DocumentLinkContent>

export const ExternalLinkType = "ExternalLink"

const externalLinkLegacyCodec = t.exact(
	t.intersection([
		t.type({
			url: t.string,
		}),
		t.partial({
			kind: t.literal("web"),
			target: StringOrNull,
			preview: nullable(
				t.partial({
					title: t.string,
				}),
			),
		}),
	]),
)

type ExternalLinkLegacy = t.TypeOf<typeof externalLinkLegacyCodec>
const ExternalLinkLegacy = new t.Type<ExternalLinkContent, ExternalLinkLegacy>(
	"ExternalLink",
	(u): u is ExternalLinkContent =>
		hasContentType(u) && u.__TYPE__ === ExternalLinkType,
	(file) => {
		return pipe(
			externalLinkLegacyCodec.decode(file),
			either.map((parsedLink) => {
				return ExternalLinkContent.encode({
					...parsedLink,
					__TYPE__: ExternalLinkType,
				})
			}),
		)
	},
	(link: ExternalLinkContent): ExternalLinkLegacy => {
		return externalLinkLegacyCodec.encode(link)
	},
)

export const ExternalLinkContent = t.intersection([
	t.strict({
		__TYPE__: t.literal(ExternalLinkType),
	}),
	externalLinkLegacyCodec,
])
export type ExternalLinkContent = t.TypeOf<typeof ExternalLinkContent>

export const LinkContentType = "LinkContent"

export const isLinkContent = (u: unknown): u is LinkContent =>
	hasContentType(u) && u.__TYPE__ === LinkContentType

export const LinkLegacy = t.union([
	ImageLinkLegacy,
	FileLinkLegacy,
	DocumentLinkLegacy,
	ExternalLinkLegacy,
])

type LinkLegacy = t.OutputOf<typeof LinkLegacy>

export const LinkContentLegacy = (ctx: LegacyContentCtx) =>
	new t.Type<LinkContent, WithTypes<LinkLegacy>, unknown>(
		"LinkLegacy",
		isLinkContent,
		(u) => {
			return pipe(
				LinkLegacy.decode(u),
				either.map((link) =>
					LinkContent.encode({
						value: link,
						__TYPE__: LinkContentType,
					}),
				),
			)
		},

		(link: LinkContent): WithTypes<LinkLegacy> => {
			return {
				content: LinkLegacy.encode(link.value),
				types: { [ctx.keyOfType]: "Link" },
			}
		},
	)

export const Link = t.union([
	ImageLinkContent,
	FileLinkContent,
	DocumentLinkContent,
	ExternalLinkContent,
])
export const LinkContent = t.strict({
	__TYPE__: t.literal(LinkContentType),
	value: Link,
})

export type LinkContent = t.TypeOf<typeof LinkContent>

export type LinksTypes =
	| LinkContent["__TYPE__"]
	| LinkContent["value"]["__TYPE__"]
