import { either } from "fp-ts"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import { NumberOrNull, StringOrNull } from "../../../validators"
import type { LegacyContentCtx, WithTypes } from "../../LegacyContentCtx"
import { hasContentType } from "../../utils"

export const EmbedContentType = "EmbedContent"

export const isEmbedContent = (u: unknown): u is EmbedContent =>
	hasContentType(u) && u.__TYPE__ === EmbedContentType

export const EmbedContentLegacy = t.exact(
	t.intersection([
		t.type({
			embed_url: t.string,
			type: t.string,
		}),
		t.partial({
			version: t.union([t.string, t.number, t.null]),
			title: StringOrNull,
			author_name: StringOrNull,
			author_url: StringOrNull,
			provider_name: StringOrNull,
			provider_url: StringOrNull,
			cache_age: t.union([t.string, t.number, t.null]),
			thumbnail_url: StringOrNull,
			thumbnail_width: NumberOrNull,
			thumbnail_height: NumberOrNull,
			html: StringOrNull,
		}),
	]),
)

export type EmbedLegacy = t.TypeOf<typeof EmbedContentLegacy>

export const EmbedLegacy = (ctx: LegacyContentCtx) =>
	new t.Type<EmbedContent, WithTypes<unknown>, unknown>(
		"EmbedLegacy",
		isEmbedContent,
		(u) => {
			return pipe(
				EmbedContentLegacy.decode(u),
				either.map((embed) => ({
					...embed,
					all: u,
					__TYPE__: EmbedContentType,
				})),
			)
		},

		(embed: EmbedContent) => {
			return {
				/**
				 *  we cast here because actually in the all property
				 * we can have extra keys that are never parsed and we don't want to loose them.
				 **/
				content: embed.all,
				types: { [ctx.keyOfType]: "Embed" },
			}
		},
	)

export const EmbedContent = t.intersection([
	EmbedContentLegacy,
	t.strict({
		__TYPE__: t.literal(EmbedContentType),
		all: t.unknown,
	}),
])

export type EmbedContent = t.TypeOf<typeof EmbedContent>
