import {
	type NestableWidget,
	type SlicePrimaryWidget,
	Group,
	GroupFieldType,
} from "../../customtypes"
import {
	GroupContent,
	GroupContentDefaultValue,
	GroupContentType,
	groupContentWithDefaultValues,
	isGroupContent,
} from "./GroupContent"
import type { NestableContent } from "./nestable"
import { NestableContentDefaultValue } from "./nestable"
import type { SlicePrimaryContent } from "./slices/Slice/SlicePrimaryContent"

export function withDefaultSlicePrimaryContentValues(
	customType: Record<string, SlicePrimaryWidget>,
	content: Partial<Record<string, SlicePrimaryContent>>,
): Record<string, SlicePrimaryContent> {
	const updatedContent = content as Record<string, SlicePrimaryContent>

	for (const [widgetKey, widgetDef] of Object.entries(customType)) {
		const widgetContent = content[widgetKey]

		if (widgetContent === undefined) {
			if (widgetDef.type === GroupFieldType) {
				updatedContent[widgetKey] = groupContentWithDefaultValues(
					widgetDef,
					GroupContentDefaultValue,
				)
			} else {
				const defaultValue = NestableContentDefaultValue(widgetDef)

				if (defaultValue) {
					updatedContent[widgetKey] = defaultValue
				}
			}

			continue
		}

		if (widgetDef.type === GroupFieldType && isGroupContent(widgetContent)) {
			updatedContent[widgetKey] = groupContentWithDefaultValues(
				widgetDef,
				widgetContent,
			)
		}
	}

	return updatedContent
}

export function withDefaultNestableContentValues(
	customType: Record<string, NestableWidget>,
	content: Record<string, NestableContent>,
): Record<string, NestableContent> {
	return Object.entries(customType).reduce<Record<string, NestableContent>>(
		(updatedContent, [widgetKey, widgetDef]) => {
			if (content[widgetKey] === undefined) {
				const defaultValue = NestableContentDefaultValue(widgetDef)
				return defaultValue !== undefined
					? {
							...updatedContent,
							[widgetKey]: defaultValue,
					  }
					: updatedContent
			}

			return updatedContent
		},
		content,
	)
}

export function repeatableContentWithDefaultNestableContentValues<
	T extends {
		value: [string, GroupContent | NestableContent][]
	},
>(fields: Record<string, Group | NestableWidget>, content: T[]): T[] {
	const groupKeys = Object.entries(fields)
	return content.map((contentItem) => {
		return groupKeys.reduce((updatedContentItem, [key, fieldDef]) => {
			const maybeContentItemValue = contentItem.value.find(
				([_key]) => _key === key,
			)

			if (fieldDef.type === "Group") {
				const defaultValue = groupContentWithDefaultValues(
					fieldDef,
					(maybeContentItemValue?.[1] as GroupContent | undefined) ?? {
						__TYPE__: GroupContentType,
						value: [],
					},
				)
				return {
					...updatedContentItem,
					value: [
						// Since there was default content for the group, we need to remove the old one
						...updatedContentItem.value.filter(([_key]) => _key !== key),
						...(defaultValue ? [[key, defaultValue]] : []),
					],
				}
			} else if (!maybeContentItemValue) {
				const defaultValue = NestableContentDefaultValue(fieldDef)
				return {
					...updatedContentItem,
					value: [
						...updatedContentItem.value,
						...(defaultValue ? [[key, defaultValue]] : []),
					],
				}
			}

			return updatedContentItem
		}, contentItem)
	})
}
