import * as t from "io-ts"

import { WidgetKey } from "../../../common"
import { StringOrNull } from "../../../validators"
import { CompositeSlice } from "./CompositeSlice"
import { LegacySlice } from "./LegacySlice"
import { SharedSlice } from "./SharedSlice"
import { SharedSliceRef } from "./SharedSliceRef"

export const LegacySlicesFieldType = "Choice"
export const SlicesFieldType = "Slices"

export const SlicesLabels = t.union([
	t.record(
		t.string,
		t.readonlyArray(
			t.exact(
				t.intersection([
					t.type({
						name: t.string,
					}),
					t.partial({
						display: t.string,
					}),
				]),
			),
		),
	),
	t.null,
])
export type SlicesLabels = t.TypeOf<typeof SlicesLabels>

export function slicesConfigReader<T extends SharedSlice | SharedSliceRef>(
	codec: t.Type<T, unknown>,
) {
	return t.exact(
		t.partial({
			label: StringOrNull,
			labels: SlicesLabels,
			choices: t.record(
				WidgetKey,
				t.union([LegacySlice, CompositeSlice, codec]),
			),
		}),
	)
}
export const StaticSlicesConfig = slicesConfigReader(SharedSlice)
export type StaticSlicesConfig = t.TypeOf<typeof StaticSlicesConfig>

export const DynamicSlicesConfig = slicesConfigReader(SharedSliceRef)
export type DynamicSlicesConfig = t.TypeOf<typeof DynamicSlicesConfig>

const SlicesConfig = {
	toStatic(
		config: DynamicSlicesConfig,
		sharedSlices: Map<string, SharedSlice>,
	): StaticSlicesConfig {
		const choices: {
			[key: string]: LegacySlice | CompositeSlice | SharedSlice
		} = Object.entries(config.choices || {}).reduce((acc, [ref, slice]) => {
			if (slice.type === "SharedSlice") {
				const sharedSlice = sharedSlices.get(ref)
				if (sharedSlice) return { ...acc, [ref]: sharedSlice }
				else return acc
			} else {
				return { ...acc, [ref]: slice }
			}
		}, {})

		return { ...config, choices } as StaticSlicesConfig
	},
}

export function slicesReader<
	T extends StaticSlicesConfig | DynamicSlicesConfig,
>(codec: t.Type<T, unknown>) {
	return t.exact(
		t.intersection([
			t.type({
				type: t.keyof({
					[SlicesFieldType]: null,
					[LegacySlicesFieldType]: null,
				}),
			}),
			t.partial({
				fieldset: StringOrNull,
				config: codec,
			}),
		]),
	)
}

export const StaticSlices = slicesReader(StaticSlicesConfig)
export type StaticSlices = t.TypeOf<typeof StaticSlices>

export const DynamicSlices = slicesReader(DynamicSlicesConfig)
export type DynamicSlices = t.TypeOf<typeof DynamicSlices>

export const Slices = {
	toStatic(
		slices: DynamicSlices,
		sharedSlices: Map<string, SharedSlice>,
	): StaticSlices {
		if (!slices.config) return slices as StaticSlices
		else {
			return {
				...slices,
				config: SlicesConfig.toStatic(slices.config, sharedSlices),
			}
		}
	},
}
