import * as t from "io-ts"

import { WidgetKey } from "../../common"
import { StringOrNull } from "../../validators"
import { NestableWidget } from "./nestable/NestableWidget"

export const GroupFieldType = "Group"

// We're obliged to use `t.Mixed` here, otherwise the factory would be
// referencing itself and TypeScript would infer its type as `any`
const createGroupConfig = <TWidgets extends t.Mixed>(widgets: TWidgets) =>
	t.exact(
		t.partial({
			label: StringOrNull,
			repeat: t.boolean,
			fields: t.record(WidgetKey, widgets),
		}),
	)

// We're obliged to use `t.Mixed` here, otherwise the factory would be
// referencing itself and TypeScript would infer its type as `any`
const createGroup = <TWidgets extends t.Mixed>(widgets: TWidgets) =>
	t.exact(
		t.intersection([
			t.type({
				type: t.literal(GroupFieldType),
			}),
			t.partial({
				fieldset: StringOrNull,
				icon: t.string,
				description: t.string,
				config: createGroupConfig(widgets),
			}),
		]),
	)

export const NestedGroupConfig = createGroupConfig(NestableWidget)
export type NestedGroupConfig = t.TypeOf<typeof NestedGroupConfig>

export const NestedGroup = createGroup(NestableWidget)
export type NestedGroup = t.TypeOf<typeof NestedGroup>

export const GroupConfig = createGroupConfig(
	t.union([NestableWidget, NestedGroup]),
)
export type GroupConfig = t.TypeOf<typeof GroupConfig>

export const Group = createGroup(t.union([NestableWidget, NestedGroup]))
export type Group = t.TypeOf<typeof Group>
