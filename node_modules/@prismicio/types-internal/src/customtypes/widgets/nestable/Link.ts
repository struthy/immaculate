import { either } from "fp-ts/lib/Either"
import * as t from "io-ts"
import { withFallback } from "io-ts-types/lib/withFallback"

import { StringOrNull } from "../../../validators"

const arrayString = (
	entries:
		| string
		| string[]
		| {
				[x: string]: {
					name: string
				}[]
		  }
		| undefined,
) => {
	if (entries instanceof Array) {
		const isValidEntries = entries.reduce(
			(acc, l) => acc && typeof l === "string",
			true,
		)
		if (isValidEntries) return t.success(entries)
	}
	return
}

const plainString = (
	entries:
		| string
		| string[]
		| {
				[x: string]: {
					name: string
				}[]
		  }
		| undefined,
) => {
	if (typeof entries === "string") {
		return t.success([entries])
	}
	return
}

const MasksArrayString = new t.Type<ReadonlyArray<string>, object, unknown>(
	"MasksArrayString",
	(u: unknown): u is ReadonlyArray<string> => {
		return u instanceof Array
	},
	(u: unknown, context: t.Context) => {
		return either.chain(
			t.union([t.array(t.string), t.string]).validate(u, context),
			(masks) => {
				return arrayString(masks) || plainString(masks) || t.failure(u, context)
			},
		)
	},
	(res) => res,
)

export const LinkFieldType = "Link"

export const LinkConfig = t.exact(
	t.partial({
		label: StringOrNull,
		useAsTitle: t.boolean,
		placeholder: t.string,
		select: withFallback(
			t.union([
				t.literal("media"),
				t.literal("document"),
				t.literal("web"),
				t.null,
			]),
			null,
		),
		customtypes: t.readonlyArray(t.string), // `customtypes` and `masks` are alternatives
		masks: MasksArrayString,
		tags: MasksArrayString,
		allowTargetBlank: t.boolean,
	}),
)
export type LinkConfig = t.TypeOf<typeof LinkConfig>

export const Link = t.exact(
	t.intersection([
		t.type({
			type: t.literal(LinkFieldType),
		}),
		t.partial({
			fieldset: StringOrNull,
			config: LinkConfig,
		}),
	]),
)
export type Link = t.TypeOf<typeof Link>
