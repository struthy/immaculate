"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateSliceItem = exports.SlicesItemLegacy = exports.sliceItemContentWithDefaultValues = exports.isSimpleSliceItemContent = exports.isCompositeSliceItemContent = exports.isSharedSliceItemContent = exports.SliceItemContent = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const function_2 = require("../../../validators/function");
const LegacyContentCtx_1 = require("../../LegacyContentCtx");
const GroupContent_1 = require("../GroupContent");
const nestable_1 = require("../nestable");
const withDefaultValues_1 = require("../withDefaultValues");
const Slice_1 = require("./Slice");
const CompositeSliceContent_1 = require("./Slice/CompositeSliceContent");
const SharedSliceContent_1 = require("./Slice/SharedSliceContent");
const SimpleSliceContent_1 = require("./Slice/SimpleSliceContent");
exports.SliceItemContent = t.type({
    key: t.string,
    name: t.string,
    maybeLabel: t.union([t.string, t.undefined]),
    widget: Slice_1.SliceContent,
});
function isSharedSliceItemContent(item) {
    return (0, SharedSliceContent_1.isSharedSliceContent)(item.widget);
}
exports.isSharedSliceItemContent = isSharedSliceItemContent;
function isCompositeSliceItemContent(item) {
    return (0, CompositeSliceContent_1.isCompositeSliceContent)(item.widget);
}
exports.isCompositeSliceItemContent = isCompositeSliceItemContent;
function isSimpleSliceItemContent(item) {
    return (0, GroupContent_1.isGroupContent)(item.widget) || (0, nestable_1.isNestableContent)(item.widget);
}
exports.isSimpleSliceItemContent = isSimpleSliceItemContent;
function sliceItemContentWithDefaultValues(customType, content) {
    var _a;
    if (customType.type === "SharedSlice" && (0, SharedSliceContent_1.isSharedSliceContent)(content)) {
        return (0, Slice_1.sharedSliceContentWithDefaultValues)(customType, content);
    }
    if (customType.type === "Slice" && (0, CompositeSliceContent_1.isCompositeSliceContent)(content)) {
        return (0, Slice_1.compositeSliceContentWithDefaultValues)(customType, content);
    }
    if (customType.type === "Group" &&
        (0, GroupContent_1.isGroupContent)(content) &&
        ((_a = customType.config) === null || _a === void 0 ? void 0 : _a.fields)) {
        const updateGroupFieldValue = (0, withDefaultValues_1.repeatableContentWithDefaultNestableContentValues)(customType.config.fields, content.value);
        return {
            ...content,
            value: updateGroupFieldValue,
        };
    }
    // Note - SimpleSliceContent can also be a NestableContent, but in that case we have no default value to fill, because the content is already there.
    // There is no key specified in custom type that does not have a value provided like in other cases.
    return content;
}
exports.sliceItemContentWithDefaultValues = sliceItemContentWithDefaultValues;
const itemLegacyReader = t.exact(t.intersection([
    t.type({
        key: t.string,
        value: t.unknown,
    }),
    t.partial({
        label: (0, function_2.nullable)(t.string),
    }),
]));
const SlicesItemLegacy = (ctx) => {
    return new t.Type("SlicesItemLegacy", (u) => ((0, SharedSliceContent_1.isSharedSliceContent)(u.widget),
        (0, CompositeSliceContent_1.isCompositeSliceContent)(u.widget),
        (0, SimpleSliceContent_1.isSimpleSliceContent)(u.widget)), (sliceItem, context) => {
        return (0, function_1.pipe)(itemLegacyReader.decode(sliceItem), fp_ts_1.either.chain((parsedSlice) => {
            var _a;
            const stopIdx = parsedSlice.key.indexOf("$");
            const sliceName = parsedSlice.key.substring(0, stopIdx > 0 ? stopIdx : undefined);
            const itemCtx = (0, LegacyContentCtx_1.getFieldCtx)(sliceName, ctx);
            const item = (0, Slice_1.SliceLegacy)(itemCtx).decode(parsedSlice.value);
            if (!item || (0, Either_1.isLeft)(item))
                return t.failure(sliceItem, context);
            return t.success({
                key: parsedSlice.key,
                name: sliceName,
                maybeLabel: (_a = parsedSlice.label) !== null && _a !== void 0 ? _a : undefined,
                widget: item.right,
            });
        }));
    }, (sItem) => {
        const itemCtx = (0, LegacyContentCtx_1.getFieldCtx)(sItem.name, ctx);
        const result = (0, Slice_1.SliceLegacy)(itemCtx).encode(sItem.widget);
        return {
            content: {
                key: sItem.key,
                label: sItem.maybeLabel,
                value: (result === null || result === void 0 ? void 0 : result.content) || {},
            },
            types: (result === null || result === void 0 ? void 0 : result.types) || {},
        };
    });
};
exports.SlicesItemLegacy = SlicesItemLegacy;
const migrateSliceItem = ({ model, content, }) => {
    if (isCompositeSliceItemContent(content) && (model === null || model === void 0 ? void 0 : model.type) === "SharedSlice")
        return (0, CompositeSliceContent_1.migrateCompositeSlice)(model, content);
    if (isSimpleSliceItemContent(content) && (model === null || model === void 0 ? void 0 : model.type) === "SharedSlice")
        return (0, SimpleSliceContent_1.migrateSimpleSlice)(model, content);
    return content;
};
exports.migrateSliceItem = migrateSliceItem;
