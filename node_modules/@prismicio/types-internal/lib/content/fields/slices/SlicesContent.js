"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseSlices = exports.slicesContentWithDefaultValues = exports.SlicesContent = exports.SlicesLegacy = exports.isSlicesContent = exports.SlicesContentType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const utils_1 = require("../../../_internal/utils");
const customtypes_1 = require("../../../customtypes");
const utils_2 = require("../../utils");
const CompositeSliceContent_1 = require("./Slice/CompositeSliceContent");
const SharedSliceContent_1 = require("./Slice/SharedSliceContent");
const SimpleSliceContent_1 = require("./Slice/SimpleSliceContent");
const SliceItem_1 = require("./SliceItem");
exports.SlicesContentType = "SliceContentType";
const isSlicesContent = (u) => (0, utils_2.hasContentType)(u) && u.__TYPE__ === exports.SlicesContentType;
exports.isSlicesContent = isSlicesContent;
const SlicesLegacy = (ctx) => {
    const codec = t.array((0, SliceItem_1.SlicesItemLegacy)(ctx));
    return new t.Type("SlicesLegacy", exports.isSlicesContent, (items) => {
        return (0, function_1.pipe)(codec.decode(items), fp_ts_1.either.map((parsedSlices) => {
            return {
                __TYPE__: exports.SlicesContentType,
                value: parsedSlices,
            };
        }));
    }, (s) => {
        const result = codec.encode(s.value);
        return {
            content: result.map((s) => s.content),
            types: result.reduce((acc, s) => ({ ...acc, ...s.types }), { [ctx.keyOfType]: "Slices" }),
        };
    });
};
exports.SlicesLegacy = SlicesLegacy;
exports.SlicesContent = t.type({
    __TYPE__: t.literal(exports.SlicesContentType),
    value: t.array(SliceItem_1.SliceItemContent),
});
function slicesContentWithDefaultValues(codec, content) {
    var _a;
    const choices = (_a = codec === null || codec === void 0 ? void 0 : codec.config) === null || _a === void 0 ? void 0 : _a.choices;
    if (choices === undefined)
        return content;
    const updateSlicesValue = content.value.map((slice) => {
        const sliceConfig = choices[slice.name];
        if (sliceConfig) {
            const updatedSliceWidget = (0, SliceItem_1.sliceItemContentWithDefaultValues)(sliceConfig, slice.widget);
            return {
                ...slice,
                widget: updatedSliceWidget,
            };
        }
        return slice;
    });
    return {
        ...content,
        value: updateSlicesValue,
    };
}
exports.slicesContentWithDefaultValues = slicesContentWithDefaultValues;
function findSliceModel(slicesPath, model, content) {
    var _a, _b;
    const defaultModel = (_b = (_a = model === null || model === void 0 ? void 0 : model.config) === null || _a === void 0 ? void 0 : _a.choices) === null || _b === void 0 ? void 0 : _b[content.name];
    // regular case for shared slices
    const sharedSliceModel = () => {
        if ((0, SliceItem_1.isSharedSliceItemContent)(content)) {
            if (defaultModel && (0, customtypes_1.isStaticSharedSlice)(defaultModel)) {
                const variationDef = defaultModel.variations.find((v) => v.id === content.widget.variation);
                return variationDef
                    ? {
                        type: "SharedSlice",
                        sliceName: defaultModel.id,
                        variationId: variationDef.id,
                        fields: {
                            primary: variationDef.primary || {},
                            items: variationDef.items || {},
                        },
                    }
                    : undefined;
            }
        }
        return;
    };
    const migratedSliceModel = () => {
        var _a;
        const legacyContentPath = utils_1.ContentPath.append(utils_1.ContentPath.serialize(slicesPath), content.name);
        const migratedSliceModel = Object.values(((_a = model === null || model === void 0 ? void 0 : model.config) === null || _a === void 0 ? void 0 : _a.choices) || {}).find((sliceModel) => {
            var _a;
            if ((0, customtypes_1.isStaticSharedSlice)(sliceModel)) {
                return !!((_a = sliceModel.legacyPaths) === null || _a === void 0 ? void 0 : _a[legacyContentPath]);
            }
            return false;
        });
        if (!migratedSliceModel)
            return;
        const migratedVariation = migratedSliceModel === null || migratedSliceModel === void 0 ? void 0 : migratedSliceModel.variations.find((v) => { var _a; return v.id === ((_a = migratedSliceModel.legacyPaths) === null || _a === void 0 ? void 0 : _a[legacyContentPath]); });
        if (!migratedVariation)
            return;
        return {
            type: "SharedSlice",
            sliceName: migratedSliceModel.id,
            variationId: migratedVariation.id,
            fields: {
                primary: migratedVariation.primary || {},
                items: migratedVariation.items || {},
            },
        };
    };
    const legacySliceModel = () => {
        if (!defaultModel)
            return;
        if ((0, customtypes_1.isCompositeSlice)(defaultModel)) {
            return {
                type: "Slice",
                "non-repeat": defaultModel["non-repeat"] || {},
                repeat: defaultModel.repeat || {},
            };
        }
        if ((0, customtypes_1.isLegacySlice)(defaultModel)) {
            return defaultModel;
        }
        return;
    };
    return sharedSliceModel() || migratedSliceModel() || legacySliceModel();
}
function traverseSlices({ path, key, model, content, }) {
    return ({ transformWidget = ({ content }) => content, transformSlice = ({ content }) => content, }) => {
        const value = content.value.reduce((acc, sliceContent) => {
            const sliceModel = model && findSliceModel(path, model, sliceContent);
            const convertedSlice = (() => {
                if ((0, SliceItem_1.isSharedSliceItemContent)(sliceContent))
                    return (0, SharedSliceContent_1.traverseSharedSliceContent)({
                        path: path.concat({
                            key: sliceContent.key,
                            type: "SharedSlice",
                        }),
                        sliceKey: sliceContent.key,
                        sliceName: sliceContent.name,
                        model: (sliceModel === null || sliceModel === void 0 ? void 0 : sliceModel.type) === "SharedSlice" ? sliceModel : undefined,
                        content: sliceContent,
                    })(transformWidget, transformSlice);
                if ((0, SliceItem_1.isCompositeSliceItemContent)(sliceContent))
                    return (0, CompositeSliceContent_1.traverseCompositeSliceContent)({
                        path: path.concat({
                            key: sliceContent.key,
                            type: "Slice",
                        }),
                        sliceKey: sliceContent.key,
                        sliceName: sliceContent.name,
                        model: (sliceModel === null || sliceModel === void 0 ? void 0 : sliceModel.type) === "Slice" ||
                            (sliceModel === null || sliceModel === void 0 ? void 0 : sliceModel.type) === "SharedSlice"
                            ? sliceModel
                            : undefined,
                        content: sliceContent,
                    })(transformWidget, transformSlice);
                if ((0, SliceItem_1.isSimpleSliceItemContent)(sliceContent))
                    return (0, SimpleSliceContent_1.traverseSimpleSliceContent)({
                        path: path.concat({
                            key: sliceContent.key,
                            type: "LegacySlice",
                        }),
                        sliceKey: sliceContent.key,
                        sliceName: sliceContent.name,
                        model: sliceModel && (sliceModel === null || sliceModel === void 0 ? void 0 : sliceModel.type) !== "Slice"
                            ? sliceModel
                            : undefined,
                        content: sliceContent,
                    })(transformWidget, transformSlice);
                return;
            })();
            return convertedSlice ? acc.concat(convertedSlice) : acc;
        }, []);
        return transformWidget({
            path,
            key,
            apiId: key,
            model,
            content: {
                __TYPE__: content.__TYPE__,
                value,
            },
        });
    };
}
exports.traverseSlices = traverseSlices;
