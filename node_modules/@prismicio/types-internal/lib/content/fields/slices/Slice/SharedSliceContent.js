"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseSharedSliceContent = exports.sharedSliceContentWithDefaultValues = exports.SharedSliceContent = exports.SharedSliceLegacy = exports.isSharedSliceContent = exports.SharedSliceContentType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const io_ts_types_1 = require("io-ts-types");
const customtypes_1 = require("../../../../customtypes");
const LegacyContentCtx_1 = require("../../../LegacyContentCtx");
const utils_1 = require("../../../utils");
const GroupContent_1 = require("../../GroupContent");
const nestable_1 = require("../../nestable");
const withDefaultValues_1 = require("../../withDefaultValues");
const RepeatableContent_1 = require("./RepeatableContent");
const SlicePrimaryContent_1 = require("./SlicePrimaryContent");
exports.SharedSliceContentType = "SharedSliceContent";
const isSharedSliceContent = (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.SharedSliceContentType;
exports.isSharedSliceContent = isSharedSliceContent;
const legacyReader = t.exact(t.type({
    variation: t.string,
    items: (0, io_ts_types_1.withFallback)(t.array(t.unknown), []),
    primary: (0, io_ts_types_1.withFallback)(t.UnknownRecord, {}),
}));
const SharedSliceLegacy = (ctx) => {
    return new t.Type("SharedSliceLegacy", exports.isSharedSliceContent, (slice) => {
        return (0, function_1.pipe)(legacyReader.decode(slice), fp_ts_1.either.map((parsedSlice) => {
            const items = (() => {
                const itemsCtx = (0, LegacyContentCtx_1.getFieldCtx)("items", ctx, [
                    "variations",
                    parsedSlice.variation,
                ]);
                const result = (0, RepeatableContent_1.RepeatableWidgetsLegacy)(itemsCtx).decode(parsedSlice.items);
                if (!result || (0, Either_1.isLeft)(result))
                    return;
                return result.right;
            })() || [];
            const primary = Object.entries(parsedSlice.primary).reduce((acc, [key, value]) => {
                const FieldCtx = (0, LegacyContentCtx_1.getFieldCtx)(key, ctx, [
                    "variations",
                    parsedSlice.variation,
                    "primary",
                ]);
                const result = (0, SlicePrimaryContent_1.SlicePrimaryLegacy)(FieldCtx).decode(value);
                if (!result)
                    return acc;
                if ((0, Either_1.isLeft)(result))
                    return acc;
                return { ...acc, [key]: result.right };
            }, {});
            return {
                variation: parsedSlice.variation,
                primary,
                items,
                __TYPE__: exports.SharedSliceContentType,
            };
        }));
    }, (s) => {
        const primary = Object.entries(s.primary).reduce((acc, [key, value]) => {
            const FieldCtx = (0, LegacyContentCtx_1.getFieldCtx)(key, ctx, [
                "variations",
                s.variation,
                "primary",
            ]);
            const result = (0, SlicePrimaryContent_1.SlicePrimaryLegacy)(FieldCtx).encode(value);
            if (!result)
                return acc;
            return {
                content: { ...acc.content, [key]: result.content },
                types: { ...acc.types, ...result.types },
            };
        }, { content: {}, types: {} });
        const items = (() => {
            const itemsCtx = (0, LegacyContentCtx_1.getFieldCtx)("items", ctx, [
                "variations",
                s.variation,
            ]);
            const result = (0, RepeatableContent_1.RepeatableWidgetsLegacy)(itemsCtx).encode(s.items);
            return result;
        })() || [];
        return {
            content: {
                primary: primary.content,
                items: items.map((i) => i.content),
                variation: s.variation,
            },
            types: {
                [ctx.keyOfType]: "SharedSlice",
                ...primary.types,
                ...items.reduce((acc, i) => ({ ...acc, ...i.types }), {}),
            },
        };
    });
};
exports.SharedSliceLegacy = SharedSliceLegacy;
exports.SharedSliceContent = t.strict({
    __TYPE__: t.literal(exports.SharedSliceContentType),
    variation: t.string,
    primary: t.record(t.string, SlicePrimaryContent_1.SlicePrimaryContent),
    items: RepeatableContent_1.RepeatableWidgets,
});
function sharedSliceContentWithDefaultValues(customType, content) {
    var _a, _b;
    const variationConfig = customType.variations.find((v) => v.id === content.variation);
    const primaryConfig = (_a = variationConfig === null || variationConfig === void 0 ? void 0 : variationConfig.primary) !== null && _a !== void 0 ? _a : {};
    const itemsConfig = (_b = variationConfig === null || variationConfig === void 0 ? void 0 : variationConfig.items) !== null && _b !== void 0 ? _b : {};
    const updatedPrimaryContent = (0, withDefaultValues_1.withDefaultSlicePrimaryContentValues)(primaryConfig, content.primary);
    const updatedItemsContent = (0, withDefaultValues_1.repeatableContentWithDefaultNestableContentValues)(itemsConfig, content.items);
    return {
        ...content,
        primary: updatedPrimaryContent,
        items: updatedItemsContent,
    };
}
exports.sharedSliceContentWithDefaultValues = sharedSliceContentWithDefaultValues;
function traverseSharedSliceContent({ path, sliceKey, sliceName, model, content, }) {
    return (transformWidget, transformSlice) => {
        const primary = Object.entries(content.widget.primary).reduce((acc, [fieldKey, fieldContent]) => {
            var _a, _b;
            const fieldDef = (_b = (_a = model === null || model === void 0 ? void 0 : model.fields) === null || _a === void 0 ? void 0 : _a.primary) === null || _b === void 0 ? void 0 : _b[fieldKey];
            const transformedField = (() => {
                if ((0, GroupContent_1.isGroupContent)(fieldContent)) {
                    return (0, GroupContent_1.traverseGroupContent)({
                        path: path.concat([
                            { key: "primary", type: "primary" },
                            { key: fieldKey, type: "Widget" },
                        ]),
                        key: fieldKey,
                        apiId: fieldKey,
                        content: fieldContent,
                        model: (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type) === customtypes_1.GroupFieldType ? fieldDef : undefined,
                    })(transformWidget);
                }
                else if ((0, nestable_1.isNestableContent)(fieldContent)) {
                    return transformWidget({
                        path: path.concat([
                            { key: "primary", type: "primary" },
                            { key: fieldKey, type: "Widget" },
                        ]),
                        key: fieldKey,
                        apiId: fieldKey,
                        model: fieldDef,
                        content: fieldContent,
                    });
                }
                else {
                    return undefined;
                }
            })();
            // Can happen if the transform function returns undefined to filter out a field
            if (!transformedField)
                return acc;
            if (!(0, SlicePrimaryContent_1.isSlicePrimaryContent)(transformedField)) {
                console.warn(`Warn: Non nestable or group content with key [${fieldKey}] detected in a shared slice [${sliceName}] with key [${sliceKey}]`);
            }
            return {
                ...acc,
                [fieldKey]: transformedField,
            };
        }, {});
        const items = (0, GroupContent_1.traverseGroupItemsContent)({
            path: path.concat([{ key: "items", type: "items" }]),
            model: model === null || model === void 0 ? void 0 : model.fields.items,
            content: content.widget.items,
        })(transformWidget);
        return transformSlice({
            key: sliceKey,
            apiId: sliceName,
            path,
            model: model,
            content: {
                ...content,
                widget: {
                    __TYPE__: "SharedSliceContent",
                    variation: content.widget.variation,
                    primary,
                    items,
                },
            },
        });
    };
}
exports.traverseSharedSliceContent = traverseSharedSliceContent;
