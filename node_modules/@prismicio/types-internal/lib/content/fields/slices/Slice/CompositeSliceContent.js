"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateCompositeSlice = exports.traverseCompositeSliceContent = exports.compositeSliceContentWithDefaultValues = exports.CompositeSliceContent = exports.CompositeSliceLegacy = exports.isCompositeSliceContent = exports.CompositeSliceContentType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const LegacyContentCtx_1 = require("../../../LegacyContentCtx");
const utils_1 = require("../../../utils");
const GroupContent_1 = require("../../GroupContent");
const nestable_1 = require("../../nestable");
const withDefaultValues_1 = require("../../withDefaultValues");
const RepeatableContent_1 = require("./RepeatableContent");
exports.CompositeSliceContentType = "CompositeSliceContent";
const isCompositeSliceContent = (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.CompositeSliceContentType;
exports.isCompositeSliceContent = isCompositeSliceContent;
const legacyReader = t.exact(t.partial({
    repeat: t.array(t.unknown),
    "non-repeat": t.UnknownRecord,
}));
const CompositeSliceLegacy = (ctx) => {
    return new t.Type("CompositeSliceLegacy", exports.isCompositeSliceContent, (slice) => {
        return (0, function_1.pipe)(legacyReader.decode(slice), fp_ts_1.either.map((parsedSlice) => {
            const repeat = (() => {
                const itemsCtx = (0, LegacyContentCtx_1.getFieldCtx)("repeat", ctx);
                const result = (0, RepeatableContent_1.RepeatableWidgetsLegacy)(itemsCtx).decode(parsedSlice.repeat);
                if (!result || (0, Either_1.isLeft)(result))
                    return;
                return result.right;
            })() || [];
            const nonRepeat = Object.entries(parsedSlice["non-repeat"] || {}).reduce((acc, [key, value]) => {
                const fieldCtx = (0, LegacyContentCtx_1.getFieldCtx)(key, ctx, ["non-repeat"]);
                if (!fieldCtx)
                    return acc;
                const result = (0, nestable_1.NestableLegacy)(fieldCtx).decode(value);
                if (!result)
                    return acc;
                if ((0, Either_1.isLeft)(result))
                    return acc;
                return { ...acc, [key]: result.right };
            }, {});
            return {
                nonRepeat,
                repeat,
                __TYPE__: exports.CompositeSliceContentType,
            };
        }));
    }, (s) => {
        const nonRepeat = Object.entries(s.nonRepeat).reduce((acc, [key, value]) => {
            const FieldCtx = (0, LegacyContentCtx_1.getFieldCtx)(key, ctx, ["non-repeat"]);
            const result = (0, nestable_1.NestableLegacy)(FieldCtx).encode(value);
            if (!result)
                return acc;
            return {
                content: { ...acc.content, [key]: result.content },
                types: { ...acc.types, ...result.types },
            };
        }, { content: {}, types: {} });
        const repeat = (() => {
            const itemsCtx = (0, LegacyContentCtx_1.getFieldCtx)("repeat", ctx);
            const result = (0, RepeatableContent_1.RepeatableWidgetsLegacy)(itemsCtx).encode(s.repeat);
            return result;
        })() || [];
        return {
            content: {
                "non-repeat": nonRepeat.content,
                repeat: repeat.map((i) => i.content),
            },
            types: {
                [ctx.keyOfType]: "Slice",
                ...nonRepeat.types,
                ...repeat.reduce((acc, i) => ({ ...acc, ...i.types }), {}),
            },
        };
    });
};
exports.CompositeSliceLegacy = CompositeSliceLegacy;
exports.CompositeSliceContent = t.strict({
    __TYPE__: t.literal(exports.CompositeSliceContentType),
    nonRepeat: t.record(t.string, nestable_1.NestableContent),
    repeat: RepeatableContent_1.RepeatableWidgets,
});
function compositeSliceContentWithDefaultValues(customType, content) {
    var _a, _b;
    const updatedNonRepeatContent = (0, withDefaultValues_1.withDefaultNestableContentValues)((_a = customType["non-repeat"]) !== null && _a !== void 0 ? _a : {}, content.nonRepeat);
    const updatedRepeatContent = (0, withDefaultValues_1.repeatableContentWithDefaultNestableContentValues)((_b = customType.repeat) !== null && _b !== void 0 ? _b : {}, content.repeat);
    return {
        ...content,
        nonRepeat: updatedNonRepeatContent,
        repeat: updatedRepeatContent,
    };
}
exports.compositeSliceContentWithDefaultValues = compositeSliceContentWithDefaultValues;
function traverseCompositeSliceContent({ path, sliceKey, sliceName, model, content, }) {
    return (transformWidget, transformSlice) => {
        const primary = Object.entries(content.widget.nonRepeat).reduce((acc, [fieldKey, fieldContent]) => {
            const fieldDef = (() => {
                var _a, _b, _c;
                return (model === null || model === void 0 ? void 0 : model.type) === "SharedSlice"
                    ? (_b = (_a = model === null || model === void 0 ? void 0 : model.fields) === null || _a === void 0 ? void 0 : _a.primary) === null || _b === void 0 ? void 0 : _b[fieldKey]
                    : (_c = model === null || model === void 0 ? void 0 : model["non-repeat"]) === null || _c === void 0 ? void 0 : _c[fieldKey];
            })();
            const transformedField = transformWidget({
                path: path.concat([
                    { key: "non-repeat", type: "primary" },
                    { key: fieldKey, type: "Widget" },
                ]),
                key: fieldKey,
                apiId: sliceName,
                model: fieldDef,
                content: fieldContent,
            });
            // Can happen if the transform function returns undefined to filter out a field
            if (!transformedField)
                return acc;
            if (!(0, nestable_1.isNestableContent)(transformedField)) {
                console.warn(`Warn: Non nestable content with key [${fieldKey}] detected in a composite slice [${sliceName}] with key [${sliceKey}]`);
                return acc;
            }
            return {
                ...acc,
                [fieldKey]: transformedField,
            };
        }, {});
        const items = (0, GroupContent_1.traverseGroupItemsContent)({
            path: path.concat([{ key: "repeat", type: "items" }]),
            model: (model === null || model === void 0 ? void 0 : model.type) === "SharedSlice" ? model === null || model === void 0 ? void 0 : model.fields.items : model === null || model === void 0 ? void 0 : model.repeat,
            content: content.widget.repeat,
        })(transformWidget);
        return transformSlice({
            key: sliceKey,
            apiId: sliceName,
            path,
            model,
            content: {
                ...content,
                widget: {
                    __TYPE__: "CompositeSliceContent",
                    repeat: items,
                    nonRepeat: primary,
                },
            },
        });
    };
}
exports.traverseCompositeSliceContent = traverseCompositeSliceContent;
function migrateCompositeSlice(model, content) {
    const [, sliceUUID] = content.key.split("$");
    return {
        key: `${model.sliceName}$${sliceUUID}`,
        name: model.sliceName,
        maybeLabel: content.maybeLabel,
        widget: {
            __TYPE__: "SharedSliceContent",
            variation: model.variationId,
            primary: Object.entries(content.widget.nonRepeat).reduce((acc, [fieldKey, fieldContent]) => {
                var _a;
                if (!((_a = model.fields.primary) === null || _a === void 0 ? void 0 : _a[fieldKey])) {
                    console.warn(`The widget ${fieldKey} in the non-repeat zone of the composite slice [${model.sliceName}] with key [${content.key}] doesn't exist in the model.`);
                    return acc;
                }
                return { ...acc, [fieldKey]: fieldContent };
            }, {}),
            items: content.widget.repeat.map((groupItem) => {
                return {
                    __TYPE__: "GroupItemContent",
                    value: groupItem.value.reduce((acc, [fieldKey, fieldContent]) => {
                        var _a;
                        if (!((_a = model.fields.items) === null || _a === void 0 ? void 0 : _a[fieldKey])) {
                            console.warn(`The widget ${fieldKey} in the repeat zone of the composite slice [${model.sliceName}] with key [${content.key}] doesn't exist in the model.`);
                            return acc;
                        }
                        return acc.concat([[fieldKey, fieldContent]]);
                    }, []),
                };
            }, []),
        },
    };
}
exports.migrateCompositeSlice = migrateCompositeSlice;
