"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextBlockLegacy = exports.ParagraphBlock = exports.TextBlock = exports.ValidatedSpans = exports.SpanLegacy = exports.Span = void 0;
const tslib_1 = require("tslib");
const Either_1 = require("fp-ts/lib/Either");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const io_ts_types_1 = require("io-ts-types");
const nestable_1 = require("../../../../customtypes/widgets/nestable");
const function_1 = require("../../../../validators/function");
const LinkContent_1 = require("../LinkContent");
const linkSpan = (linkCodec) => t.strict({
    data: linkCodec,
    start: t.number,
    end: t.number,
    type: t.literal(nestable_1.RichTextNodeType.hyperlink),
});
const labelSpan = t.strict({
    data: (0, io_ts_types_1.withFallback)(t.string, ""),
    start: t.number,
    end: t.number,
    type: t.literal("label"),
});
const basicSpan = t.strict({
    start: t.number,
    end: t.number,
    type: t.keyof({
        [nestable_1.RichTextNodeType.strong]: null,
        [nestable_1.RichTextNodeType.em]: null,
        "list-item": null, // legacy case that should not happen, we shouldn't support this in new page builder or migration API
    }),
});
exports.Span = t.union([linkSpan(LinkContent_1.Link), labelSpan, basicSpan]);
exports.SpanLegacy = t.union([linkSpan(LinkContent_1.LinkLegacy), labelSpan, basicSpan]);
const ValidatedSpans = (spanCodec) => {
    return new t.Type("ValidatedSpans", (spans) => Array.isArray(spans) && spans.every(spanCodec.is), (spans, c) => {
        if (Array.isArray(spans)) {
            const res = spans
                .reduce((acc, maybeSpan) => {
                const decodedSpan = spanCodec.decode(maybeSpan);
                if ((0, Either_1.isLeft)(decodedSpan))
                    return acc;
                return [...acc, decodedSpan.right];
            }, [])
                .sort((m1, m2) => m1.start - m2.start);
            return t.success(res);
        }
        else
            return t.failure(spans, c);
    }, (m) => {
        return m.reduce((acc, meta) => {
            const encoded = spanCodec.encode(meta);
            return [...acc, encoded];
        }, []);
    });
};
exports.ValidatedSpans = ValidatedSpans;
const TextBlockCodec = (spanCodec, nodeFilter) => t.exact(t.intersection([
    t.type({
        type: nodeFilter
            ? (0, function_1.refineType)(nestable_1.RichTextNodeTypeCodec, `string which isn't ${nestable_1.RichTextNodeType.image} ${nestable_1.RichTextNodeType.embed}`, nodeFilter)
            : nestable_1.RichTextNodeTypeCodec,
        content: t.intersection([
            t.type({
                text: t.string,
            }),
            t.partial({
                spans: (0, exports.ValidatedSpans)(spanCodec),
            }),
        ]),
    }),
    t.partial({
        label: t.string,
        direction: t.string,
    }),
]));
/* These Text block will decode codec A and encode from codec B to A */
exports.TextBlock = TextBlockCodec(exports.Span, (nodeType) => nodeType !== nestable_1.RichTextNodeType.image && nodeType !== nestable_1.RichTextNodeType.embed);
/** A paragraph Text block. Paragraphs may contain spans. */
exports.ParagraphBlock = TextBlockCodec(exports.Span, (nodeType) => nodeType === nestable_1.RichTextNodeType.paragraph);
exports.TextBlockLegacy = TextBlockCodec(exports.SpanLegacy);
