"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = exports.BlockLegacy = exports.TextBlock = exports.checkEmbedBlock = exports.EmbedBlock = exports.checkImageBlock = exports.ImageBlock = exports.ValidatedSpans = exports.SpanLegacy = exports.Span = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const io_ts_types_1 = require("io-ts-types");
const nestable_1 = require("../../../../customtypes/widgets/nestable");
const validators_1 = require("../../../../validators");
const function_2 = require("../../../../validators/function");
const EmbedContent_1 = require("../EmbedContent");
const ImageContent_1 = require("../ImageContent");
const LinkContent_1 = require("../LinkContent");
const linkSpan = (linkCodec) => t.strict({
    data: linkCodec,
    start: t.number,
    end: t.number,
    type: t.literal(nestable_1.RichTextNodeType.hyperlink),
});
const labelSpan = t.strict({
    data: (0, io_ts_types_1.withFallback)(t.string, ""),
    start: t.number,
    end: t.number,
    type: t.literal("label"),
});
const basicSpan = t.strict({
    start: t.number,
    end: t.number,
    type: t.keyof({
        [nestable_1.RichTextNodeType.strong]: null,
        [nestable_1.RichTextNodeType.em]: null,
        "list-item": null, // legacy case that should not happen, we shouldn't support this in new page builder or migration API
    }),
});
exports.Span = t.union([linkSpan(LinkContent_1.Link), labelSpan, basicSpan]);
exports.SpanLegacy = t.union([linkSpan(LinkContent_1.LinkLegacy), labelSpan, basicSpan]);
const ValidatedSpans = (spanCodec) => {
    return new t.Type("ValidatedSpans", (spans) => Array.isArray(spans) && spans.every(spanCodec.is), (spans, c) => {
        if (Array.isArray(spans)) {
            const res = spans
                .reduce((acc, maybeSpan) => {
                const decodedSpan = spanCodec.decode(maybeSpan);
                if ((0, Either_1.isLeft)(decodedSpan))
                    return acc;
                return [...acc, decodedSpan.right];
            }, [])
                .sort((m1, m2) => m1.start - m2.start);
            return t.success(res);
        }
        else
            return t.failure(spans, c);
    }, (m) => {
        return m.reduce((acc, meta) => {
            const encoded = spanCodec.encode(meta);
            return [...acc, encoded];
        }, []);
    });
};
exports.ValidatedSpans = ValidatedSpans;
// We allow any codec here and let TypeScript infer the resulting codec.
// Typing it more precisely creates conflicts.
//
// Using `t.Mixed` rather than `t.Type<A, O>` causes `data.linkTo` to be
// typed as `any`. It seems to be an issue with the `nullable` helper.
const ImageBlockCodec = (linkCodec) => t.exact(t.intersection([
    t.type({
        type: t.literal(nestable_1.RichTextNodeType.image),
        data: t.intersection([
            ImageContent_1.ImageContentView,
            t.partial({
                linkTo: (0, function_2.nullable)(linkCodec),
            }),
        ]),
    }),
    t.partial({
        label: validators_1.StringOrNull,
        direction: validators_1.StringOrNull,
    }),
]));
exports.ImageBlock = ImageBlockCodec(LinkContent_1.Link);
const ImageBlockLegacy = ImageBlockCodec(LinkContent_1.LinkLegacy);
function checkImageBlock(block) {
    return block.type === nestable_1.RichTextNodeType.image;
}
exports.checkImageBlock = checkImageBlock;
const embedBlockLegacyCodec = t.exact(t.intersection([
    t.type({
        type: t.literal(nestable_1.RichTextNodeType.embed),
        data: t.unknown,
    }),
    t.partial({
        label: validators_1.StringOrNull,
        direction: validators_1.StringOrNull,
    }),
]));
const EmbedBlockLegacy = new t.Type("EmbedBlockLegacy", (u) => u.type === "embed", (block) => (0, function_1.pipe)(embedBlockLegacyCodec.decode(block), fp_ts_1.either.chain((decodedBlock) => {
    return fp_ts_1.either.map((decodedData) => {
        return [decodedBlock, decodedData];
    })(EmbedContent_1.EmbedContentLegacy.decode(decodedBlock.data));
}), fp_ts_1.either.map(([block, parsedData]) => {
    return exports.EmbedBlock.encode({
        ...block,
        data: {
            ...parsedData,
            __TYPE__: EmbedContent_1.EmbedContentType,
            all: block.data,
        },
    });
})), (embedBlock) => {
    return {
        ...embedBlockLegacyCodec.encode(embedBlock),
        data: EmbedContent_1.EmbedContentLegacy.encode(embedBlock.data),
    };
});
exports.EmbedBlock = t.exact(t.intersection([
    t.type({
        type: t.literal(nestable_1.RichTextNodeType.embed),
        data: EmbedContent_1.EmbedContent,
    }),
    t.partial({
        label: validators_1.StringOrNull,
        direction: validators_1.StringOrNull,
    }),
]));
function checkEmbedBlock(block) {
    return block.type === nestable_1.RichTextNodeType.embed;
}
exports.checkEmbedBlock = checkEmbedBlock;
const TextBlockCodec = (spanCodec) => t.exact(t.intersection([
    t.type({
        type: (0, function_2.refineType)(nestable_1.RichTextNodeTypeCodec, `string which isn't ${nestable_1.RichTextNodeType.image} ${nestable_1.RichTextNodeType.embed}`, (s) => s !== nestable_1.RichTextNodeType.image && s !== nestable_1.RichTextNodeType.embed),
        content: t.intersection([
            t.type({
                text: t.string,
            }),
            t.partial({
                spans: (0, exports.ValidatedSpans)(spanCodec),
            }),
        ]),
    }),
    t.partial({
        label: t.string,
        direction: t.string,
    }),
]));
/* These Text block will decode codec A and encode from codec B to A */
exports.TextBlock = TextBlockCodec(exports.Span);
const TextBlockLegacy = TextBlockCodec(exports.SpanLegacy);
const legacyBlockCodec = t.union([
    EmbedBlockLegacy,
    ImageBlockLegacy,
    TextBlockLegacy,
]);
exports.BlockLegacy = new t.Type("BlockLegacy", (u) => EmbedBlockLegacy.is(u) || ImageBlockLegacy.is(u) || TextBlockLegacy.is(u), (legacyBlock) => legacyBlockCodec.decode(legacyBlock), (block) => {
    return (() => {
        if (exports.ImageBlock.is(block))
            return ImageBlockLegacy.encode(block);
        else if (exports.EmbedBlock.is(block))
            return EmbedBlockLegacy.encode(block);
        else
            return TextBlockLegacy.encode(block);
    })();
});
exports.Block = t.union([exports.ImageBlock, exports.EmbedBlock, exports.TextBlock]);
