"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkContent = exports.Link = exports.LinkContentLegacy = exports.LinkLegacy = exports.isLinkContent = exports.LinkContentType = exports.ExternalLinkContent = exports.ExternalLinkType = exports.DocumentLinkContent = exports.DocumentLinkType = exports.FileLinkContent = exports.FileLinkType = exports.ImageLinkContent = exports.ImageLinkType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const io_ts_types_1 = require("io-ts-types");
const validators_1 = require("../../../validators");
const function_2 = require("../../../validators/function");
const utils_1 = require("../../utils");
exports.ImageLinkType = "ImageLink";
const imageLinkLegacyCodec = t.exact(t.intersection([
    t.type({
        id: t.string,
        url: t.string,
        height: t.string,
        width: t.string,
        size: t.string,
        name: t.string,
        kind: t.string,
    }),
    t.partial({
        date: validators_1.StringOrNull,
    }),
]));
const ImageLinkLegacy = new t.Type("ImageLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.ImageLinkType, (image) => {
    return (0, function_1.pipe)(imageLinkLegacyCodec.decode(image), fp_ts_1.either.map((parsedImage) => {
        return exports.ImageLinkContent.encode({
            ...parsedImage,
            __TYPE__: exports.ImageLinkType,
        });
    }));
}, (image) => {
    return imageLinkLegacyCodec.encode(image);
});
exports.ImageLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.ImageLinkType),
    }),
    imageLinkLegacyCodec,
]);
exports.FileLinkType = "FileLink";
const fileLinkLegacyCodec = t.exact(t.intersection([
    t.type({
        id: t.string,
        url: t.string,
        name: t.string,
        kind: t.string,
        size: (0, io_ts_types_1.withFallback)(t.string, "0"),
    }),
    t.partial({
        date: (0, function_2.nullable)(t.string),
    }),
]));
const FileLinkLegacy = new t.Type("FileLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.FileLinkType, (file) => {
    return (0, function_1.pipe)(fileLinkLegacyCodec.decode(file), fp_ts_1.either.map((parsedFile) => {
        return exports.FileLinkContent.encode({
            ...parsedFile,
            __TYPE__: exports.FileLinkType,
        });
    }));
}, (file) => {
    return fileLinkLegacyCodec.encode(file);
});
exports.FileLinkContent = t.intersection([
    fileLinkLegacyCodec,
    t.exact(t.intersection([
        t.type({
            __TYPE__: t.literal(exports.FileLinkType),
        }),
        t.partial({
            size: (0, io_ts_types_1.withFallback)(t.string, "0"),
        }),
    ])),
]);
exports.DocumentLinkType = "DocumentLink";
const documentLinkLegacyCodec = t.strict({ id: validators_1.NonEmptyString });
const DocumentLinkLegacy = new t.Type("DocumentLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.DocumentLinkType, (file) => {
    return (0, function_1.pipe)(documentLinkLegacyCodec.decode(file), fp_ts_1.either.map((parsedDoc) => {
        return exports.DocumentLinkContent.encode({
            ...parsedDoc,
            __TYPE__: exports.DocumentLinkType,
        });
    }));
}, (doc) => {
    return documentLinkLegacyCodec.encode(doc);
});
exports.DocumentLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.DocumentLinkType),
    }),
    documentLinkLegacyCodec,
]);
exports.ExternalLinkType = "ExternalLink";
const externalLinkLegacyCodec = t.exact(t.intersection([
    t.type({
        url: t.string,
    }),
    t.partial({
        kind: t.literal("web"),
        target: validators_1.StringOrNull,
        preview: (0, function_2.nullable)(t.partial({
            title: t.string,
        })),
    }),
]));
const ExternalLinkLegacy = new t.Type("ExternalLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.ExternalLinkType, (file) => {
    return (0, function_1.pipe)(externalLinkLegacyCodec.decode(file), fp_ts_1.either.map((parsedLink) => {
        return exports.ExternalLinkContent.encode({
            ...parsedLink,
            __TYPE__: exports.ExternalLinkType,
        });
    }));
}, (link) => {
    return externalLinkLegacyCodec.encode(link);
});
exports.ExternalLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.ExternalLinkType),
    }),
    externalLinkLegacyCodec,
]);
exports.LinkContentType = "LinkContent";
const isLinkContent = (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.LinkContentType;
exports.isLinkContent = isLinkContent;
exports.LinkLegacy = t.union([
    ImageLinkLegacy,
    FileLinkLegacy,
    DocumentLinkLegacy,
    ExternalLinkLegacy,
]);
const LinkContentLegacy = (ctx) => new t.Type("LinkLegacy", exports.isLinkContent, (u) => {
    return (0, function_1.pipe)(exports.LinkLegacy.decode(u), fp_ts_1.either.map((link) => exports.LinkContent.encode({
        value: link,
        __TYPE__: exports.LinkContentType,
    })));
}, (link) => {
    return {
        content: exports.LinkLegacy.encode(link.value),
        types: { [ctx.keyOfType]: "Link" },
    };
});
exports.LinkContentLegacy = LinkContentLegacy;
exports.Link = t.union([
    exports.ImageLinkContent,
    exports.FileLinkContent,
    exports.DocumentLinkContent,
    exports.ExternalLinkContent,
]);
exports.LinkContent = t.strict({
    __TYPE__: t.literal(exports.LinkContentType),
    value: exports.Link,
});
