"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseGroupItemsContent = exports.traverseGroupContent = exports.groupContentWithDefaultValues = exports.GroupLegacy = exports.GroupItemLegacy = exports.GroupContentDefaultValue = exports.isGroupContent = exports.GroupContent = exports.GroupItemContent = exports.GroupContentType = exports.GroupItemContentType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const customtypes_1 = require("../../customtypes");
const LegacyContentCtx_1 = require("../LegacyContentCtx");
const utils_1 = require("../utils");
const nestable_1 = require("./nestable");
const withDefaultValues_1 = require("./withDefaultValues");
exports.GroupItemContentType = "GroupItemContent";
exports.GroupContentType = "GroupContentType";
exports.GroupItemContent = t.recursion("GroupItemContent", () => t.strict({
    __TYPE__: t.literal(exports.GroupItemContentType),
    value: t.array(t.tuple([t.string, t.union([nestable_1.NestableContent, exports.GroupContent])])),
}));
exports.GroupContent = t.recursion("GroupContent", () => t.strict({
    __TYPE__: t.literal(exports.GroupContentType),
    value: t.array(exports.GroupItemContent),
}));
exports.isGroupContent = exports.GroupContent.is;
exports.GroupContentDefaultValue = {
    __TYPE__: exports.GroupContentType,
    value: [],
};
const itemLegacyReader = t.record(t.string, t.unknown);
const GroupItemLegacy = (ctx) => {
    return new t.Type("GroupItemLegacy", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.GroupItemContentType, (u) => {
        const parsed = (0, function_1.pipe)(itemLegacyReader.decode(u), fp_ts_1.either.map((items) => {
            const parsedItems = Object.entries(items).reduce((acc, [itemKey, itemValue]) => {
                const itemCtx = (0, LegacyContentCtx_1.getFieldCtx)(itemKey, ctx);
                const result = itemCtx.fieldType === customtypes_1.GroupFieldType
                    ? (0, exports.GroupLegacy)(itemCtx).decode(itemValue)
                    : (0, nestable_1.NestableLegacy)(itemCtx).decode(itemValue);
                if (!result)
                    return acc;
                if ((0, Either_1.isLeft)(result))
                    return acc;
                return [...acc, [itemKey, result.right]];
            }, []);
            return {
                value: parsedItems,
                __TYPE__: exports.GroupItemContentType,
            };
        }));
        return parsed;
    }, (item) => {
        return item.value.reduce((acc, [key, value]) => {
            const itemCtx = (0, LegacyContentCtx_1.getFieldCtx)(key, ctx);
            const encoded = (0, exports.isGroupContent)(value)
                ? (0, exports.GroupLegacy)(itemCtx).encode(value)
                : (0, nestable_1.NestableLegacy)(itemCtx).encode(value);
            if (!encoded)
                return acc;
            return {
                content: { ...acc.content, [key]: encoded.content },
                types: { ...acc.types, ...encoded.types },
            };
        }, { content: {}, types: {} });
    });
};
exports.GroupItemLegacy = GroupItemLegacy;
const GroupLegacy = (ctx) => {
    const codecDecode = t.array(t.union([t.null, (0, exports.GroupItemLegacy)(ctx)]));
    const codecEncode = t.array((0, exports.GroupItemLegacy)(ctx));
    return new t.Type("GroupLegacy", exports.isGroupContent, (items) => {
        return (0, function_1.pipe)(codecDecode.decode(items), fp_ts_1.either.map((parsedItems) => {
            return {
                value: parsedItems.map((i) => {
                    if (i === null) {
                        return { __TYPE__: exports.GroupItemContentType, value: [] };
                    }
                    else
                        return i;
                }),
                __TYPE__: exports.GroupContentType,
            };
        }));
    }, (g) => {
        const res = codecEncode.encode(g.value);
        return {
            content: res.map((block) => block.content),
            types: res.reduce((acc, block) => {
                return { ...acc, ...block.types };
            }, { [ctx.keyOfType]: customtypes_1.GroupFieldType }),
        };
    });
};
exports.GroupLegacy = GroupLegacy;
function groupContentWithDefaultValues(customType, content) {
    var _a;
    const fields = (_a = customType.config) === null || _a === void 0 ? void 0 : _a.fields;
    if (!fields)
        return content;
    return {
        ...content,
        value: (0, withDefaultValues_1.repeatableContentWithDefaultNestableContentValues)(fields, content.value),
    };
}
exports.groupContentWithDefaultValues = groupContentWithDefaultValues;
function traverseGroupContent({ path, key, apiId, model, content, }) {
    return (transform) => {
        var _a;
        const groupItems = traverseGroupItemsContent({
            path,
            model: (_a = model === null || model === void 0 ? void 0 : model.config) === null || _a === void 0 ? void 0 : _a.fields,
            content: content.value,
        })(transform);
        return transform({
            path,
            key,
            apiId,
            model,
            content: {
                __TYPE__: content.__TYPE__,
                value: groupItems,
            },
        });
    };
}
exports.traverseGroupContent = traverseGroupContent;
function traverseGroupItemsContent({ path, model, content, }) {
    return (transform) => {
        return content.map((groupItem, index) => {
            const groupItemPath = path.concat([
                { key: index.toString(), type: "GroupItem" },
            ]);
            const groupItemFields = groupItem.value.reduce((acc, [fieldKey, fieldContent]) => {
                const fieldDef = model === null || model === void 0 ? void 0 : model[fieldKey];
                let transformedField;
                if ((!fieldDef || (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type) === customtypes_1.GroupFieldType) &&
                    fieldContent.__TYPE__ === exports.GroupContentType) {
                    transformedField = traverseGroupContent({
                        path: groupItemPath.concat([{ key: fieldKey, type: "Widget" }]),
                        key: fieldKey,
                        apiId: fieldKey,
                        model: fieldDef,
                        content: fieldContent,
                    })(transform);
                }
                else {
                    transformedField = transform({
                        path: groupItemPath.concat([{ key: fieldKey, type: "Widget" }]),
                        key: fieldKey,
                        apiId: fieldKey,
                        model: fieldDef,
                        content: fieldContent,
                    });
                }
                // Can happen if the transform function returns undefined to filter out a field
                if (!transformedField ||
                    !((0, nestable_1.isNestableContent)(transformedField) ||
                        (0, exports.isGroupContent)(transformedField)))
                    return acc;
                return acc.concat([[fieldKey, transformedField]]);
            }, []);
            return {
                __TYPE__: groupItem.__TYPE__,
                value: groupItemFields,
            };
        });
    };
}
exports.traverseGroupItemsContent = traverseGroupItemsContent;
