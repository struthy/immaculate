"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapValues = exports.isObject = exports.withOptionals = exports.isNotEmpty = exports.zipObjects = void 0;
const tslib_1 = require("tslib");
const Either_1 = require("fp-ts/lib/Either");
const t = (0, tslib_1.__importStar)(require("io-ts"));
function zipObjects(objLeft, objRight) {
    const allKeys = [
        ...new Set(Object.keys(objLeft || {}).concat(Object.keys(objRight || {}))),
    ];
    return allKeys.reduce((acc, key) => {
        const left = objLeft === null || objLeft === void 0 ? void 0 : objLeft[key];
        const right = objRight === null || objRight === void 0 ? void 0 : objRight[key];
        return {
            ...acc,
            [key]: { left, right },
        };
    }, {});
}
exports.zipObjects = zipObjects;
function isNotEmpty(obj) {
    return Boolean(Object.keys(obj).length);
}
exports.isNotEmpty = isNotEmpty;
function withOptionals(object, optionals) {
    return {
        ...object,
        ...optionals.reduce((acc, [key, value]) => {
            return value ? { ...acc, [key]: value } : acc;
        }, {}),
    };
}
exports.withOptionals = withOptionals;
const recordCodec = t.record(t.string, t.unknown);
function isObject(value) {
    return (0, Either_1.isRight)(recordCodec.decode(value));
}
exports.isObject = isObject;
function mapValues(record, fn) {
    return Object.entries(record).reduce((acc, [key, value]) => ({ ...acc, [key]: fn(value, key) }), {});
}
exports.mapValues = mapValues;
