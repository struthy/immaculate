"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectSharedSlices = exports.flattenCustomTypeFields = exports.filterMissingSharedSlices = exports.collectWidgets = exports.validateSlices = exports.toStatic = exports.flattenSections = exports.flattenWidgets = exports.CustomType = exports.StaticCustomType = exports.CustomTypeFormat = void 0;
const tslib_1 = require("tslib");
const Either_1 = require("fp-ts/lib/Either");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const withFallback_1 = require("io-ts-types/lib/withFallback");
const validators_1 = require("../validators");
const Section_1 = require("./Section");
exports.CustomTypeFormat = {
    page: "page",
    custom: "custom",
};
class CustomTypeSlicesError extends Error {
    constructor(slices) {
        super();
        Object.defineProperty(this, "slices", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.slices = slices;
        this.message = this._formatError(slices);
    }
    _formatError(slicesRefs) {
        const slicesMsg = slicesRefs.map((ref) => `\t - ${ref}`);
        return `The following slices doesn't exists in your Prismic repository:
${slicesMsg.join("\n")}
`;
    }
}
function customTypeReader(codec) {
    return t.exact(t.intersection([
        t.type({
            id: t.string,
            label: validators_1.StringOrNull,
            repeatable: (0, withFallback_1.withFallback)(t.boolean, true),
            json: t.record(t.string, codec),
            status: (0, withFallback_1.withFallback)(t.boolean, true),
        }),
        t.partial({
            hash: t.string,
            format: (0, withFallback_1.withFallback)(t.keyof(exports.CustomTypeFormat), "custom"),
        }),
    ]));
}
exports.StaticCustomType = customTypeReader(Section_1.StaticSection);
exports.CustomType = customTypeReader(Section_1.DynamicSection);
function flattenWidgets(customType) {
    return Object.entries(customType.json).reduce((acc, [, section]) => {
        const sectionWidgets = Object.entries(section);
        return acc.concat(sectionWidgets);
    }, []);
}
exports.flattenWidgets = flattenWidgets;
function flattenSections(customType) {
    return Object.entries(customType.json).reduce((acc, [, section]) => {
        const sectionWidgets = Object.entries(section);
        return acc.concat(sectionWidgets);
    }, []);
}
exports.flattenSections = flattenSections;
function _retrieveSharedSlicesRef(customType) {
    const slicezones = flattenWidgets(customType).filter(([, widget]) => widget.type === "Slices");
    const allSharedRefs = slicezones.reduce((acc, [, slicezone]) => {
        const sharedRefs = Object.entries(slicezone.config && slicezone.config.choices
            ? slicezone.config.choices
            : {})
            .filter(([, slice]) => slice.type === "SharedSlice")
            .map(([key]) => key);
        return acc.concat(sharedRefs);
    }, []);
    return allSharedRefs;
}
function _mapSharedSlicesRefs(customType) {
    const refs = _retrieveSharedSlicesRef(customType);
    return function (mapFn) {
        return refs.map(mapFn);
    };
}
function toStatic(customType, sharedSlices) {
    const json = Object.entries(customType.json).reduce((acc, [sectionKey, dynSection]) => {
        return {
            ...acc,
            [sectionKey]: Section_1.Sections.toStatic(dynSection, sharedSlices),
        };
    }, {});
    return { ...customType, json };
}
exports.toStatic = toStatic;
function validateSlices(customType, sharedSlices) {
    const missingSlices = _mapSharedSlicesRefs(customType)((ref) => {
        const slice = sharedSlices.get(ref);
        const isMissing = !slice;
        if (isMissing)
            return ref;
        return;
    }).filter(Boolean);
    if (missingSlices.length > 0)
        return (0, Either_1.left)(new CustomTypeSlicesError(missingSlices));
    else
        return (0, Either_1.right)(customType);
}
exports.validateSlices = validateSlices;
function collectWidgets(customType, f) {
    const json = Object.entries(customType.json).reduce((acc, [sectionId, section]) => {
        const updatedSection = Object.entries(section).reduce((acc, [ref, widget]) => {
            const updatedWidget = f(ref, widget);
            if (updatedWidget) {
                return { ...acc, [ref]: updatedWidget };
            }
            return acc;
        }, {});
        return { ...acc, [sectionId]: updatedSection };
    }, {});
    return { ...customType, json };
}
exports.collectWidgets = collectWidgets;
function filterMissingSharedSlices(customType, sharedSlices) {
    return collectWidgets(customType, (_widgetId, widget) => {
        if (widget.type === "Slices") {
            if (!widget.config || !widget.config.choices)
                return widget;
            const choices = Object.entries(widget.config.choices).reduce((acc, [sliceId, sliceValue]) => {
                if (sliceValue.type === "SharedSlice" && !sharedSlices.get(sliceId))
                    return acc;
                return { ...acc, [sliceId]: sliceValue };
            }, {});
            const config = { ...widget.config, choices };
            return { ...widget, config };
        }
        return widget;
    });
}
exports.filterMissingSharedSlices = filterMissingSharedSlices;
function flattenCustomTypeFields(customType) {
    return Object.values(customType.json).reduce((acc, tab) => ({
        ...acc,
        ...tab,
    }), {});
}
exports.flattenCustomTypeFields = flattenCustomTypeFields;
function collectSharedSlices(customType) {
    return Object.entries(customType.fields).reduce((acc, [, w]) => {
        var _a;
        if (w.type === "Slices" || w.type === "Choice") {
            return {
                ...acc,
                ...Object.entries(((_a = w.config) === null || _a === void 0 ? void 0 : _a.choices) || {}).reduce((sliceZoneAcc, [sliceKey, sliceModel]) => {
                    return sliceModel.type === "SharedSlice"
                        ? { ...sliceZoneAcc, [sliceKey]: sliceModel }
                        : sliceZoneAcc;
                }, {}),
            };
        }
        return acc;
    }, {});
}
exports.collectSharedSlices = collectSharedSlices;
