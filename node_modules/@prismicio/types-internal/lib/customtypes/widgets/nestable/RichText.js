"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RichText = exports.RichTextConfig = exports.RichTextNodeTypeCodec = exports.RichTextNodeType = exports.DEFAULT_OPTION = exports.RichTextFieldType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts/");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const validators_1 = require("../../../validators");
const ImageConstraint_1 = (0, tslib_1.__importDefault)(require("../shared/ImageConstraint"));
exports.RichTextFieldType = "StructuredText";
exports.DEFAULT_OPTION = "paragraph";
exports.RichTextNodeType = {
    heading1: "heading1",
    heading2: "heading2",
    heading3: "heading3",
    heading4: "heading4",
    heading5: "heading5",
    heading6: "heading6",
    paragraph: "paragraph",
    strong: "strong",
    em: "em",
    preformatted: "preformatted",
    hyperlink: "hyperlink",
    image: "image",
    embed: "embed",
    list: "list-item",
    orderedList: "o-list-item",
    rtl: "rtl",
};
exports.RichTextNodeTypeCodec = t.keyof({
    [exports.RichTextNodeType.heading1]: null,
    [exports.RichTextNodeType.heading2]: null,
    [exports.RichTextNodeType.heading3]: null,
    [exports.RichTextNodeType.heading4]: null,
    [exports.RichTextNodeType.heading5]: null,
    [exports.RichTextNodeType.heading6]: null,
    [exports.RichTextNodeType.paragraph]: null,
    [exports.RichTextNodeType.strong]: null,
    [exports.RichTextNodeType.em]: null,
    [exports.RichTextNodeType.preformatted]: null,
    [exports.RichTextNodeType.hyperlink]: null,
    [exports.RichTextNodeType.image]: null,
    [exports.RichTextNodeType.embed]: null,
    [exports.RichTextNodeType.list]: null,
    [exports.RichTextNodeType.orderedList]: null,
    [exports.RichTextNodeType.rtl]: null,
});
const RichTextOptions = new t.Type("RichTextOptions", (u) => typeof u === "string", (u) => {
    return (0, function_1.pipe)(t.union([t.string, t.null]).decode(u), fp_ts_1.either.map((s) => {
        if (!s)
            return exports.DEFAULT_OPTION;
        const entries = s.split(",").map((e) => e.trim());
        const filtered = entries.filter((entry) => {
            return (0, Either_1.getOrElseW)(() => undefined)(exports.RichTextNodeTypeCodec.decode(entry));
        });
        if (!filtered.length)
            return exports.DEFAULT_OPTION;
        return filtered.join(",");
    }));
}, (a) => a);
const NoLabels = (labels) => {
    if (!labels)
        return t.success([]);
    return;
};
const LabelsAsObject = (labels) => {
    if (labels instanceof Object) {
        const labelsObj = labels;
        // empty labels
        if (!Object.entries(labelsObj).length)
            return t.success([]);
        // weird case labels with empty key as parent
        if (labelsObj[""]) {
            return t.success(labelsObj[""].map((l) => l.name));
        }
        const convertedObjectToArray = Object.entries(labelsObj)
            .reduce((acc, [, labelsEntries]) => {
            return acc.concat(labelsEntries.map((l) => l.name));
        }, [])
            .filter(Boolean);
        return t.success(convertedObjectToArray);
    }
    return;
};
const LabelsAsArray = (labels) => {
    if (labels instanceof Array) {
        const isValidLabels = labels.reduce((acc, l) => acc && typeof l === "string", true);
        if (isValidLabels)
            return t.success(labels);
    }
    return;
};
const LabelsAsString = (labels) => {
    if (typeof labels === "string") {
        return t.success([labels]);
    }
    return;
};
const RichTextLabels = new t.Type("RichTextLabels", (u) => {
    return u instanceof Array;
}, (u, context) => {
    const legacyValidator = t.record(t.string, t.readonlyArray(t.record(t.literal("name"), t.string)));
    const validator = t.readonlyArray(t.string);
    return (0, function_1.pipe)(t.union([legacyValidator, validator, t.string, t.null]).decode(u), fp_ts_1.either.chain((labels) => {
        return (NoLabels(labels) ||
            LabelsAsArray(labels) ||
            LabelsAsObject(labels) ||
            LabelsAsString(labels) ||
            t.failure(u, context));
    }));
}, (res) => res);
exports.RichTextConfig = t.exact(t.partial({
    label: validators_1.StringOrNull,
    placeholder: t.string,
    useAsTitle: t.boolean,
    single: RichTextOptions,
    multi: RichTextOptions,
    imageConstraint: ImageConstraint_1.default,
    labels: RichTextLabels,
    allowTargetBlank: t.boolean,
}));
exports.RichText = t.exact(t.intersection([
    t.type({
        type: t.literal(exports.RichTextFieldType),
    }),
    t.partial({
        fieldset: validators_1.StringOrNull,
        config: exports.RichTextConfig,
    }),
]));
