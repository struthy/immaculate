"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmptyArray = exports.EmptyObject = exports.Boolean = exports.NumberOrNull = exports.Number = exports.StringOrNull = exports.String = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const function_2 = require("./function");
exports.String = (0, function_2.withCustomError)(t.string, () => "The value must be a string");
exports.StringOrNull = (0, function_2.withCustomError)(t.union([t.string, t.null]), () => "The value must be a string or null");
exports.Number = (0, function_2.withCustomError)(t.number, () => "The value must be a number");
exports.NumberOrNull = (0, function_2.withCustomError)(t.union([t.number, t.null]), () => "The value must be a number or null");
exports.Boolean = (0, function_2.withCustomError)(t.boolean, () => "The value must be a boolean");
exports.EmptyObject = t.UnknownRecord.pipe(new t.Type("emptyObject", (u) => t.UnknownRecord.is(u), (u, c) => {
    if (Object.keys(u).length > 0)
        return t.failure(u, c, "The object is not empty.");
    return t.success({});
}, t.identity));
exports.EmptyArray = new t.Type("emptyArray", (u) => t.UnknownArray.is(u) && u.length === 0, (u, c) => {
    return (0, function_1.pipe)(t.UnknownArray.decode(u), fp_ts_1.either.chain((parsedArray) => {
        if (parsedArray.length > 0)
            return t.failure(u, c, "The array is not empty.");
        return t.success(new Array());
    }));
}, () => []);
