"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withCustomError = exports.addType = exports.isEmpty = exports.objectToMap = exports.grouped = exports.formatDate = exports.formatDateTime = exports.filterDouble = exports.refineType = exports.nullable = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const function_1 = require("fp-ts/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const io_ts_types_1 = require("io-ts-types");
const mapOutput_1 = require("io-ts-types/mapOutput");
function nullable(c) {
    return t.union([c, t.null, t.undefined]);
}
exports.nullable = nullable;
function refineType(type, newName, pred) {
    return new t.Type(newName, type.is, (u, c) => (0, function_1.pipe)(type.validate(u, c), fp_ts_1.either.chain((v) => (pred(v) ? t.success(v) : t.failure(u, c)))), type.encode);
}
exports.refineType = refineType;
function filterDouble(value) {
    if (value === "") {
        return null;
    }
    const result = Number(value);
    return Number.isNaN(result) ? null : result;
}
exports.filterDouble = filterDouble;
function formatDateTime(date) {
    return date.toISOString().replace(/\.\d{3}Z$/, "+0000");
}
exports.formatDateTime = formatDateTime;
function formatDate(date) {
    return date.toISOString().replace(/T.*/, "");
}
exports.formatDate = formatDate;
function grouped(array, n) {
    return array.reduce((acc, curr, idx) => {
        if (idx % n === 0) {
            acc.push([curr]);
        }
        else {
            /* eslint-disable  @typescript-eslint/no-non-null-assertion */
            acc[Math.floor(idx / n)].push(curr);
        }
        return acc;
    }, new Array());
}
exports.grouped = grouped;
function objectToMap(object) {
    return new Map(Object.entries(object));
}
exports.objectToMap = objectToMap;
function isEmpty(obj) {
    for (const _x in obj) {
        return false;
    }
    return true;
}
exports.isEmpty = isEmpty;
function addType(codec, t) {
    return (0, mapOutput_1.mapOutput)(codec, (o) => ({ ...o, __TYPE__: t }));
}
exports.addType = addType;
/**
 * Returns a clone of the given codec that tries to find sub-error with message already set.
 * If there is such error it just returns sub-errors array.
 * If there is no such error it generates new error with given message.
 *
 * @example
 * expect(
 * 		withCustomError(
 * 			t.type({age: withCustomError(t.number, () => 'Invalid child')}),
 * 			() => "Invalid parent"
 * 		)
 * ).toSubsetEqualLeft([{message: "Invalid child"}])
 * expect(
 * 		withCustomError(
 * 			t.type({age: t.number}),
 * 			() => "Invalid parent"
 * 		)
 * ).toSubsetEqualLeft([{message: "Invalid parent"}])
 */
function withCustomError(codec, message) {
    return (0, io_ts_types_1.withValidate)(codec, (i, c) => {
        return fp_ts_1.either.mapLeft((errors) => {
            if (errors.find((error) => error.message)) {
                return errors;
            }
            return [
                {
                    value: i,
                    context: c,
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    message: message(i, c),
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    actual: i,
                },
            ];
        })(codec.validate(i, c));
    });
}
exports.withCustomError = withCustomError;
