import * as t from "io-ts";
export declare function nullable<A, O>(c: t.Type<A, O>): t.UnionC<[t.Type<A, O, unknown>, t.NullC, t.UndefinedC]>;
export declare function refineType<A, O, I>(type: t.Type<A, O, I>, newName: string, pred: (a: A) => boolean): t.Type<A, O, I>;
export declare function filterDouble(value: string): number | null;
export declare function formatDateTime(date: Date): string;
export declare function formatDate(date: Date): string;
export declare function grouped<A>(array: A[], n: number): A[][];
export declare function objectToMap<T>(object: {
    [key: string]: T;
}): Map<string, T>;
export declare function isEmpty(obj: object): boolean;
export declare function addType<A, O extends object, I, T extends string>(codec: t.Type<A, O, I>, t: T): t.Type<A, O & {
    __TYPE__: T;
}, I>;
/**
 * Returns a clone of the given codec that tries to find sub-error with message already set.
 * If there is such error it just returns sub-errors array.
 * If there is no such error it generates new error with given message.
 *
 * @example
 * expect(
 * 		withCustomError(
 * 			t.type({age: withCustomError(t.number, () => 'Invalid child')}),
 * 			() => "Invalid parent"
 * 		)
 * ).toSubsetEqualLeft([{message: "Invalid child"}])
 * expect(
 * 		withCustomError(
 * 			t.type({age: t.number}),
 * 			() => "Invalid parent"
 * 		)
 * ).toSubsetEqualLeft([{message: "Invalid parent"}])
 */
export declare function withCustomError<C extends t.Any>(codec: C, message: (i: t.InputOf<C>, c: t.Context) => string): C;
