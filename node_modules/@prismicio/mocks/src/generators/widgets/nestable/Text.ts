import {
	FieldContent,
	FieldContentType,
	isTextContent,
} from "@prismicio/types-internal/lib/content"
import type { Text } from "@prismicio/types-internal/lib/customtypes"
import {
	DiffChange,
	DiffOperation,
} from "@prismicio/types-internal/lib/customtypes/diff"

import type { NestableMock, Patch } from "../../Mock"
import type { MockConfig } from "../../MockConfig"
import { slug } from "../../utils"

function random(min?: number, max?: number) {
	const minConf = min ? { min } : {}
	const maxConf = max ? { max } : {}
	return slug({ ...minConf, ...maxConf })
}

export interface TextMockConfig extends MockConfig<Text["type"], string> {
	minChar?: number
	maxChar?: number
}

export const TextMock: NestableMock<Text, FieldContent, TextMockConfig> = {
	generate(_def: Text, config?: TextMockConfig): FieldContent {
		const value = config?.value || random(config?.minChar, config?.maxChar)

		return {
			__TYPE__: FieldContentType,
			value,
			type: "Text",
		}
	},

	applyPatch(data: Patch):
		| {
				result: FieldContent | undefined
		  }
		| undefined {
		if (data.diff.op === DiffOperation.Removed) return { result: undefined }

		if (data.diff.value.type === "Text") {
			const patched = this.patch(
				data.diff,
				isTextContent(data.content) ? data.content : undefined,
				data.config?.type === "Text" ? data.config : undefined,
			)
			return { result: patched }
		}
		return
	},

	patch(
		diff: DiffChange<Text, Text>,
		_content: FieldContent,
		config?: TextMockConfig,
	): FieldContent | undefined {
		switch (diff.op) {
			case DiffOperation.Removed:
				return
			case DiffOperation.Updated:
			case DiffOperation.Added:
				return this.generate(diff.value, config)
		}
	},
}
