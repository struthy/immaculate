import {
	Block,
	ImageBlock,
	isRichTextContent,
	RichTextContent,
	RichTextContentType,
	TextBlock,
} from "@prismicio/types-internal/lib/content"
import {
	RichText,
	RichTextNodeType,
} from "@prismicio/types-internal/lib/customtypes"
import {
	DiffChange,
	DiffOperation,
} from "@prismicio/types-internal/lib/customtypes/diff"

import type { NestableMock, Patch } from "../../../Mock"
import { random as generateImage } from "../Image"
import {
	LoremDefaultConfig,
	Patterns,
	RichTextMockConfig,
} from "./RichTextMockConfig"

function random(def: RichText, config?: RichTextMockConfig): Array<Block> {
	const options: Array<RichTextNodeType> = (
		def?.config?.multi ||
		def?.config?.single ||
		`${RichTextNodeType.paragraph}`
	)
		.split(",")
		.map((o) => o as RichTextNodeType)
	const pattern =
		(config?.pattern && Patterns[config.pattern]) ||
		RichTextMockConfig.findMatchingPattern(options)
	const patternValue = pattern.value(options)

	const content = Array(
		config?.nbBlocks || RichTextMockConfig.INITIAL_CONFIG.blocks,
	)
		.fill(null)
		.map(() => {
			return patternValue.map<TextBlock | ImageBlock>(
				(contentType: RichTextNodeType) => {
					if (RichTextMockConfig.isText(contentType)) {
						return {
							type: contentType,
							content: {
								text: RichTextMockConfig.generateText(
									contentType,
									LoremDefaultConfig,
								),
							},
						}
					}
					const res = generateImage({ type: "Image" })
					return {
						type: RichTextNodeType.image,
						data: res,
					}
				},
			)
		})
	return content.flat()
}

export const RichTextMock: NestableMock<
	RichText,
	RichTextContent,
	RichTextMockConfig
> = {
	generate(def: RichText, config?: RichTextMockConfig): RichTextContent {
		const value = config?.value || random(def, config)

		return {
			__TYPE__: RichTextContentType,
			value,
		}
	},

	applyPatch(data: Patch):
		| {
				result: RichTextContent | undefined
		  }
		| undefined {
		if (data.diff.op === DiffOperation.Removed) return { result: undefined }

		if (data.diff.value.type === "StructuredText") {
			const patched = this.patch(
				data.diff,
				isRichTextContent(data.content) ? data.content : undefined,
				data.config?.type === "StructuredText" ? data.config : undefined,
			)
			return { result: patched }
		}
		return
	},

	patch(
		diff: DiffChange<RichText, RichText>,
		_content: RichTextContent,
		config?: RichTextMockConfig,
	): RichTextContent | undefined {
		switch (diff.op) {
			case DiffOperation.Removed:
				return
			case DiffOperation.Updated:
			case DiffOperation.Added:
				return this.generate(diff.value, config)
		}
	},
}

export * from "./RichTextMockConfig"
