"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupMock = exports.randomGroupBlock = void 0;
const fields_1 = require("@prismicio/types-internal/lib/content/fields");
const customtypes_1 = require("@prismicio/types-internal/lib/customtypes");
const errors_1 = require("../../errors");
const _1 = require(".");
function randomGroupBlock(fieldsDefs, mockConfigs) {
    return fieldsDefs.map(([key, field]) => {
        const mockConfig = mockConfigs === null || mockConfigs === void 0 ? void 0 : mockConfigs[key];
        switch (field.type) {
            case customtypes_1.GroupFieldType: {
                if (mockConfig && mockConfig.type !== customtypes_1.GroupFieldType) {
                    throw new errors_1.IncompatibleMockConfigError(mockConfig.type, field.type);
                }
                return [key, exports.GroupMock.generate(field, mockConfig)];
            }
            default: {
                if (mockConfig && mockConfig.type !== field.type) {
                    throw new errors_1.IncompatibleMockConfigError(mockConfig.type, field.type);
                }
                return [key, _1.NestableWidgetMock.generate(field, mockConfig)];
            }
        }
    });
}
exports.randomGroupBlock = randomGroupBlock;
function random(def, nbBlocks = 1, fields = {}) {
    if (!def.config || !def.config.fields) {
        return [];
    }
    const fieldsDefs = Object.entries(def.config.fields);
    return Array(nbBlocks)
        .fill(null)
        .map(() => randomGroupBlock(fieldsDefs, fields));
}
exports.GroupMock = {
    generate(def, config) {
        const value = (config === null || config === void 0 ? void 0 : config.value) || random(def, config === null || config === void 0 ? void 0 : config.nbBlocks, config === null || config === void 0 ? void 0 : config.fields);
        return {
            __TYPE__: fields_1.GroupContentType,
            value: value.map((item) => ({
                __TYPE__: fields_1.GroupItemContentType,
                value: item,
            })),
        };
    },
    patch(diff, content, config) {
        if (diff.op === customtypes_1.DiffOperation.Removed)
            return;
        // Retrieve group item values or create empty new ones after mock config
        const items = (content === null || content === void 0 ? void 0 : content.value) ||
            Array((config === null || config === void 0 ? void 0 : config.nbBlocks) || 1).fill({
                __TYPE__: fields_1.GroupItemContentType,
                value: [],
            });
        // Patch each group item values
        const patched = items.map((item) => {
            var _a;
            // Take current group item value
            const valueObject = Object.fromEntries(item.value);
            // Patch each group item widget value
            Object.entries((_a = diff.value.config.fields) !== null && _a !== void 0 ? _a : {}).forEach(([key, fieldDiff]) => {
                var _a;
                const itemContent = valueObject[key];
                const widgetConfig = (_a = config === null || config === void 0 ? void 0 : config.fields) === null || _a === void 0 ? void 0 : _a[key];
                let patchedWidget;
                if ((0, fields_1.isGroupContent)(itemContent) &&
                    (!widgetConfig || (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) === customtypes_1.GroupFieldType)) {
                    patchedWidget = exports.GroupMock.patch(fieldDiff, itemContent, widgetConfig);
                }
                else if (!(0, fields_1.isGroupContent)(itemContent) &&
                    (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) !== customtypes_1.GroupFieldType) {
                    patchedWidget = _1.NestableWidgetMock.patch(fieldDiff, itemContent, widgetConfig);
                }
                if (patchedWidget) {
                    // If the widget was patched, update the group item widget value
                    valueObject[key] = patchedWidget;
                }
                else {
                    // If the widget was removed, delete it from the group item value
                    delete valueObject[key];
                }
            });
            return {
                __TYPE__: fields_1.GroupItemContentType,
                value: Object.entries(valueObject),
            };
        });
        return {
            __TYPE__: fields_1.GroupContentType,
            value: patched,
        };
    },
};
