"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RichTextMock = void 0;
const tslib_1 = require("tslib");
const content_1 = require("@prismicio/types-internal/lib/content");
const customtypes_1 = require("@prismicio/types-internal/lib/customtypes");
const diff_1 = require("@prismicio/types-internal/lib/customtypes/diff");
const Image_1 = require("../Image");
const RichTextMockConfig_1 = require("./RichTextMockConfig");
function random(def, config) {
    var _a, _b;
    const options = (((_a = def === null || def === void 0 ? void 0 : def.config) === null || _a === void 0 ? void 0 : _a.multi) ||
        ((_b = def === null || def === void 0 ? void 0 : def.config) === null || _b === void 0 ? void 0 : _b.single) ||
        `${customtypes_1.RichTextNodeType.paragraph}`)
        .split(",")
        .map((o) => o);
    const pattern = ((config === null || config === void 0 ? void 0 : config.pattern) && RichTextMockConfig_1.Patterns[config.pattern]) ||
        RichTextMockConfig_1.RichTextMockConfig.findMatchingPattern(options);
    const patternValue = pattern.value(options);
    const content = Array((config === null || config === void 0 ? void 0 : config.nbBlocks) || RichTextMockConfig_1.RichTextMockConfig.INITIAL_CONFIG.blocks)
        .fill(null)
        .map(() => {
        return patternValue.map((contentType) => {
            if (RichTextMockConfig_1.RichTextMockConfig.isText(contentType)) {
                return {
                    type: contentType,
                    content: {
                        text: RichTextMockConfig_1.RichTextMockConfig.generateText(contentType, RichTextMockConfig_1.LoremDefaultConfig),
                    },
                };
            }
            const res = (0, Image_1.random)({ type: "Image" });
            return {
                type: customtypes_1.RichTextNodeType.image,
                data: res,
            };
        });
    });
    return content.flat();
}
exports.RichTextMock = {
    generate(def, config) {
        const value = (config === null || config === void 0 ? void 0 : config.value) || random(def, config);
        return {
            __TYPE__: content_1.RichTextContentType,
            value,
        };
    },
    applyPatch(data) {
        var _a;
        if (data.diff.op === diff_1.DiffOperation.Removed)
            return { result: undefined };
        if (data.diff.value.type === "StructuredText") {
            const patched = this.patch(data.diff, (0, content_1.isRichTextContent)(data.content) ? data.content : undefined, ((_a = data.config) === null || _a === void 0 ? void 0 : _a.type) === "StructuredText" ? data.config : undefined);
            return { result: patched };
        }
        return;
    },
    patch(diff, _content, config) {
        switch (diff.op) {
            case diff_1.DiffOperation.Removed:
                return;
            case diff_1.DiffOperation.Updated:
            case diff_1.DiffOperation.Added:
                return this.generate(diff.value, config);
        }
    },
};
(0, tslib_1.__exportStar)(require("./RichTextMockConfig"), exports);
