"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageMock = exports.random = void 0;
const tslib_1 = require("tslib");
const content_1 = require("@prismicio/types-internal/lib/content");
const diff_1 = require("@prismicio/types-internal/lib/customtypes/diff");
const images_json_1 = (0, tslib_1.__importDefault)(require("../../dataset/images.json"));
const utils_1 = require("../../utils");
const defaultImages = images_json_1.default;
/* Computes the best size and source rect for the image that satisfies the constraints. */
const fitImage = (imageSize, constraints) => {
    const [constraintWidth, constraintHeight] = (() => {
        const { width, height } = constraints !== null && constraints !== void 0 ? constraints : {};
        // If we have both constraints, keep them.
        if (width && height)
            return [width, height];
        // If we only have a width constraint, calculate the missing height constraint based on the image ratio.
        if (width)
            return [width, Math.round(imageSize.height * (width / imageSize.width))];
        // If we only have a height constraint, calculate the missing width constraint based on the image ratio.
        if (height)
            return [Math.round(imageSize.width * (height / imageSize.height)), height];
        // If we have no constraints at all, then use the original size.
        return [imageSize.width, imageSize.height];
    })();
    // Computes which side is the most constraining so we can calculate the most fitting source rectangle.
    const scaleFactor = Math.max(constraintWidth / imageSize.width, constraintHeight / imageSize.height);
    const rectX = Math.round((imageSize.width - constraintWidth / scaleFactor) / 2);
    const rectY = Math.round((imageSize.height - constraintHeight / scaleFactor) / 2);
    const rectWidth = Math.round(constraintWidth / scaleFactor);
    const rectHeight = Math.round(constraintHeight / scaleFactor);
    return {
        width: constraintWidth,
        height: constraintHeight,
        rect: {
            x: rectX,
            y: rectY,
            width: rectWidth,
            height: rectHeight,
        },
    };
};
const buildImageUrl = (originUrl, rect, outputSize) => {
    const url = new URL(originUrl);
    const { x, y, width, height } = rect;
    url.searchParams.set("rect", [x, y, width, height].join(","));
    url.searchParams.set("w", outputSize.width.toString());
    url.searchParams.set("h", outputSize.height.toString());
    return url.toString();
};
function generateImageView(img) {
    var _a, _b;
    const [originUrl, originWidth, originHeight] = (() => {
        const randomImage = img.images[(0, utils_1.randomInt)(0, img.images.length - 1)];
        const generatedUrl = randomImage === null || randomImage === void 0 ? void 0 : randomImage.url.split("?")[0];
        if (!generatedUrl)
            throw new Error("Something happened during Image generation.");
        return [generatedUrl, randomImage.width, randomImage.height];
    })();
    const { width, height, rect } = fitImage({ width: originWidth, height: originHeight }, img.constraints);
    const hasConstraints = Boolean(((_a = img.constraints) === null || _a === void 0 ? void 0 : _a.width) || ((_b = img.constraints) === null || _b === void 0 ? void 0 : _b.height));
    const url = hasConstraints
        ? buildImageUrl(originUrl, rect, { width, height })
        : originUrl;
    return {
        origin: {
            id: img.id,
            url: originUrl,
            width: originWidth,
            height: originHeight,
        },
        url,
        width,
        height,
        edit: {
            zoom: 1,
            crop: {
                x: rect.x,
                y: rect.y,
            },
            background: "transparent",
        },
    };
}
function random(def, images = defaultImages) {
    var _a, _b, _c;
    const mainView = generateImageView({
        id: "main",
        constraints: (_a = def.config) === null || _a === void 0 ? void 0 : _a.constraint,
        images,
    });
    const views = (_c = (_b = def.config) === null || _b === void 0 ? void 0 : _b.thumbnails) === null || _c === void 0 ? void 0 : _c.map((t) => {
        return [
            t.name,
            generateImageView({
                id: t.name,
                constraints: { width: t.width, height: t.height },
                images,
            }),
        ];
    });
    const thumbnails = (() => {
        if (!views)
            return {};
        return {
            thumbnails: views.reduce((acc, [viewName, viewValue]) => {
                return { ...acc, [viewName]: viewValue };
            }, {}),
        };
    })();
    return {
        __TYPE__: content_1.ImageContentType,
        ...mainView,
        ...thumbnails,
    };
}
exports.random = random;
exports.ImageMock = {
    generate(def, config) {
        return random(def, (config === null || config === void 0 ? void 0 : config.value) && [config.value]);
    },
    applyPatch(data) {
        if (data.diff.op === diff_1.DiffOperation.Removed)
            return { result: undefined };
        if (data.diff.value.type === "Image") {
            const patched = this.patch(data.diff, (0, content_1.isImageContent)(data.content) ? data.content : undefined);
            return { result: patched };
        }
        return;
    },
    patch(diff, _content) {
        switch (diff.op) {
            case diff_1.DiffOperation.Removed:
                return;
            case diff_1.DiffOperation.Updated:
            case diff_1.DiffOperation.Added:
                return this.generate(diff.value);
        }
    },
};
