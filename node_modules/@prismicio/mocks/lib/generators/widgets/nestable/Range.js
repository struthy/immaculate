"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangeMock = void 0;
const content_1 = require("@prismicio/types-internal/lib/content");
const diff_1 = require("@prismicio/types-internal/lib/customtypes/diff");
const DEFAULT_MIN = 0;
const DEFAULT_MAX = 100;
const DEFAULT_STEP = 1;
function random(min, max, step) {
    const rand = Math.floor(Math.random() * (max - min)) + min;
    if (rand % step === 0)
        return rand;
    const withStep = rand + (step - (rand % step)); // we ensure that it respects the increment step
    return Math.min(withStep, max); // if exceed max, just return max
}
exports.RangeMock = {
    generate(def, config) {
        const min = (() => {
            var _a;
            if ((_a = def.config) === null || _a === void 0 ? void 0 : _a.min) {
                return (config === null || config === void 0 ? void 0 : config.min) && config.min > def.config.min
                    ? config.min
                    : def.config.min;
            }
            return DEFAULT_MIN;
        })();
        const max = (() => {
            var _a;
            if ((_a = def.config) === null || _a === void 0 ? void 0 : _a.max) {
                return (config === null || config === void 0 ? void 0 : config.max) && config.max < def.config.max
                    ? config.max
                    : def.config.max;
            }
            return DEFAULT_MAX;
        })();
        const step = (() => {
            var _a;
            if ((_a = def.config) === null || _a === void 0 ? void 0 : _a.step) {
                return (config === null || config === void 0 ? void 0 : config.step) && config.step > def.config.step
                    ? config.step
                    : def.config.step;
            }
            return DEFAULT_STEP;
        })();
        const value = (() => {
            if (config === null || config === void 0 ? void 0 : config.value)
                return config.value;
            return random(min, max, step);
        })().toString();
        return {
            __TYPE__: content_1.FieldContentType,
            value,
            type: "Range",
        };
    },
    applyPatch(data) {
        var _a;
        if (data.diff.op === diff_1.DiffOperation.Removed)
            return { result: undefined };
        if (data.diff.value.type === "Range") {
            const patched = this.patch(data.diff, (0, content_1.isRangeContent)(data.content) ? data.content : undefined, ((_a = data.config) === null || _a === void 0 ? void 0 : _a.type) === "Range" ? data.config : undefined);
            return { result: patched };
        }
        return;
    },
    patch(diff, _content, config) {
        switch (diff.op) {
            case diff_1.DiffOperation.Removed:
                return;
            case diff_1.DiffOperation.Updated:
            case diff_1.DiffOperation.Added:
                return this.generate(diff.value, config);
        }
    },
};
