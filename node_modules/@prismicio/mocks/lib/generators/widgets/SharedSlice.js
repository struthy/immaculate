"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedSliceMock = void 0;
const content_1 = require("@prismicio/types-internal/lib/content");
const content_2 = require("@prismicio/types-internal/lib/content");
const customtypes_1 = require("@prismicio/types-internal/lib/customtypes");
const diff_1 = require("@prismicio/types-internal/lib/customtypes/diff");
const _1 = require(".");
function randomItemsBlock(fieldsDefs, mockConfigs) {
    return fieldsDefs.map(([key, field]) => {
        const mockConfig = mockConfigs && mockConfigs[key];
        return [key, _1.NestableWidgetMock.generate(field, mockConfig)];
    });
}
function random(variationDef, config) {
    const nbItemsBlocks = (config === null || config === void 0 ? void 0 : config.nbItemsBlocks) || 1;
    return {
        __TYPE__: content_2.SharedSliceContentType,
        variation: variationDef.id,
        primary: (() => {
            if (!variationDef.primary)
                return {};
            return (0, _1.randomGroupBlock)(Object.entries(variationDef.primary), config === null || config === void 0 ? void 0 : config.primaryFields).reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {});
        })(),
        items: (() => {
            if (!variationDef.items)
                return [];
            return Array(nbItemsBlocks)
                .fill(null)
                .map(() => {
                return randomItemsBlock(Object.entries(variationDef.items || {}), config === null || config === void 0 ? void 0 : config.itemFields);
            })
                .map((b) => ({
                __TYPE__: content_1.GroupItemContentType,
                value: b,
            }));
        })(),
    };
}
exports.SharedSliceMock = {
    generate(def, config) {
        var _a;
        if (config === null || config === void 0 ? void 0 : config.value) {
            return { __TYPE__: content_2.SharedSliceContentType, ...config.value };
        }
        const variationDef = (_a = def.variations.find((v) => v.id === (config === null || config === void 0 ? void 0 : config.variation))) !== null && _a !== void 0 ? _a : def.variations[0];
        if (!variationDef) {
            throw new Error(`Something happened during Shared slice generation. No variations were configured for slice ${def.id}.`);
        }
        const variationMockConfig = (config === null || config === void 0 ? void 0 : config.variations) && config.variations[variationDef.id];
        return generateVariation(variationDef, variationMockConfig);
    },
    patch(diff, content, config) {
        var _a, _b;
        switch (diff.op) {
            case diff_1.DiffOperation.Removed:
                if (!(config === null || config === void 0 ? void 0 : config.variation) || config.variation === (content === null || content === void 0 ? void 0 : content.variation))
                    return {
                        ok: true,
                        result: undefined,
                    };
                return {
                    ok: false,
                    error: new Error(`Content doesn't match the config for variation ${config.variation}`),
                };
            case diff_1.DiffOperation.Added:
                if (content)
                    return {
                        ok: false,
                        error: new Error(`Content already exists for slice ${diff.value.id}.`),
                    };
                if (!(config === null || config === void 0 ? void 0 : config.variation) ||
                    diff.value.variations.find((v) => v.id === config.variation)) {
                    return {
                        ok: true,
                        result: this.generate(diff.value, config),
                    };
                }
                return {
                    ok: false,
                    error: new Error(`Configured variation ${config.variation} not found in slice ${diff.value.id} definition.`),
                };
            case diff_1.DiffOperation.Updated: {
                // we take the content as reference or fallback to the config if no content yet.
                // This case can happen if a variation is newly added
                const variationResult = (() => {
                    if (content === null || content === void 0 ? void 0 : content.variation) {
                        if ((config === null || config === void 0 ? void 0 : config.variation) && content.variation !== (config === null || config === void 0 ? void 0 : config.variation))
                            return {
                                ok: false,
                                error: new Error(`Variation ${content.variation} from the content doesn't match the config ${config === null || config === void 0 ? void 0 : config.variation}.`),
                            };
                        return {
                            ok: true,
                            result: content.variation,
                        };
                    }
                    else {
                        return (config === null || config === void 0 ? void 0 : config.variation)
                            ? {
                                ok: true,
                                result: config.variation,
                            }
                            : {
                                ok: false,
                                error: new Error("No variation provided. You must either provide some content or a config."),
                            };
                    }
                })();
                if (!variationResult.ok)
                    return variationResult;
                const variationId = variationResult.result;
                const variationDiff = (_a = diff.value.variations) === null || _a === void 0 ? void 0 : _a[variationId];
                if (!variationDiff)
                    // the content provided can't be patched since there is no corresponding diff
                    return {
                        ok: false,
                        error: new Error(`The model of the content with variation ${variationId} has not changed.`),
                    };
                return patchVariation(variationId, variationDiff, content, variationDiff.op !== diff_1.DiffOperation.Removed
                    ? (_b = config === null || config === void 0 ? void 0 : config.variations) === null || _b === void 0 ? void 0 : _b[variationId]
                    : undefined);
            }
        }
    },
};
function generateVariation(def, config) {
    return random(def, config);
}
function patchVariation(variationId, diff, content, config) {
    switch (diff.op) {
        case diff_1.DiffOperation.Removed:
            return {
                ok: true,
                result: undefined,
            };
        case diff_1.DiffOperation.Added:
            if (!content)
                return {
                    ok: true,
                    result: generateVariation(diff.value, config), // we're not supposed to have content already
                };
            return {
                ok: false,
                error: new Error(`Content already exists for variation ${content.variation}.`),
            };
        case diff_1.DiffOperation.Updated: {
            const primary = diff.value.primary && (content === null || content === void 0 ? void 0 : content.primary)
                ? patchWidgets(diff.value.primary, Object.entries(content === null || content === void 0 ? void 0 : content.primary), config === null || config === void 0 ? void 0 : config.primaryFields)
                : (content === null || content === void 0 ? void 0 : content.primary) || {};
            const items = (() => {
                if (diff.value.items && (content === null || content === void 0 ? void 0 : content.items)) {
                    const diffItems = diff.value.items;
                    return content.items.map((block) => {
                        return {
                            __TYPE__: content_1.GroupItemContentType,
                            value: Object.entries(patchWidgets(diffItems, block.value, config === null || config === void 0 ? void 0 : config.itemFields)),
                        };
                    });
                }
                else
                    return (content === null || content === void 0 ? void 0 : content.items) || [];
            })();
            return {
                ok: true,
                result: {
                    __TYPE__: "SharedSliceContent",
                    variation: variationId,
                    primary,
                    items,
                },
            };
        }
    }
}
function patchWidgets(diff, content, config) {
    const patched = Object.entries(diff).reduce((acc, [widgetId, widgetChange]) => {
        var _a;
        const widgetContent = (_a = content.find(([id]) => id === widgetId)) === null || _a === void 0 ? void 0 : _a[1];
        const widgetConfig = config === null || config === void 0 ? void 0 : config[widgetId];
        // this will be undefined if a widget is in the diff with a remove OP
        let patched = undefined;
        if (
        // If content is not group content...
        !(0, content_1.isGroupContent)(widgetContent) &&
            // ...and widget config is not of type Group...
            (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) !== customtypes_1.GroupFieldType &&
            // ...and the widget change value is not of type Group
            widgetChange.op !== diff_1.DiffOperation.Removed &&
            widgetChange.value.type !== customtypes_1.GroupFieldType) {
            patched = _1.NestableWidgetMock.patch(widgetChange, widgetContent, widgetConfig);
        }
        else if (
        // If content is group content...
        (!widgetContent || (0, content_1.isGroupContent)(widgetContent)) &&
            // ...and widget config is of type Group.
            (!widgetConfig || widgetConfig.type === customtypes_1.GroupFieldType)) {
            patched = _1.GroupMock.patch(widgetChange, widgetContent, widgetConfig);
        }
        return {
            ...acc,
            ...(patched ? { [widgetId]: patched } : {}),
        };
    }, {});
    const updatedContent = content.reduce((acc, [widgetId, widgetContent]) => {
        // patched can return undefined if there is no diff or if it was removed.
        // we need to verify the widget has an actual diff to know if we return undefined or the previous content
        const updatedWidgetContent = diff[widgetId]
            ? patched[widgetId]
            : widgetContent;
        if (!updatedWidgetContent)
            return acc;
        return {
            ...acc,
            [widgetId]: updatedWidgetContent,
        };
    }, {});
    return {
        ...updatedContent,
        ...patched,
    };
}
