"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const client = require("@prismicio/client");
const vue = require("vue");
const vueRouter = require("vue-router");
const isInternalURL = require("../lib/isInternalURL.cjs");
const simplyResolveComponent = require("../lib/simplyResolveComponent.cjs");
const usePrismic = require("../usePrismic.cjs");
const defaultWrapper = "div";
const usePrismicRichText = (props) => {
  const { options } = usePrismic.usePrismic();
  const html = vue.computed(() => {
    const field = vue.unref(props.field);
    if (!client.isFilled.richText(field)) {
      return vue.unref(props.fallback) ?? "";
    }
    const linkResolver = vue.unref(props.linkResolver) ?? options.linkResolver;
    const serializer = vue.unref(props.serializer) ?? vue.unref(props.htmlSerializer) ?? options.richTextSerializer ?? options.htmlSerializer;
    return client.asHTML(vue.unref(field), linkResolver, serializer);
  });
  return {
    html
  };
};
const PrismicRichTextImpl = /* @__PURE__ */ vue.defineComponent({
  name: "PrismicRichText",
  props: {
    field: {
      type: Array,
      default: void 0,
      required: false
    },
    linkResolver: {
      type: Function,
      default: void 0,
      required: false
    },
    serializer: {
      type: [Function, Object],
      default: void 0,
      required: false
    },
    htmlSerializer: {
      type: [Function, Object],
      default: void 0,
      required: false
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    },
    fallback: {
      type: String,
      default: void 0,
      required: false
    }
  },
  setup(props) {
    const { html } = usePrismicRichText(props);
    const root = vue.ref(null);
    const maybeRouter = vue.inject(vueRouter.routerKey, null);
    if (maybeRouter) {
      let links = [];
      const navigate = function(event) {
        event.preventDefault();
        maybeRouter.push(this.href);
      };
      const addListeners = () => {
        const node = root.value && "$el" in root.value ? root.value.$el : root.value;
        if (node && "querySelectorAll" in node) {
          links = Array.from(node.querySelectorAll("a")).map((element) => {
            const href = element.getAttribute("href");
            if (href && isInternalURL.isInternalURL(href)) {
              const listener = navigate.bind({ href });
              element.addEventListener("click", listener);
              return { element, listener };
            } else {
              return false;
            }
          }).filter((link) => link);
        }
      };
      const removeListeners = () => {
        links.forEach(({ element, listener }) => element.removeEventListener("click", listener));
        links = [];
      };
      vue.watch(html, () => {
        removeListeners();
        vue.nextTick(addListeners);
      }, { immediate: true });
      vue.onBeforeUnmount(() => {
        removeListeners();
      });
    }
    return () => {
      return vue.h(simplyResolveComponent.simplyResolveComponent(props.wrapper || defaultWrapper), {
        innerHTML: html.value,
        ref: root
      });
    };
  }
});
const PrismicRichText = PrismicRichTextImpl;
exports.PrismicRichText = PrismicRichText;
exports.PrismicRichTextImpl = PrismicRichTextImpl;
exports.usePrismicRichText = usePrismicRichText;
//# sourceMappingURL=PrismicRichText.cjs.map
