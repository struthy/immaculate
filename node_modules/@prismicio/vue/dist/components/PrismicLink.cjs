"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const client = require("@prismicio/client");
const vue = require("vue");
const getSlots = require("../lib/getSlots.cjs");
const isInternalURL = require("../lib/isInternalURL.cjs");
const simplyResolveComponent = require("../lib/simplyResolveComponent.cjs");
const usePrismic = require("../usePrismic.cjs");
const defaultInternalComponent = "router-link";
const defaultExternalComponent = "a";
const defaultBlankTargetRelAttribute = "noopener noreferrer";
const usePrismicLink = (props) => {
  const { options } = usePrismic.usePrismic();
  const type = vue.computed(() => {
    var _a, _b;
    const internalComponent = vue.unref(props.internalComponent) || ((_a = options.components) == null ? void 0 : _a.linkInternalComponent) || defaultInternalComponent;
    const externalComponent = vue.unref(props.externalComponent) || ((_b = options.components) == null ? void 0 : _b.linkExternalComponent) || defaultExternalComponent;
    return href.value && isInternalURL.isInternalURL(href.value) && !target.value ? internalComponent : externalComponent;
  });
  const href = vue.computed(() => {
    const field = vue.unref(props.field);
    const linkResolver = vue.unref(props.linkResolver) ?? options.linkResolver;
    return client.asLink(field, linkResolver) ?? "";
  });
  const target = vue.computed(() => {
    const field = vue.unref(props.field);
    const target2 = vue.unref(props.target);
    if (typeof target2 !== "undefined") {
      return target2;
    } else {
      return field && "target" in field && field.target ? field.target : null;
    }
  });
  const rel = vue.computed(() => {
    var _a;
    const rel2 = vue.unref(props.rel);
    if (typeof rel2 !== "undefined") {
      return rel2;
    } else if (target.value === "_blank") {
      const blankTargetRelAttribute = vue.unref(props.blankTargetRelAttribute);
      if (typeof blankTargetRelAttribute !== "undefined") {
        return blankTargetRelAttribute;
      } else {
        return typeof ((_a = options.components) == null ? void 0 : _a.linkBlankTargetRelAttribute) !== "undefined" ? options.components.linkBlankTargetRelAttribute : defaultBlankTargetRelAttribute;
      }
    } else {
      return null;
    }
  });
  return {
    type,
    href,
    target,
    rel
  };
};
const PrismicLinkImpl = /* @__PURE__ */ vue.defineComponent({
  name: "PrismicLink",
  props: {
    field: {
      type: Object,
      required: true
    },
    linkResolver: {
      type: Function,
      default: void 0,
      required: false
    },
    target: {
      type: String,
      default: void 0,
      required: false
    },
    rel: {
      type: String,
      default: void 0,
      required: false
    },
    blankTargetRelAttribute: {
      type: String,
      default: void 0,
      required: false
    },
    internalComponent: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    },
    externalComponent: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    }
  },
  setup(props, { slots }) {
    if (!props.field) {
      return () => null;
    }
    const { type, href, target, rel } = usePrismicLink(props);
    return () => {
      const parent = type.value === "a" ? "a" : simplyResolveComponent.simplyResolveComponent(type.value);
      const computedSlots = getSlots.getSlots(parent, slots, vue.reactive({ href: href.value }));
      if (typeof parent === "string") {
        return vue.h(parent, { href: href.value, target: target.value, rel: rel.value }, computedSlots);
      } else {
        return vue.h(parent, { to: href.value, target: target.value, rel: rel.value }, computedSlots);
      }
    };
  }
});
const PrismicLink = PrismicLinkImpl;
exports.PrismicLink = PrismicLink;
exports.PrismicLinkImpl = PrismicLinkImpl;
exports.usePrismicLink = usePrismicLink;
//# sourceMappingURL=PrismicLink.cjs.map
