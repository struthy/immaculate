import { isFilled, asHTML } from "@prismicio/client";
import { computed, unref, defineComponent, ref, inject, watch, nextTick, onBeforeUnmount, h } from "vue";
import { routerKey } from "vue-router";
import { isInternalURL } from "../lib/isInternalURL.js";
import { simplyResolveComponent } from "../lib/simplyResolveComponent.js";
import { usePrismic } from "../usePrismic.js";
const defaultWrapper = "div";
const usePrismicRichText = (props) => {
  const { options } = usePrismic();
  const html = computed(() => {
    const field = unref(props.field);
    if (!isFilled.richText(field)) {
      return unref(props.fallback) ?? "";
    }
    const linkResolver = unref(props.linkResolver) ?? options.linkResolver;
    const serializer = unref(props.serializer) ?? unref(props.htmlSerializer) ?? options.richTextSerializer ?? options.htmlSerializer;
    return asHTML(unref(field), linkResolver, serializer);
  });
  return {
    html
  };
};
const PrismicRichTextImpl = /* @__PURE__ */ defineComponent({
  name: "PrismicRichText",
  props: {
    field: {
      type: Array,
      default: void 0,
      required: false
    },
    linkResolver: {
      type: Function,
      default: void 0,
      required: false
    },
    serializer: {
      type: [Function, Object],
      default: void 0,
      required: false
    },
    htmlSerializer: {
      type: [Function, Object],
      default: void 0,
      required: false
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    },
    fallback: {
      type: String,
      default: void 0,
      required: false
    }
  },
  setup(props) {
    const { html } = usePrismicRichText(props);
    const root = ref(null);
    const maybeRouter = inject(routerKey, null);
    if (maybeRouter) {
      let links = [];
      const navigate = function(event) {
        event.preventDefault();
        maybeRouter.push(this.href);
      };
      const addListeners = () => {
        const node = root.value && "$el" in root.value ? root.value.$el : root.value;
        if (node && "querySelectorAll" in node) {
          links = Array.from(node.querySelectorAll("a")).map((element) => {
            const href = element.getAttribute("href");
            if (href && isInternalURL(href)) {
              const listener = navigate.bind({ href });
              element.addEventListener("click", listener);
              return { element, listener };
            } else {
              return false;
            }
          }).filter((link) => link);
        }
      };
      const removeListeners = () => {
        links.forEach(({ element, listener }) => element.removeEventListener("click", listener));
        links = [];
      };
      watch(html, () => {
        removeListeners();
        nextTick(addListeners);
      }, { immediate: true });
      onBeforeUnmount(() => {
        removeListeners();
      });
    }
    return () => {
      return h(simplyResolveComponent(props.wrapper || defaultWrapper), {
        innerHTML: html.value,
        ref: root
      });
    };
  }
});
const PrismicRichText = PrismicRichTextImpl;
export {
  PrismicRichText,
  PrismicRichTextImpl,
  usePrismicRichText
};
//# sourceMappingURL=PrismicRichText.js.map
