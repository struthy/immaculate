"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const client = require("@prismicio/client");
const vue = require("vue");
const __PRODUCTION__ = require("../lib/__PRODUCTION__.cjs");
const simplyResolveComponent = require("../lib/simplyResolveComponent.cjs");
const usePrismic = require("../usePrismic.cjs");
const defaultImageComponent = "img";
const usePrismicImage = (props) => {
  const { options } = usePrismic.usePrismic();
  const asImage = vue.computed(() => {
    var _a, _b;
    const field = vue.unref(props.field);
    if (!client.isFilled.image(field)) {
      return {
        src: null,
        srcset: null
      };
    }
    const imgixParams = vue.unref(props.imgixParams);
    const widths = vue.unref(props.widths);
    const pixelDensities = vue.unref(props.pixelDensities);
    if (widths) {
      if (!__PRODUCTION__.__PRODUCTION__ && pixelDensities) {
        console.warn("[PrismicImage] Only one of `widths` or `pixelDensities` props can be provided. You can resolve this warning by removing either the `widths` or `pixelDensities` prop. `widths` will be used in this case.", props);
      }
      return client.asImageWidthSrcSet(field, {
        ...imgixParams,
        widths: widths === "defaults" ? (_a = options.components) == null ? void 0 : _a.imageWidthSrcSetDefaults : widths
      });
    } else if (pixelDensities) {
      return client.asImagePixelDensitySrcSet(field, {
        ...imgixParams,
        pixelDensities: pixelDensities === "defaults" ? (_b = options.components) == null ? void 0 : _b.imagePixelDensitySrcSetDefaults : pixelDensities
      });
    } else {
      return {
        src: client.asImageSrc(field, imgixParams),
        srcset: null
      };
    }
  });
  const src = vue.computed(() => {
    return asImage.value.src;
  });
  const srcset = vue.computed(() => {
    return asImage.value.srcset;
  });
  const alt = vue.computed(() => {
    return vue.unref(props.field).alt || "";
  });
  const copyright = vue.computed(() => {
    return vue.unref(props.field).copyright || null;
  });
  return {
    src,
    srcset,
    alt,
    copyright
  };
};
const PrismicImageImpl = /* @__PURE__ */ vue.defineComponent({
  name: "PrismicImage",
  props: {
    field: {
      type: Object,
      required: true
    },
    imageComponent: {
      type: [String, Object],
      default: void 0,
      required: false
    },
    imgixParams: {
      type: Object,
      default: void 0,
      required: false
    },
    widths: {
      type: [String, Object],
      default: void 0,
      required: false
    },
    pixelDensities: {
      type: [String, Object],
      default: void 0,
      required: false
    }
  },
  setup(props) {
    if (!props.field) {
      return () => null;
    }
    const { options } = usePrismic.usePrismic();
    const type = vue.computed(() => {
      var _a;
      return props.imageComponent || ((_a = options.components) == null ? void 0 : _a.imageComponent) || defaultImageComponent;
    });
    const { src, srcset, alt, copyright } = usePrismicImage(props);
    return () => {
      const attributes = {
        src: src.value,
        srcset: srcset.value,
        alt: alt.value
      };
      switch (type.value) {
        case "img":
          return vue.h("img", attributes);
        default:
          return vue.h(simplyResolveComponent.simplyResolveComponent(type.value), {
            ...attributes,
            copyright: copyright.value
          });
      }
    };
  }
});
const PrismicImage = PrismicImageImpl;
exports.PrismicImage = PrismicImage;
exports.PrismicImageImpl = PrismicImageImpl;
exports.usePrismicImage = usePrismicImage;
//# sourceMappingURL=PrismicImage.cjs.map
