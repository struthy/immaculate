{"version":3,"file":"SliceZone.js","sources":["../../../src/components/SliceZone.ts"],"sourcesContent":["import { Slice } from \"@prismicio/client\";\nimport {\n\tAllowedComponentProps,\n\tComponentCustomProps,\n\tConcreteComponent,\n\tDefineComponent,\n\tFunctionalComponent,\n\tPropType,\n\tRaw,\n\tVNodeProps,\n\tcomputed,\n\tdefineAsyncComponent,\n\tdefineComponent,\n\th,\n\tmarkRaw,\n\twatchEffect,\n} from \"vue\";\n\nimport { __PRODUCTION__ } from \"../lib/__PRODUCTION__\";\nimport { simplyResolveComponent } from \"../lib/simplyResolveComponent\";\n\nimport { usePrismic } from \"../usePrismic\";\n\n/**\n * Returns the type of a `SliceLike` type.\n *\n * @typeParam TSlice - The Slice from which the type will be extracted.\n */\ntype ExtractSliceType<TSlice extends SliceLike> = TSlice extends SliceLikeRestV2\n\t? TSlice[\"slice_type\"]\n\t: TSlice extends SliceLikeGraphQL\n\t? TSlice[\"type\"]\n\t: never;\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * Rest API V2 for the `<SliceZone>` component.\n *\n * If using Prismic's Rest API V2, use the `Slice` export from\n * `@prismicio/client` for a full interface.\n *\n * @typeParam TSliceType - Type name of the Slice.\n */\nexport type SliceLikeRestV2<TSliceType extends string = string> = Pick<\n\tSlice<TSliceType>,\n\t\"id\" | \"slice_type\"\n>;\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * GraphQL API for the `<SliceZone>` component.\n *\n * @typeParam TSliceType - Type name of the Slice.\n */\nexport type SliceLikeGraphQL<TSliceType extends string = string> = {\n\ttype: Slice<TSliceType>[\"slice_type\"];\n};\n\n/**\n * The minimum required properties to represent a Prismic Slice for the\n * `<SliceZone />` component.\n *\n * If using Prismic's Rest API V2, use the `Slice` export from\n * `@prismicio/client` for a full interface.\n *\n * @typeParam TSliceType - Type name of the Slice\n */\nexport type SliceLike<TSliceType extends string = string> = (\n\t| SliceLikeRestV2<TSliceType>\n\t| SliceLikeGraphQL<TSliceType>\n) & {\n\t/**\n\t * If `true`, this Slice has been modified from its original value using a\n\t * mapper and `@prismicio/client`'s `mapSliceZone()`.\n\t *\n\t * @internal\n\t */\n\t__mapped?: true;\n};\n\n/**\n * A looser version of the `SliceZone` type from `@prismicio/client` using\n * `SliceLike`.\n *\n * If using Prismic's REST API, use the `SliceZone` export from\n * `@prismicio/client` for the full type.\n *\n * @typeParam TSlice - The type(s) of slices in the Slice Zone\n */\nexport type SliceZoneLike<TSlice extends SliceLike = SliceLike> =\n\treadonly TSlice[];\n\n/**\n * Vue props for a component rendering content from a Prismic Slice using the\n * `<SliceZone />` component.\n *\n * @typeParam TSlice - The type(s) of slices in the Slice Zone\n * @typeParam TContext - Arbitrary data passed to `<SliceZone />` and made\n *   available to all Slice components\n */\nexport type SliceComponentProps<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> = {\n\t/**\n\t * Slice data for this component.\n\t */\n\tslice: TSlice;\n\n\t/**\n\t * The index of the Slice in the Slice Zone.\n\t */\n\tindex: number;\n\n\t/**\n\t * All Slices from the Slice Zone to which the Slice belongs.\n\t */\n\t// TODO: We have to keep this list of Slices general due to circular\n\t// reference limtiations. If we had another generic to determine the full\n\t// union of Slice types, it would include TSlice. This causes TypeScript to\n\t// throw a compilation error.\n\tslices: SliceZoneLike<\n\t\tTSlice extends SliceLikeGraphQL ? SliceLikeGraphQL : SliceLikeRestV2\n\t>;\n\n\t/**\n\t * Arbitrary data passed to `<SliceZone />` and made available to all Slice\n\t * components.\n\t */\n\tcontext: TContext;\n};\n\n/**\n * Native Vue props for a component rendering content from a Prismic Slice using\n * the `<SliceZone />` component.\n *\n * @typeParam TSlice - The Slice type\n * @typeParam TContext - Arbitrary data passed to `<SliceZone />` and made\n *   available to all Slice components\n */\nexport type DefineComponentSliceComponentProps<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n> = {\n\tslice: {\n\t\ttype: PropType<SliceComponentProps<TSlice, TContext>[\"slice\"]>;\n\t\trequired: true;\n\t};\n\tindex: {\n\t\ttype: PropType<SliceComponentProps<TSlice, TContext>[\"index\"]>;\n\t\trequired: true;\n\t};\n\tslices: {\n\t\ttype: PropType<SliceComponentProps<TSlice, TContext>[\"slices\"]>;\n\t\trequired: true;\n\t};\n\tcontext: {\n\t\ttype: PropType<SliceComponentProps<TSlice, TContext>[\"context\"]>;\n\t\trequired: true;\n\t};\n};\n\n/**\n * Gets native Vue props for a component rendering content from a Prismic Slice\n * using the `<SliceZone />` component.\n *\n * Props are: `[\"slice\", \"index\", \"slices\", \"context\"]`\n *\n * @example\n *\n * ```javascript\n * // Defining a new slice component\n * import { getSliceComponentProps } from \"@prismicio/vue\";\n *\n * export default {\n * \tprops: getSliceComponentProps(),\n * };\n * ```\n *\n * @example\n *\n * ```javascript\n * // Defining a new slice component with visual hint\n * import { getSliceComponentProps } from \"@prismicio/vue\";\n *\n * export default {\n * \tprops: getSliceComponentProps([\"slice\", \"index\", \"slices\", \"context\"]),\n * };\n * ```\n *\n * @typeParam TSlice - The Slice type\n * @typeParam TContext - Arbitrary data passed to `<SliceZone />` and made\n *   available to all Slice components\n * @param propsHint - An optional array of prop names used for the sole purpose\n *   of having a visual hint of which props are made available to the slice,\n *   this parameters doesn't have any effect\n *\n * @returns Props object to use with {@link defineComponent}\n */\nexport const getSliceComponentProps = <\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n>(\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpropsHint?: [\"slice\", \"index\", \"slices\", \"context\"],\n): DefineComponentSliceComponentProps<TSlice, TContext> => ({\n\tslice: {\n\t\ttype: Object as PropType<SliceComponentProps<TSlice, TContext>[\"slice\"]>,\n\t\trequired: true,\n\t},\n\tindex: {\n\t\ttype: Number as PropType<SliceComponentProps<TSlice, TContext>[\"index\"]>,\n\t\trequired: true,\n\t},\n\tslices: {\n\t\ttype: Array as PropType<SliceComponentProps<TSlice, TContext>[\"slices\"]>,\n\t\trequired: true,\n\t},\n\tcontext: {\n\t\ttype: null as unknown as PropType<\n\t\t\tSliceComponentProps<TSlice, TContext>[\"context\"]\n\t\t>,\n\t\trequired: true,\n\t},\n});\n\n/**\n * A Vue component to be rendered for each instance of its Slice.\n *\n * @typeParam TSlice - The type(s) of slices in the Slice Zone\n * @typeParam TContext - Arbitrary data made available to all Slice components\n */\nexport type SliceComponentType<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n> =\n\t// For reference within TypeScript files when `*.vue` type cannot be inferred\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types\n\t| DefineComponent<{}, {}, any>\n\t// Likewise, for reference with TypeScript files.\n\t| ReturnType<typeof defineAsyncComponent>\n\t| DefineComponent<SliceComponentProps<TSlice, TContext>>\n\t| FunctionalComponent<SliceComponentProps<TSlice, TContext>>;\n\n/**\n * This Slice component can be used as a reminder to provide a proper\n * implementation.\n *\n * This is also the default Vue component rendered when a component mapping\n * cannot be found in `<SliceZone />`.\n */\nexport const TODOSliceComponent = __PRODUCTION__\n\t? ((() => null) as FunctionalComponent<{\n\t\t\tslice: SliceLike;\n\t  }>)\n\t: /*#__PURE__*/ (defineComponent({\n\t\t\tname: \"TODOSliceComponent\",\n\t\t\tprops: {\n\t\t\t\tslice: {\n\t\t\t\t\ttype: Object as PropType<SliceLike>,\n\t\t\t\t\trequired: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tsetup(props) {\n\t\t\t\tconst type = computed(() => {\n\t\t\t\t\treturn \"slice_type\" in props.slice\n\t\t\t\t\t\t? props.slice.slice_type\n\t\t\t\t\t\t: props.slice.type;\n\t\t\t\t});\n\n\t\t\t\twatchEffect(() => {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[SliceZone] Could not find a component for Slice type \"${type.value}\"`,\n\t\t\t\t\t\tprops.slice,\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\treturn () => {\n\t\t\t\t\treturn h(\n\t\t\t\t\t\t\"section\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"data-slice-zone-todo-component\": \"\",\n\t\t\t\t\t\t\t\"data-slice-type\": type.value,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t[`Could not find a component for Slice type \"${type.value}\"`],\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t},\n\t  }) as SliceComponentType);\n\n/**\n * A record of Slice types mapped to Vue components. Each components will be\n * rendered for each instance of their Slice type.\n *\n * @typeParam TSlice - The type(s) of slices in the Slice Zone\n * @typeParam TContext - Arbitrary data made available to all Slice components\n */\nexport type SliceZoneComponents<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> =\n\t// This is purposely not wrapped in Partial to ensure a component is provided\n\t// for all Slice types. <SliceZone /> will render a default component if one is\n\t// not provided, but it *should* be a type error if an explicit component is\n\t// missing.\n\t//\n\t// If a developer purposely does not want to provide a component, they can\n\t// assign it to the TODOSliceComponent exported from this package. This\n\t// signals to future developers that it is a placeholder and should be\n\t// implemented.\n\t{\n\t\t[SliceType in ExtractSliceType<TSlice>]:\n\t\t\t| SliceComponentType<Extract<TSlice, SliceLike<SliceType>>, TContext>\n\t\t\t| string;\n\t};\n\n/**\n * Gets an optimized record of Slice types mapped to Vue components. Each\n * components will be rendered for each instance of their Slice type.\n *\n * @remarks\n * This is essentially an helper function to ensure {@link markRaw} is correctly\n * applied on each components, improving performances.\n * @example\n *\n * ```javascript\n * // Defining a slice components\n * import { defineSliceZoneComponents } from \"@prismicio/vue\";\n *\n * export default {\n *   data() {\n *     components: defineSliceZoneComponents({\n *       foo: Foo,\n *       bar: defineAsyncComponent(\n *         () => new Promise((res) => res(Bar)),\n *       ),\n *       baz: \"Baz\",\n *     }),\n *   }\n * };\n * ```\n *\n * @typeParam TSlice - The type(s) of slices in the Slice Zone\n * @typeParam TContext - Arbitrary data made available to all Slice components\n *\n * @param components - {@link SliceZoneComponents}\n *\n * @returns A new optimized record of {@link SliceZoneComponents}\n */\nexport const defineSliceZoneComponents = <\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n>(\n\tcomponents: SliceZoneComponents<TSlice, TContext>,\n): SliceZoneComponents<TSlice, TContext> => {\n\tconst result = {} as SliceZoneComponents<TSlice, TContext>;\n\n\tlet type: keyof typeof components;\n\tfor (type in components) {\n\t\tconst component = components[type];\n\t\tresult[type] =\n\t\t\ttypeof component === \"string\"\n\t\t\t\t? component\n\t\t\t\t: markRaw(\n\t\t\t\t\t\tcomponent as SliceComponentType<\n\t\t\t\t\t\t\tExtract<TSlice, SliceLike<typeof type>>,\n\t\t\t\t\t\t\tTContext\n\t\t\t\t\t\t>,\n\t\t\t\t  );\n\t}\n\n\treturn result;\n};\n\n/**\n * Arguments for a `<SliceZone>` `resolver` function.\n */\nexport type SliceZoneResolverArgs<TSlice extends SliceLike = SliceLike> = {\n\t/**\n\t * The Slice to resolve to a Vue component..\n\t */\n\tslice: TSlice;\n\n\t/**\n\t * The name of the Slice.\n\t */\n\tsliceName: ExtractSliceType<TSlice>;\n\n\t/**\n\t * The index of the Slice in the Slice Zone.\n\t */\n\ti: number;\n};\n\n/**\n * A function that determines the rendered Vue component for each Slice in the\n * Slice Zone. If a nullish value is returned, the component will fallback to\n * the `components` or `defaultComponent` props to determine the rendered\n * component.\n *\n * @deprecated Use the `components` prop instead.\n *\n * @param args - Arguments for the resolver function.\n *\n * @returns The Vue component to render for a Slice.\n */\nexport type SliceZoneResolver<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n> = (\n\targs: SliceZoneResolverArgs<TSlice>,\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => SliceComponentType<any, TContext> | string | undefined | null;\n\n/**\n * Props for `<SliceZone />`.\n *\n * @typeParam TContext - Arbitrary data made available to all Slice components\n */\nexport type SliceZoneProps<TContext = unknown> = {\n\t/**\n\t * List of Slice data from the Slice Zone.\n\t */\n\tslices: SliceZoneLike;\n\n\t/**\n\t * A record mapping Slice types to Vue components.\n\t */\n\tcomponents?: SliceZoneComponents;\n\n\t/**\n\t * A function that determines the rendered Vue component for each Slice in the\n\t * Slice Zone.\n\t *\n\t * @deprecated Use the `components` prop instead.\n\t *\n\t * @param args - Arguments for the resolver function.\n\t *\n\t * @returns The Vue component to render for a Slice.\n\t */\n\t// TODO: Remove in v5 when the `resolver` prop is removed.\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tresolver?: SliceZoneResolver<any, TContext>;\n\n\t/**\n\t * Arbitrary data made available to all Slice components.\n\t */\n\tcontext?: TContext;\n\n\t/**\n\t * A component or a functional component rendered if a component mapping from\n\t * the `components` prop cannot be found.\n\t *\n\t * @remarks\n\t * Components will be rendered using the {@link SliceComponentProps} interface.\n\t *\n\t * @defaultValue The Slice Zone default component provided to `@prismicio/vue` plugin if configured, otherwise `null` when `process.env.NODE_ENV === \"production\"` else {@link TODOSliceComponent}.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tdefaultComponent?: SliceComponentType<any, TContext>;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to wrap the\n\t * output. The Slice Zone is not wrapped by default.\n\t */\n\twrapper?: string | ConcreteComponent | Raw<DefineComponent>;\n};\n\n/**\n * `<SliceZone />` implementation.\n *\n * @internal\n */\nexport const SliceZoneImpl = /*#__PURE__*/ defineComponent({\n\tname: \"SliceZone\",\n\tprops: {\n\t\tslices: {\n\t\t\ttype: Array as PropType<\n\t\t\t\tSliceZoneLike<SliceLike & Record<string, unknown>>\n\t\t\t>,\n\t\t\trequired: true,\n\t\t},\n\t\tcomponents: {\n\t\t\ttype: Object as PropType<SliceZoneComponents>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tresolver: {\n\t\t\ttype: Function as PropType<SliceZoneResolver>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tcontext: {\n\t\t\ttype: null,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tdefaultComponent: {\n\t\t\ttype: Object as PropType<SliceComponentType>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\twrapper: {\n\t\t\ttype: [String, Object, Function] as PropType<\n\t\t\t\tstring | ConcreteComponent | Raw<DefineComponent>\n\t\t\t>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t},\n\tsetup(props) {\n\t\t// Prevent fatal if user didn't check for field, throws `Invalid prop` warn\n\t\tif (!props.slices) {\n\t\t\treturn () => null;\n\t\t}\n\n\t\t// TODO: Remove in v3 when the `resolver` prop is removed.\n\t\tif (!__PRODUCTION__) {\n\t\t\tif (props.resolver) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"The `resolver` prop is deprecated. Please replace it with a components map using the `components` prop.\",\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst { options } = usePrismic();\n\n\t\tconst renderedSlices = computed(() => {\n\t\t\treturn props.slices.map((slice, index) => {\n\t\t\t\tconst type =\n\t\t\t\t\t\"slice_type\" in slice ? (slice.slice_type as string) : slice.type;\n\n\t\t\t\tlet component =\n\t\t\t\t\tprops.components && type in props.components\n\t\t\t\t\t\t? props.components[type]\n\t\t\t\t\t\t: props.defaultComponent ||\n\t\t\t\t\t\t  options.components?.sliceZoneDefaultComponent;\n\n\t\t\t\t// TODO: Remove `resolver` in v5 in favor of `components`.\n\t\t\t\tif (props.resolver) {\n\t\t\t\t\tconst resolvedComponent = props.resolver({\n\t\t\t\t\t\tslice,\n\t\t\t\t\t\tsliceName: type,\n\t\t\t\t\t\ti: index,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (resolvedComponent) {\n\t\t\t\t\t\tcomponent = resolvedComponent;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst key =\n\t\t\t\t\t\"id\" in slice && typeof slice.id === \"string\"\n\t\t\t\t\t\t? slice.id\n\t\t\t\t\t\t: `${index}-${JSON.stringify(slice)}`;\n\n\t\t\t\tif (component) {\n\t\t\t\t\tif (slice.__mapped) {\n\t\t\t\t\t\tconst { __mapped, ...mappedProps } = slice;\n\n\t\t\t\t\t\treturn h(simplyResolveComponent(component as ConcreteComponent), {\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t...mappedProps,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn h(simplyResolveComponent(component as ConcreteComponent), {\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tslice,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\tcontext: props.context,\n\t\t\t\t\t\tslices: props.slices,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn h(\n\t\t\t\t\t\tsimplyResolveComponent(TODOSliceComponent as ConcreteComponent),\n\t\t\t\t\t\t{ key, slice },\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn () => {\n\t\t\tif (props.wrapper) {\n\t\t\t\tconst parent = simplyResolveComponent(props.wrapper);\n\n\t\t\t\tif (typeof parent === \"string\") {\n\t\t\t\t\treturn h(parent, null, renderedSlices.value);\n\t\t\t\t} else {\n\t\t\t\t\treturn h(parent, null, { default: () => renderedSlices.value });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn renderedSlices.value;\n\t\t\t}\n\t\t};\n\t},\n});\n\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to render a Prismic Slice Zone.\n *\n * @see Component props {@link SliceZoneProps}\n * @see Templating Slice Zones {@link https://prismic.io/docs/technologies/vue-template-content#slices-and-groups}\n */\nexport const SliceZone = SliceZoneImpl as unknown as {\n\tnew (): {\n\t\t$props: AllowedComponentProps &\n\t\t\tComponentCustomProps &\n\t\t\tVNodeProps &\n\t\t\tSliceZoneProps;\n\t};\n};\n"],"names":[],"mappings":"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"}