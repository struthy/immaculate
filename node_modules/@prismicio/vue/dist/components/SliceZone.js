import { defineComponent, computed, watchEffect, h, markRaw } from "vue";
import { __PRODUCTION__ } from "../lib/__PRODUCTION__.js";
import { simplyResolveComponent } from "../lib/simplyResolveComponent.js";
import { usePrismic } from "../usePrismic.js";
const getSliceComponentProps = (propsHint) => ({
  slice: {
    type: Object,
    required: true
  },
  index: {
    type: Number,
    required: true
  },
  slices: {
    type: Array,
    required: true
  },
  context: {
    type: null,
    required: true
  }
});
const TODOSliceComponent = __PRODUCTION__ ? () => null : /* @__PURE__ */ defineComponent({
  name: "TODOSliceComponent",
  props: {
    slice: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const type = computed(() => {
      return "slice_type" in props.slice ? props.slice.slice_type : props.slice.type;
    });
    watchEffect(() => {
      console.warn(`[SliceZone] Could not find a component for Slice type "${type.value}"`, props.slice);
    });
    return () => {
      return h("section", {
        "data-slice-zone-todo-component": "",
        "data-slice-type": type.value
      }, [`Could not find a component for Slice type "${type.value}"`]);
    };
  }
});
const defineSliceZoneComponents = (components) => {
  const result = {};
  let type;
  for (type in components) {
    const component = components[type];
    result[type] = typeof component === "string" ? component : markRaw(component);
  }
  return result;
};
const SliceZoneImpl = /* @__PURE__ */ defineComponent({
  name: "SliceZone",
  props: {
    slices: {
      type: Array,
      required: true
    },
    components: {
      type: Object,
      default: void 0,
      required: false
    },
    resolver: {
      type: Function,
      default: void 0,
      required: false
    },
    context: {
      type: null,
      default: void 0,
      required: false
    },
    defaultComponent: {
      type: Object,
      default: void 0,
      required: false
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    }
  },
  setup(props) {
    if (!props.slices) {
      return () => null;
    }
    if (!__PRODUCTION__) {
      if (props.resolver) {
        console.warn("The `resolver` prop is deprecated. Please replace it with a components map using the `components` prop.");
      }
    }
    const { options } = usePrismic();
    const renderedSlices = computed(() => {
      return props.slices.map((slice, index) => {
        var _a;
        const type = "slice_type" in slice ? slice.slice_type : slice.type;
        let component = props.components && type in props.components ? props.components[type] : props.defaultComponent || ((_a = options.components) == null ? void 0 : _a.sliceZoneDefaultComponent);
        if (props.resolver) {
          const resolvedComponent = props.resolver({
            slice,
            sliceName: type,
            i: index
          });
          if (resolvedComponent) {
            component = resolvedComponent;
          }
        }
        const key = "id" in slice && typeof slice.id === "string" ? slice.id : `${index}-${JSON.stringify(slice)}`;
        if (component) {
          if (slice.__mapped) {
            const { __mapped, ...mappedProps } = slice;
            return h(simplyResolveComponent(component), {
              key,
              ...mappedProps
            });
          }
          return h(simplyResolveComponent(component), {
            key,
            slice,
            index,
            context: props.context,
            slices: props.slices
          });
        } else {
          return h(simplyResolveComponent(TODOSliceComponent), { key, slice });
        }
      });
    });
    return () => {
      if (props.wrapper) {
        const parent = simplyResolveComponent(props.wrapper);
        if (typeof parent === "string") {
          return h(parent, null, renderedSlices.value);
        } else {
          return h(parent, null, { default: () => renderedSlices.value });
        }
      } else {
        return renderedSlices.value;
      }
    };
  }
});
const SliceZone = SliceZoneImpl;
export {
  SliceZone,
  SliceZoneImpl,
  TODOSliceComponent,
  defineSliceZoneComponents,
  getSliceComponentProps
};
//# sourceMappingURL=SliceZone.js.map
