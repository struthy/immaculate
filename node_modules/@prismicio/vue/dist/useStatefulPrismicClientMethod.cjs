"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const vue = require("vue");
const usePrismic = require("./usePrismic.cjs");
const isParams = (value) => {
  return typeof value === "object" && value !== null && !Array.isArray(value);
};
const useStatefulPrismicClientMethod = (methodName, args) => {
  const { client } = usePrismic.usePrismic();
  const state = vue.ref(
    "idle"
    /* PrismicClientComposableState.Idle */
  );
  const data = vue.shallowRef(null);
  const error = vue.ref(null);
  const refresh = async () => {
    const lastArg = vue.unref(args[args.length - 1]);
    const { client: explicitClient, ...params } = isParams(lastArg) ? lastArg : {};
    const argsWithoutParams = isParams(lastArg) ? args.slice(0, -1) : args;
    state.value = "pending";
    data.value = null;
    error.value = null;
    try {
      data.value = await (vue.unref(explicitClient) || client)[methodName](...argsWithoutParams.map((arg) => vue.unref(arg)), params);
      state.value = "success";
    } catch (err) {
      state.value = "error";
      error.value = err;
    }
  };
  const refArgs = args.filter((arg) => vue.isRef(arg));
  if (refArgs.length) {
    vue.watch(refArgs, refresh, { deep: true });
  }
  refresh();
  return { state, data, error, refresh };
};
exports.useStatefulPrismicClientMethod = useStatefulPrismicClientMethod;
//# sourceMappingURL=useStatefulPrismicClientMethod.cjs.map
