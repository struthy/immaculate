{"version":3,"file":"useStatefulPrismicClientMethod.cjs","sources":["../../src/useStatefulPrismicClientMethod.ts"],"sourcesContent":["import {\n\tClient,\n\tForbiddenError,\n\tParsingError,\n\tPrismicError,\n} from \"@prismicio/client\";\nimport { Ref, isRef, ref, shallowRef, unref, watch } from \"vue\";\n\nimport { PrismicClientComposableState, VueUseParameters } from \"./types\";\n\nimport { usePrismic } from \"./usePrismic\";\n\n// Helpers\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ClientMethodLike = (...args: any[]) => Promise<any> | any;\ntype ClientMethods = typeof Client.prototype;\ntype ClientError = PrismicError<unknown> | ParsingError | ForbiddenError;\n\n// Interfaces\n\n/**\n * @internal\n */\nexport type ClientMethodParameters<TMethodName extends keyof ClientMethods> =\n\tClientMethods[TMethodName] extends ClientMethodLike\n\t\t? VueUseParameters<Parameters<ClientMethods[TMethodName]>>\n\t\t: never;\n\n/**\n * @internal\n */\nexport type ClientMethodReturnType<TMethodName extends keyof ClientMethods> =\n\tClientMethods[TMethodName] extends ClientMethodLike\n\t\t? ReturnType<ClientMethods[TMethodName]>\n\t\t: never;\n\n/**\n * @internal\n */\nexport type ComposableOnlyParameters = {\n\tclient?: Ref<Client> | Client;\n};\n\n/**\n * The return type of a `@prismicio/client` Vue composable.\n *\n * @typeParam TData - The expected format of the `data` property of the returned\n *   object\n */\nexport type ClientComposableReturnType<TData = unknown> = {\n\t/**\n\t * The current state of the composable's client method call.\n\t */\n\tstate: Ref<PrismicClientComposableState>;\n\n\t/**\n\t * Data returned by the client.\n\t */\n\tdata: Ref<TData | null>;\n\n\t/**\n\t * Error returned by the composable's client method call if in an errror\n\t * state.\n\t */\n\terror: Ref<ClientError | Error | null>;\n\n\t/**\n\t * Perform the composable's client method call again.\n\t */\n\trefresh: () => Promise<void>;\n};\n\n/**\n * Determines if a value is a `@prismicio/client` params object.\n *\n * @param value - The value to check\n *\n * @returns `true` if `value` is a `@prismicio/client` params object, `false`\n *   otherwise\n */\nconst isParams = (\n\tvalue: unknown,\n): value is ClientMethodParameters<\"get\">[0] & ComposableOnlyParameters => {\n\t// This is a *very* naive check.\n\treturn typeof value === \"object\" && value !== null && !Array.isArray(value);\n};\n\n/**\n * A low level Vue composable that uses provided method name on plugin or\n * provided client with given arguments. The composable has its own internal\n * state manager to report async status, such as pending or error statuses.\n *\n * @typeParam TClientMethodName - A method name from `@prismicio/client`\n * @typeParam TClientMethodArguments - The method expected arguments\n * @typeParam TClientMethodReturnType - The method expected return type\n *\n * @param method - The `@prismicio/client` method name to use\n * @param args - The arguments to use with requested method\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @internal\n */\nexport const useStatefulPrismicClientMethod = <\n\tTClientMethodName extends keyof ClientMethods,\n\tTClientMethodArguments extends ClientMethodParameters<TClientMethodName>,\n\tTClientMethodReturnType extends UnwrapPromise<\n\t\tClientMethodReturnType<TClientMethodName>\n\t>,\n>(\n\tmethodName: TClientMethodName,\n\targs: TClientMethodArguments,\n): ClientComposableReturnType<TClientMethodReturnType> => {\n\tconst { client } = usePrismic();\n\n\tconst state = ref<PrismicClientComposableState>(\n\t\tPrismicClientComposableState.Idle,\n\t);\n\tconst data = shallowRef<TClientMethodReturnType | null>(null);\n\tconst error = ref<ClientError | Error | null>(null);\n\tconst refresh = async (): Promise<void> => {\n\t\tconst lastArg = unref(args[args.length - 1]);\n\t\tconst { client: explicitClient, ...params } = isParams(lastArg)\n\t\t\t? (lastArg as ClientMethodParameters<\"get\">[0] & ComposableOnlyParameters)\n\t\t\t: ({} as ComposableOnlyParameters);\n\t\tconst argsWithoutParams = isParams(lastArg) ? args.slice(0, -1) : args;\n\n\t\tstate.value = PrismicClientComposableState.Pending;\n\t\tdata.value = null;\n\t\terror.value = null;\n\t\ttry {\n\t\t\tdata.value = await (\n\t\t\t\t(unref(explicitClient) || client)[methodName] as ClientMethodLike\n\t\t\t)(\n\t\t\t\t...argsWithoutParams.map((arg: Ref<unknown> | unknown) => unref(arg)),\n\t\t\t\tparams,\n\t\t\t);\n\t\t\tstate.value = PrismicClientComposableState.Success;\n\t\t} catch (err) {\n\t\t\tstate.value = PrismicClientComposableState.Error;\n\t\t\terror.value = err as ClientError | Error;\n\t\t}\n\t};\n\n\t// Watch reactive args\n\tconst refArgs = args.filter((arg) => isRef(arg));\n\tif (refArgs.length) {\n\t\twatch(refArgs, refresh, { deep: true });\n\t}\n\n\t// Fetch once\n\trefresh();\n\n\treturn { state, data, error, refresh };\n};\n"],"names":["usePrismic","ref","shallowRef","unref","isRef","watch"],"mappings":";;;;AAiFA,MAAM,WAAW,CAChB,UACyE;AAElE,SAAA,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,MAAM,QAAQ,KAAK;AAC3E;AAkBa,MAAA,iCAAiC,CAO7C,YACA,SACwD;AAClD,QAAA,EAAE,WAAWA,WAAAA;AAEnB,QAAM,QAAQC,IAAA;AAAA,IAAG;AAAA;AAAA,EAAA;AAGX,QAAA,OAAOC,eAA2C,IAAI;AACtD,QAAA,QAAQD,QAAgC,IAAI;AAClD,QAAM,UAAU,YAA0B;AACzC,UAAM,UAAUE,IAAAA,MAAM,KAAK,KAAK,SAAS,CAAC,CAAC;AACrC,UAAA,EAAE,QAAQ,gBAAgB,GAAG,OAAA,IAAW,SAAS,OAAO,IAC1D,UACA;AACE,UAAA,oBAAoB,SAAS,OAAO,IAAI,KAAK,MAAM,GAAG,EAAE,IAAI;AAElE,UAAM,QAAK;AACX,SAAK,QAAQ;AACb,UAAM,QAAQ;AACV,QAAA;AACH,WAAK,QAAQ,OACXA,IAAAA,MAAM,cAAc,KAAK,QAAQ,UAAU,EAE5C,GAAG,kBAAkB,IAAI,CAAC,QAAgCA,IAAAA,MAAM,GAAG,CAAC,GACpE,MAAM;AAEP,YAAM,QAAK;AAAA,aACH,KAAK;AACb,YAAM,QAAK;AACX,YAAM,QAAQ;AAAA,IACf;AAAA,EAAA;AAID,QAAM,UAAU,KAAK,OAAO,CAAC,QAAQC,IAAA,MAAM,GAAG,CAAC;AAC/C,MAAI,QAAQ,QAAQ;AACnBC,QAAA,MAAM,SAAS,SAAS,EAAE,MAAM,KAAM,CAAA;AAAA,EACvC;;AAKA,SAAO,EAAE,OAAO,MAAM,OAAO,QAAO;AACrC;;"}