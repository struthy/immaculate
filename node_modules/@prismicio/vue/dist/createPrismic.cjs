"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const client = require("@prismicio/client");
const injectionSymbols = require("./injectionSymbols.cjs");
const PrismicLink = require("./components/PrismicLink.cjs");
const PrismicEmbed = require("./components/PrismicEmbed.cjs");
const PrismicImage = require("./components/PrismicImage.cjs");
const PrismicText = require("./components/PrismicText.cjs");
const PrismicRichText = require("./components/PrismicRichText.cjs");
const SliceZone = require("./components/SliceZone.cjs");
const createPrismic = (options) => {
  let client$1;
  if (options.client) {
    client$1 = options.client;
  } else {
    client$1 = client.createClient(options.endpoint, {
      fetch: async (endpoint, options2) => {
        let fetchFunction;
        if (typeof globalThis.fetch === "function") {
          fetchFunction = globalThis.fetch;
        } else {
          fetchFunction = (await import("isomorphic-unfetch")).default;
        }
        return await fetchFunction(endpoint, options2);
      },
      ...options.clientConfig
    });
  }
  const prismicClient = {
    client: client$1,
    filter: client.filter,
    cookie: client.cookie
  };
  const prismicHelpers = {
    asText: client.asText,
    asHTML: (richTextField, ...config) => {
      const [configOrLinkResolver, maybeHTMLSerializer] = config;
      return client.asHTML(richTextField, typeof configOrLinkResolver === "function" || configOrLinkResolver == null ? {
        linkResolver: configOrLinkResolver || options.linkResolver,
        serializer: maybeHTMLSerializer || options.richTextSerializer || options.htmlSerializer
      } : {
        linkResolver: options.linkResolver,
        serializer: options.richTextSerializer || options.htmlSerializer,
        ...configOrLinkResolver
      });
    },
    asLink: (linkField, config) => {
      return client.asLink(linkField, typeof config === "function" ? { linkResolver: config } : {
        linkResolver: options.linkResolver,
        // TODO: For some reasons, TypeScript narrows the type to "unknown" where it's supposed to be a union
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ...config
      });
    },
    asLinkAttrs: (linkField, config) => {
      return client.asLinkAttrs(linkField, {
        // TODO: We can't really retrieve the generic type here, this might cause some unexpected type error in some edge-case scenario
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        linkResolver: options.linkResolver,
        ...config
      });
    },
    asDate: client.asDate,
    asImageSrc: client.asImageSrc,
    asImageWidthSrcSet: client.asImageWidthSrcSet,
    asImagePixelDensitySrcSet: client.asImagePixelDensitySrcSet,
    isFilled: client.isFilled,
    documentToLinkField: client.documentToLinkField
  };
  const prismic = {
    options,
    ...prismicClient,
    ...prismicHelpers,
    install(app) {
      app.provide(injectionSymbols.prismicKey, this);
      app.config.globalProperties.$prismic = this;
      if (options.injectComponents !== false) {
        app.component(PrismicLink.PrismicLink.name, PrismicLink.PrismicLink);
        app.component(PrismicEmbed.PrismicEmbed.name, PrismicEmbed.PrismicEmbed);
        app.component(PrismicImage.PrismicImage.name, PrismicImage.PrismicImage);
        app.component(PrismicText.PrismicText.name, PrismicText.PrismicText);
        app.component(PrismicRichText.PrismicRichText.name, PrismicRichText.PrismicRichText);
        app.component(SliceZone.SliceZone.name, SliceZone.SliceZone);
      }
    }
  };
  return prismic;
};
exports.createPrismic = createPrismic;
//# sourceMappingURL=createPrismic.cjs.map
