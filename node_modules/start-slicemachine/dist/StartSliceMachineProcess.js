var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import chalk from "chalk";
import open from "open";
import os from "node:os";
import { createSliceMachineManager } from "@slicemachine/manager";
import { createSliceMachineExpressApp } from "./lib/createSliceMachineExpressApp.js";
import { setupSentry } from "./lib/setupSentry.js";
import { migrateSMJSON } from "./legacyMigrations/migrateSMJSON.js";
import { migrateAssets } from "./legacyMigrations/migrateAssets.js";
import { SLICE_MACHINE_NPM_PACKAGE_NAME } from "./constants.js";
import { safelyExecute } from "./lib/safelyExecute.js";
const DEFAULT_SERVER_PORT = 9999;
const createStartSliceMachineProcess = (...args) => {
  return new StartSliceMachineProcess(...args);
};
class StartSliceMachineProcess {
  constructor(args) {
    /**
     * Determines if Slice Machine should automatically be opened once the server
     * starts.
     *
     * @defaultValue `false`
     */
    __publicField(this, "open");
    /**
     * The port on which to start the Slice Machine server.
     *
     * @defaultValue `9999`
     */
    __publicField(this, "port");
    /**
     * The Slice Machine manager used for the process.
     */
    __publicField(this, "_sliceMachineManager");
    this._sliceMachineManager = createSliceMachineManager();
    this.open = args.open ?? false;
    this.port = args.port ?? DEFAULT_SERVER_PORT;
  }
  /**
   * Runs the process.
   */
  async run() {
    await migrateSMJSON(this._sliceMachineManager);
    const appVersion = await this._sliceMachineManager.versions.getRunningSliceMachineVersion();
    await this._sliceMachineManager.telemetry.initTelemetry({
      appName: SLICE_MACHINE_NPM_PACKAGE_NAME,
      appVersion
    });
    const isTelemetryEnabled = await this._sliceMachineManager.telemetry.checkIsTelemetryEnabled();
    if (isTelemetryEnabled) {
      try {
        await setupSentry(this._sliceMachineManager);
      } catch (error) {
      }
    }
    await this._sliceMachineManager.plugins.initPlugins();
    await migrateAssets(this._sliceMachineManager);
    await this._validateProject();
    if (isTelemetryEnabled) {
      try {
        this._trackStart();
      } catch (error) {
      }
    }
    const app = await createSliceMachineExpressApp({
      sliceMachineManager: this._sliceMachineManager
    });
    const server = app.listen(this.port);
    const address = server.address();
    const url = `http://localhost:${address.port}`;
    if (this.open) {
      await open(url);
    }
    console.log();
    console.log(await this._buildSliceMachineRunningLine(`Running at ${chalk.magenta(url)}`));
    console.log();
    const profile = await this._fetchProfile();
    if (profile) {
      this._sliceMachineManager.telemetry.identify({
        userID: profile.shortId,
        intercomHash: profile.intercomHash
      });
      await Promise.allSettled([
        // noop - We'll try again when needed.
        this._sliceMachineManager.user.refreshAuthenticationToken(),
        // noop - We'll try again before uploading a screenshot.
        this._sliceMachineManager.screenshots.initS3ACL()
      ]);
    }
  }
  /**
   * Returns a string with Slice Machine info formatted for the console.
   *
   * @param value - Info to display.
   *
   * @returns String to pass to the console.
   */
  async _buildSliceMachineRunningLine(value) {
    const currentVersion = await this._sliceMachineManager.versions.getRunningSliceMachineVersion();
    return `${chalk.bgBlack(` ${chalk.bold.white("Slice Machine")} ${chalk.magenta(`v${currentVersion}`)} `)} ${chalk.dim("â†’")} ${value}`;
  }
  /**
   * Validates the project's config and content models.
   *
   * @throws Throws if a Library name is invalid.
   * @throws Throws if a Slice model is invalid.
   * @throws Throws if a Custom Type model is invalid.
   */
  async _validateProject() {
    var _a;
    const config = await this._sliceMachineManager.project.loadSliceMachineConfig();
    const invalidLibraries = ((_a = config.libraries) == null ? void 0 : _a.filter((library) => library.startsWith("@") || library.startsWith("~"))) || [];
    if (invalidLibraries.length > 0) {
      throw new Error(`The following Slice libraries have invalid names: ${invalidLibraries.join(", ")}. Slice library names must not start with "@" nor "~".`);
    }
    const allSlices = await this._sliceMachineManager.slices.readAllSlices();
    if (allSlices.errors.length > 0) {
      throw new Error(`Errors occurred while validating your project's slices.

${allSlices.errors.join("\n\n")}`);
    }
    const allCustomTypes = await this._sliceMachineManager.customTypes.readAllCustomTypes();
    if (allCustomTypes.errors.length > 0) {
      throw new Error(allCustomTypes.errors.join(", "));
    }
  }
  /**
   * Fetches the logged in Prismic user's profile. If the user is not logged in,
   * `undefined` is returned.
   *
   * @returns The logged in Prismic user's profile, or `undefined` if not logged
   *   in.
   */
  async _fetchProfile() {
    const isLoggedIn = await this._sliceMachineManager.user.checkIsLoggedIn();
    if (isLoggedIn) {
      return await this._sliceMachineManager.user.getProfile();
    }
  }
  /**
   * Tracks the start of Slice Machine.
   *
   * This method is called after Slice Machine has started and so it will not
   * cause the process to wait for the tracking to complete.
   */
  async _trackStart() {
    const [adapter, adapterVersion, customTypes, gitProvider, isAdapterUpdateAvailable, isLoggedIn, isSliceMachineUpdateAvailable, isTypeScriptProject, packageManager, simulatorUrl, sliceMachineVersion, slices, versionControlSystem] = await Promise.all([
      safelyExecute(() => this._sliceMachineManager.project.getAdapterName()),
      safelyExecute(() => this._sliceMachineManager.versions.getRunningAdapterVersion()),
      safelyExecute(() => this._sliceMachineManager.customTypes.readAllCustomTypes()),
      safelyExecute(() => this._sliceMachineManager.git.detectGitProvider()),
      safelyExecute(() => this._sliceMachineManager.versions.checkIsAdapterUpdateAvailable()),
      safelyExecute(() => this._sliceMachineManager.user.checkIsLoggedIn()),
      safelyExecute(() => this._sliceMachineManager.versions.checkIsSliceMachineUpdateAvailable()),
      safelyExecute(() => this._sliceMachineManager.project.checkIsTypeScript()),
      safelyExecute(() => this._sliceMachineManager.project.detectPackageManager()),
      safelyExecute(() => this._sliceMachineManager.simulator.getLocalSliceSimulatorURL()),
      safelyExecute(() => this._sliceMachineManager.versions.getRunningSliceMachineVersion()),
      safelyExecute(() => this._sliceMachineManager.slices.readAllSlices()),
      safelyExecute(() => this._sliceMachineManager.project.detectVersionControlSystem())
    ]);
    this._sliceMachineManager.telemetry.track({
      event: "slice-machine:start",
      _includeEnvironmentKind: true,
      adapter,
      adapterVersion,
      gitProvider,
      isAdapterUpdateAvailable,
      isLoggedIn,
      isSliceMachineUpdateAvailable,
      isTypeScriptProject,
      nodeVersion: process.versions.node,
      numberOfCustomTypes: customTypes == null ? void 0 : customTypes.models.length,
      numberOfSlices: slices == null ? void 0 : slices.models.length,
      osPlatform: os.platform(),
      // Ensure we escape the "@" character to prevent it from being interpreted
      // as an email address and being considered sensitive and stripped off.
      packageManager: packageManager == null ? void 0 : packageManager.replace("@", "[at]"),
      projectPort: simulatorUrl ? new URL(simulatorUrl).port : void 0,
      sliceMachineVersion,
      versionControlSystem
    });
  }
}
export {
  StartSliceMachineProcess,
  createStartSliceMachineProcess
};
//# sourceMappingURL=StartSliceMachineProcess.js.map
