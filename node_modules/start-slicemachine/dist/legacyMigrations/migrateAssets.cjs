"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("io-ts");
const path = require("node:path");
const fsSync = require("node:fs");
const content = require("@prismicio/types-internal/lib/content");
const mocks = require("@prismicio/mocks");
const sentryErrorHandlers = require("../lib/sentryErrorHandlers.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
const fsSync__namespace = /* @__PURE__ */ _interopNamespaceDefault(fsSync);
const MOCKS_FILE_NAME = "mocks.json";
const SharedSliceContentArray = t__namespace.array(content.SharedSliceContent);
const DocumentArray = t__namespace.array(content.Document);
const createPathToDeprecatedLibrary = (cwd) => path__namespace.join(cwd, ".slicemachine");
const createPathToCustomTypesAssets = (cwd) => path__namespace.join(createPathToDeprecatedLibrary(cwd), "assets", "customtypes");
const ensureOrGenerateSliceScreenshot = (variationsIDs, targetPathToSliceFolder, deprecatedPathToSliceAssets) => {
  variationsIDs.forEach((variationID) => {
    const targetPathToVariationScreenshot = path__namespace.join(targetPathToSliceFolder, `screenshot-${variationID}.png`);
    if (!fsSync__namespace.existsSync(targetPathToVariationScreenshot)) {
      const deprecatedPathToCustomVariation = path__namespace.join(targetPathToSliceFolder, variationID);
      const deprecatedPathToCustomVariationScreenshot = path__namespace.join(deprecatedPathToCustomVariation, "preview.png");
      if (fsSync__namespace.existsSync(deprecatedPathToCustomVariationScreenshot)) {
        fsSync__namespace.renameSync(deprecatedPathToCustomVariationScreenshot, targetPathToVariationScreenshot);
        try {
          if (fsSync__namespace.readdirSync(deprecatedPathToCustomVariation).length === 0) {
            fsSync__namespace.rmSync(deprecatedPathToCustomVariation, { recursive: true });
          }
        } catch {
        }
      } else {
        const deprecatedPathToVariationScreenshot = path__namespace.join(deprecatedPathToSliceAssets, variationID, "preview.png");
        if (fsSync__namespace.existsSync(deprecatedPathToVariationScreenshot)) {
          fsSync__namespace.renameSync(deprecatedPathToVariationScreenshot, targetPathToVariationScreenshot);
        }
      }
    }
  });
};
const ensureOrGenerateMockFile = (targetPathToMocks, deprecatedPathToMocks, validator, generate, isTelemetryEnabled) => {
  try {
    const rawMockContent = (() => {
      if (fsSync__namespace.existsSync(targetPathToMocks)) {
        return fsSync__namespace.readFileSync(targetPathToMocks, "utf-8");
      }
      if (fsSync__namespace.existsSync(deprecatedPathToMocks)) {
        return fsSync__namespace.readFileSync(deprecatedPathToMocks, "utf-8");
      }
      return null;
    })();
    const regeneratedMocksString = JSON.stringify(generate(), null, 2);
    const isValidMock = (() => {
      try {
        return rawMockContent !== null && validator(rawMockContent);
      } catch {
        return false;
      }
    })();
    if (!isValidMock) {
      fsSync__namespace.writeFileSync(targetPathToMocks, regeneratedMocksString);
    } else if (rawMockContent) {
      fsSync__namespace.writeFileSync(targetPathToMocks, rawMockContent);
    } else {
      fsSync__namespace.writeFileSync(targetPathToMocks, regeneratedMocksString);
    }
  } catch (error) {
    if (isTelemetryEnabled) {
      sentryErrorHandlers.node("migrateAssets.ensureOrGenerateMockFile", error);
    }
  }
};
const migrateAssets = async (manager) => {
  const isTelemetryEnabled = await manager.telemetry.checkIsTelemetryEnabled();
  try {
    if (!fsSync__namespace.existsSync(path__namespace.join(createPathToDeprecatedLibrary(manager.cwd), "assets"))) {
      return;
    }
    const allSlices = await manager.slices.readAllSlices();
    const sharedSlices = allSlices.models.reduce((o, slice) => ({ ...o, [slice.model.id]: slice.model }), {});
    allSlices.models.forEach((c) => {
      const targetPathToSliceFolder = path__namespace.join(manager.cwd, c.libraryID, c.model.name);
      const targetPathToMocks = path__namespace.join(targetPathToSliceFolder, MOCKS_FILE_NAME);
      const deprecatedPathToSliceAssets = path__namespace.join(createPathToDeprecatedLibrary(manager.cwd), "assets", c.libraryID, c.model.name);
      const deprecatedPathToMocks = path__namespace.join(deprecatedPathToSliceAssets, MOCKS_FILE_NAME);
      const reGeneratedMocks = c.model.variations.map((variation) => {
        return mocks.SharedSliceMock.generate(c.model, {
          variation: variation.id,
          type: "SharedSlice"
        });
      });
      ensureOrGenerateMockFile(targetPathToMocks, deprecatedPathToMocks, (str) => SharedSliceContentArray.decode(JSON.parse(str))._tag === "Right", () => reGeneratedMocks, isTelemetryEnabled);
      const variationsIDs = c.model.variations.map((v) => v.id);
      ensureOrGenerateSliceScreenshot(variationsIDs, targetPathToSliceFolder, deprecatedPathToSliceAssets);
    });
    const allCustomTypes = await manager.customTypes.readAllCustomTypes();
    allCustomTypes.models.forEach((c) => {
      const targetPathToMocks = path__namespace.join(manager.cwd, "customtypes", c.model.id, MOCKS_FILE_NAME);
      const deprecatedPathToMocks = path__namespace.join(createPathToCustomTypesAssets(manager.cwd), c.model.id, MOCKS_FILE_NAME);
      ensureOrGenerateMockFile(targetPathToMocks, deprecatedPathToMocks, (str) => DocumentArray.decode(JSON.parse(str))._tag === "Right", () => [mocks.DocumentMock.generate(c.model, sharedSlices)], isTelemetryEnabled);
    });
  } catch (error) {
    if (isTelemetryEnabled) {
      sentryErrorHandlers.node("migrateAssets", error);
    }
  } finally {
    const dotSlicemachine = createPathToDeprecatedLibrary(manager.cwd);
    const prismicioTypesDTS = path__namespace.join(manager.cwd, "prismicio-types.d.ts");
    if (!fsSync__namespace.existsSync(prismicioTypesDTS)) {
      const sliceMachinePrismicioDTS = path__namespace.join(dotSlicemachine, "prismicio.d.ts");
      const prismicioDTS = path__namespace.join(manager.cwd, "prismicio.d.ts");
      if (fsSync__namespace.existsSync(sliceMachinePrismicioDTS)) {
        fsSync__namespace.renameSync(sliceMachinePrismicioDTS, prismicioTypesDTS);
      } else if (fsSync__namespace.existsSync(prismicioDTS)) {
        fsSync__namespace.renameSync(prismicioDTS, prismicioTypesDTS);
      }
    }
    if (fsSync__namespace.existsSync(dotSlicemachine)) {
      fsSync__namespace.rmSync(dotSlicemachine, { recursive: true });
    }
  }
};
exports.migrateAssets = migrateAssets;
//# sourceMappingURL=migrateAssets.cjs.map
