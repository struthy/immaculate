{"version":3,"file":"body.cjs","sources":["../../../../../../node_modules/node-fetch/src/body.js"],"sourcesContent":["\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'node:stream';\nimport {types, deprecate, promisify} from 'node:util';\nimport {Buffer} from 'node:buffer';\n\nimport Blob from 'fetch-blob';\nimport {FormData, formDataToBlob} from 'formdata-polyfill/esm.min.js';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {isBlob, isURLSearchParameters} from './utils/is.js';\n\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (body instanceof FormData) {\n\t\t\t// Body is FormData\n\t\t\tbody = formDataToBlob(body);\n\t\t\tboundary = body.type.split('=')[1];\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tlet stream = body;\n\n\t\tif (Buffer.isBuffer(body)) {\n\t\t\tstream = Stream.Readable.from(body);\n\t\t} else if (isBlob(body)) {\n\t\t\tstream = Stream.Readable.from(body.stream());\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tstream,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].stream;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\tasync formData() {\n\t\tconst ct = this.headers.get('content-type');\n\n\t\tif (ct.startsWith('application/x-www-form-urlencoded')) {\n\t\t\tconst formData = new FormData();\n\t\t\tconst parameters = new URLSearchParams(await this.text());\n\n\t\t\tfor (const [name, value] of parameters) {\n\t\t\t\tformData.append(name, value);\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\tconst {toFormData} = await import('./utils/multipart-parser.js');\n\t\treturn toFormData(this.body, ct);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.arrayBuffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst text = await this.text();\n\t\treturn JSON.parse(text);\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer');\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true},\n\tdata: {get: deprecate(() => {},\n\t\t'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead',\n\t\t'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tconst {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance[INTERNALS];\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].stream = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\nconst getNonSpecFormDataBoundary = deprecate(\n\tbody => body.getBoundary(),\n\t'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package',\n\t'https://github.com/node-fetch/node-fetch/issues/1167'\n);\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\tif (body instanceof FormData) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request[INTERNALS];\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\nexport const writeToStream = async (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tawait pipeline(body, dest);\n\t}\n};\n"],"names":["promisify","isURLSearchParameters","Buffer","isBlob","types","FormData","formDataToBlob","FetchBaseError","FetchError","Blob","deprecate","PassThrough"],"mappings":"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","x_google_ignoreList":[0]}