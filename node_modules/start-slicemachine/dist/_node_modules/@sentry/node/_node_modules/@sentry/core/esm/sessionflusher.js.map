{"version":3,"file":"sessionflusher.js","sources":["../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/core/esm/sessionflusher.js"],"sourcesContent":["import { dropUndefinedKeys } from '@sentry/utils';\nimport { getCurrentScope } from './exports.js';\n\n/**\n * @inheritdoc\n */\nclass SessionFlusher  {\n\n  // Cast to any so that it can use Node.js timeout\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n   constructor(client, attrs) {\n    this._client = client;\n    this.flushTimeout = 60;\n    this._pendingAggregates = {};\n    this._isEnabled = true;\n\n    // Call to setInterval, so that flush is called every 60 seconds.\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (this._intervalId.unref) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      this._intervalId.unref();\n    }\n    this._sessionAttrs = attrs;\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */\n   flush() {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this._client.sendSession(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n   getSessionAggregates() {\n    const aggregates = Object.keys(this._pendingAggregates).map((key) => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n\n    const sessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates,\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n   close() {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n   incrementSessionStatusCount() {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentScope();\n    const requestSession = scope.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      scope.setRequestSession(undefined);\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n   _incrementSessionStatusCount(status, date) {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\n\nexport { SessionFlusher };\n//# sourceMappingURL=sessionflusher.js.map\n"],"names":[],"mappings":";;AAMA,MAAM,eAAgB;AAAA;AAAA;AAAA,EAKnB,YAAY,QAAQ,OAAO;AAC1B,SAAK,UAAU;AACf,SAAK,eAAe;AACpB,SAAK,qBAAqB;AAC1B,SAAK,aAAa;AAGlB,SAAK,cAAc,YAAY,MAAM,KAAK,MAAK,GAAI,KAAK,eAAe,GAAI;AAE3E,QAAI,KAAK,YAAY,OAAO;AAE1B,WAAK,YAAY;IAClB;AACD,SAAK,gBAAgB;AAAA,EACtB;AAAA;AAAA,EAGA,QAAQ;AACP,UAAM,oBAAoB,KAAK;AAC/B,QAAI,kBAAkB,WAAW,WAAW,GAAG;AAC7C;AAAA,IACD;AACD,SAAK,qBAAqB;AAC1B,SAAK,QAAQ,YAAY,iBAAiB;AAAA,EAC3C;AAAA;AAAA,EAGA,uBAAuB;AACtB,UAAM,aAAa,OAAO,KAAK,KAAK,kBAAkB,EAAE,IAAI,CAAC,QAAQ;AACnE,aAAO,KAAK,mBAAmB,SAAS,GAAG,CAAC;AAAA,IAClD,CAAK;AAED,UAAM,oBAAoB;AAAA,MACxB,OAAO,KAAK;AAAA,MACZ;AAAA,IACN;AACI,WAAO,kBAAkB,iBAAiB;AAAA,EAC3C;AAAA;AAAA,EAGA,QAAQ;AACP,kBAAc,KAAK,WAAW;AAC9B,SAAK,aAAa;AAClB,SAAK,MAAK;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,8BAA8B;AAC7B,QAAI,CAAC,KAAK,YAAY;AACpB;AAAA,IACD;AACD,UAAM,QAAQ;AACd,UAAM,iBAAiB,MAAM;AAE7B,QAAI,kBAAkB,eAAe,QAAQ;AAC3C,WAAK,6BAA6B,eAAe,QAAQ,oBAAI,KAAM,CAAA;AAGnE,YAAM,kBAAkB,MAAS;AAAA,IAElC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,6BAA6B,QAAQ,MAAM;AAE1C,UAAM,sBAAsB,IAAI,KAAK,IAAI,EAAE,WAAW,GAAG,CAAC;AAC1D,SAAK,mBAAmB,mBAAmB,IAAI,KAAK,mBAAmB,mBAAmB,KAAK;AAI/F,UAAM,oBAAoB,KAAK,mBAAmB,mBAAmB;AACrE,QAAI,CAAC,kBAAkB,SAAS;AAC9B,wBAAkB,UAAU,IAAI,KAAK,mBAAmB,EAAE,YAAW;AAAA,IACtE;AAED,YAAQ,QAAM;AAAA,MACZ,KAAK;AACH,0BAAkB,WAAW,kBAAkB,WAAW,KAAK;AAC/D,eAAO,kBAAkB;AAAA,MAC3B,KAAK;AACH,0BAAkB,UAAU,kBAAkB,UAAU,KAAK;AAC7D,eAAO,kBAAkB;AAAA,MAC3B;AACE,0BAAkB,WAAW,kBAAkB,WAAW,KAAK;AAC/D,eAAO,kBAAkB;AAAA,IAC5B;AAAA,EACF;AACH;","x_google_ignoreList":[0]}