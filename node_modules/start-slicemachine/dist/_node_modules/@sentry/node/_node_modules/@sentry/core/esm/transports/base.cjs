"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const debugBuild = require("../debug-build.cjs");
const promisebuffer = require("../../../utils/esm/promisebuffer.cjs");
const envelope = require("../../../utils/esm/envelope.cjs");
const syncpromise = require("../../../utils/esm/syncpromise.cjs");
const error = require("../../../utils/esm/error.cjs");
const logger = require("../../../utils/esm/logger.cjs");
const ratelimit = require("../../../utils/esm/ratelimit.cjs");
const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
function createTransport(options, makeRequest, buffer = promisebuffer.makePromiseBuffer(
  options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
)) {
  let rateLimits = {};
  const flush = (timeout) => buffer.drain(timeout);
  function send(envelope$1) {
    const filteredEnvelopeItems = [];
    envelope.forEachEnvelopeItem(envelope$1, (item, type) => {
      const dataCategory = envelope.envelopeItemTypeToDataCategory(type);
      if (ratelimit.isRateLimited(rateLimits, dataCategory)) {
        const event = getEventForEnvelopeItem(item, type);
        options.recordDroppedEvent("ratelimit_backoff", dataCategory, event);
      } else {
        filteredEnvelopeItems.push(item);
      }
    });
    if (filteredEnvelopeItems.length === 0) {
      return syncpromise.resolvedSyncPromise();
    }
    const filteredEnvelope = envelope.createEnvelope(envelope$1[0], filteredEnvelopeItems);
    const recordEnvelopeLoss = (reason) => {
      envelope.forEachEnvelopeItem(filteredEnvelope, (item, type) => {
        const event = getEventForEnvelopeItem(item, type);
        options.recordDroppedEvent(reason, envelope.envelopeItemTypeToDataCategory(type), event);
      });
    };
    const requestTask = () => makeRequest({ body: envelope.serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(
      (response) => {
        if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
          debugBuild.DEBUG_BUILD && logger.logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
        }
        rateLimits = ratelimit.updateRateLimits(rateLimits, response);
        return response;
      },
      (error2) => {
        recordEnvelopeLoss("network_error");
        throw error2;
      }
    );
    return buffer.add(requestTask).then(
      (result) => result,
      (error$1) => {
        if (error$1 instanceof error.SentryError) {
          debugBuild.DEBUG_BUILD && logger.logger.error("Skipped sending event because buffer is full.");
          recordEnvelopeLoss("queue_overflow");
          return syncpromise.resolvedSyncPromise();
        } else {
          throw error$1;
        }
      }
    );
  }
  send.__sentry__baseTransport__ = true;
  return {
    send,
    flush
  };
}
function getEventForEnvelopeItem(item, type) {
  if (type !== "event" && type !== "transaction") {
    return void 0;
  }
  return Array.isArray(item) ? item[1] : void 0;
}
exports.DEFAULT_TRANSPORT_BUFFER_SIZE = DEFAULT_TRANSPORT_BUFFER_SIZE;
exports.createTransport = createTransport;
//# sourceMappingURL=base.cjs.map
