"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const debugBuild = require("../debug-build.cjs");
const semanticAttributes = require("../semanticAttributes.cjs");
const hasTracingEnabled = require("../utils/hasTracingEnabled.cjs");
const spanUtils = require("../utils/spanUtils.cjs");
const logger = require("../../../utils/esm/logger.cjs");
const is = require("../../../utils/esm/is.cjs");
function sampleTransaction(transaction, options, samplingContext) {
  if (!hasTracingEnabled.hasTracingEnabled(options)) {
    transaction.sampled = false;
    return transaction;
  }
  if (transaction.sampled !== void 0) {
    transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(transaction.sampled));
    return transaction;
  }
  let sampleRate;
  if (typeof options.tracesSampler === "function") {
    sampleRate = options.tracesSampler(samplingContext);
    transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(sampleRate));
  } else if (samplingContext.parentSampled !== void 0) {
    sampleRate = samplingContext.parentSampled;
  } else if (typeof options.tracesSampleRate !== "undefined") {
    sampleRate = options.tracesSampleRate;
    transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(sampleRate));
  } else {
    sampleRate = 1;
    transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, sampleRate);
  }
  if (!isValidSampleRate(sampleRate)) {
    debugBuild.DEBUG_BUILD && logger.logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
    transaction.sampled = false;
    return transaction;
  }
  if (!sampleRate) {
    debugBuild.DEBUG_BUILD && logger.logger.log(
      `[Tracing] Discarding transaction because ${typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
    );
    transaction.sampled = false;
    return transaction;
  }
  transaction.sampled = Math.random() < sampleRate;
  if (!transaction.sampled) {
    debugBuild.DEBUG_BUILD && logger.logger.log(
      `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
        sampleRate
      )})`
    );
    return transaction;
  }
  debugBuild.DEBUG_BUILD && // eslint-disable-next-line deprecation/deprecation
  logger.logger.log(`[Tracing] starting ${transaction.op} transaction - ${spanUtils.spanToJSON(transaction).description}`);
  return transaction;
}
function isValidSampleRate(rate) {
  if (is.isNaN(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
    debugBuild.DEBUG_BUILD && logger.logger.warn(
      `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
        rate
      )} of type ${JSON.stringify(typeof rate)}.`
    );
    return false;
  }
  if (rate < 0 || rate > 1) {
    debugBuild.DEBUG_BUILD && logger.logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);
    return false;
  }
  return true;
}
exports.isValidSampleRate = isValidSampleRate;
exports.sampleTransaction = sampleTransaction;
//# sourceMappingURL=sampling.cjs.map
