{"version":3,"file":"requestdata.cjs","sources":["../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/utils/esm/requestdata.js"],"sourcesContent":["import { parseCookie } from './cookie.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { isString, isPlainObject } from './is.js';\nimport { logger } from './logger.js';\nimport { normalize } from './normalize.js';\nimport { stripUrlQueryAndFragment } from './url.js';\n\nconst DEFAULT_INCLUDES = {\n  ip: false,\n  request: true,\n  transaction: true,\n  user: true,\n};\nconst DEFAULT_REQUEST_INCLUDES = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\nconst DEFAULT_USER_INCLUDES = ['id', 'username', 'email'];\n\n/**\n * Sets parameterized route as transaction name e.g.: `GET /users/:id`\n * Also adds more context data on the transaction from the request.\n *\n * @deprecated This utility will be removed in v8.\n */\nfunction addRequestDataToTransaction(\n  transaction,\n  req,\n  deps,\n) {\n  if (!transaction) return;\n  // eslint-disable-next-line deprecation/deprecation\n  if (!transaction.metadata.source || transaction.metadata.source === 'url') {\n    // Attempt to grab a parameterized route off of the request\n    const [name, source] = extractPathForTransaction(req, { path: true, method: true });\n    transaction.updateName(name);\n    // TODO: SEMANTIC_ATTRIBUTE_SENTRY_SOURCE is in core, align this once we merge utils & core\n    // eslint-disable-next-line deprecation/deprecation\n    transaction.setMetadata({ source });\n  }\n  transaction.setAttribute('url', req.originalUrl || req.url);\n  if (req.baseUrl) {\n    transaction.setAttribute('baseUrl', req.baseUrl);\n  }\n  // TODO: We need to rewrite this to a flat format?\n  // eslint-disable-next-line deprecation/deprecation\n  transaction.setData('query', extractQueryParams(req, deps));\n}\n\n/**\n * Extracts a complete and parameterized path from the request object and uses it to construct transaction name.\n * If the parameterized transaction name cannot be extracted, we fall back to the raw URL.\n *\n * Additionally, this function determines and returns the transaction name source\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req A request object\n * @param options What to include in the transaction name (method, path, or a custom route name to be\n *                used instead of the request's route)\n *\n * @returns A tuple of the fully constructed transaction name [0] and its source [1] (can be either 'route' or 'url')\n */\nfunction extractPathForTransaction(\n  req,\n  options = {},\n) {\n  const method = req.method && req.method.toUpperCase();\n\n  let path = '';\n  let source = 'url';\n\n  // Check to see if there's a parameterized route we can use (as there is in Express)\n  if (options.customRoute || req.route) {\n    path = options.customRoute || `${req.baseUrl || ''}${req.route && req.route.path}`;\n    source = 'route';\n  }\n\n  // Otherwise, just take the original URL\n  else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n\n  let name = '';\n  if (options.method && method) {\n    name += method;\n  }\n  if (options.method && options.path) {\n    name += ' ';\n  }\n  if (options.path && path) {\n    name += path;\n  }\n\n  return [name, source];\n}\n\n/** JSDoc */\nfunction extractTransaction(req, type) {\n  switch (type) {\n    case 'path': {\n      return extractPathForTransaction(req, { path: true })[0];\n    }\n    case 'handler': {\n      return (req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name) || '<anonymous>';\n    }\n    case 'methodPath':\n    default: {\n      // if exist _reconstructedRoute return that path instead of route.path\n      const customRoute = req._reconstructedRoute ? req._reconstructedRoute : undefined;\n      return extractPathForTransaction(req, { path: true, method: true, customRoute })[0];\n    }\n  }\n}\n\n/** JSDoc */\nfunction extractUserData(\n  user\n\n,\n  keys,\n) {\n  const extractedUser = {};\n  const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;\n\n  attributes.forEach(key => {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n\n  return extractedUser;\n}\n\n/**\n * Normalize data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param options.include An optional array of keys to include in the normalized data. Defaults to\n * DEFAULT_REQUEST_INCLUDES if not provided.\n * @param options.deps Injected, platform-specific dependencies\n * @returns An object containing normalized request data\n */\nfunction extractRequestData(\n  req,\n  options\n\n,\n) {\n  const { include = DEFAULT_REQUEST_INCLUDES, deps } = options || {};\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const requestData = {};\n\n  // headers:\n  //   node, express, koa, nextjs: req.headers\n  const headers = (req.headers || {})\n\n;\n  // method:\n  //   node, express, koa, nextjs: req.method\n  const method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n  // Express 4 mistakenly strips off port number from req.host / req.hostname so we can't rely on them\n  // See: https://github.com/expressjs/express/issues/3047#issuecomment-236653223\n  // Also: https://github.com/getsentry/sentry-javascript/issues/1917\n  const host = headers.host || req.hostname || req.host || '<no host>';\n  // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n  const protocol = req.protocol === 'https' || (req.socket && req.socket.encrypted) ? 'https' : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  const originalUrl = req.originalUrl || req.url || '';\n  // absolute url\n  const absoluteUrl = originalUrl.startsWith(protocol) ? originalUrl : `${protocol}://${host}${originalUrl}`;\n  include.forEach(key => {\n    switch (key) {\n      case 'headers': {\n        requestData.headers = headers;\n\n        // Remove the Cookie header in case cookie data should not be included in the event\n        if (!include.includes('cookies')) {\n          delete (requestData.headers ).cookie;\n        }\n\n        break;\n      }\n      case 'method': {\n        requestData.method = method;\n        break;\n      }\n      case 'url': {\n        requestData.url = absoluteUrl;\n        break;\n      }\n      case 'cookies': {\n        // cookies:\n        //   node, express, koa: req.headers.cookie\n        //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n        requestData.cookies =\n          // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can\n          // come off in v8\n          req.cookies || (headers.cookie && parseCookie(headers.cookie)) || {};\n        break;\n      }\n      case 'query_string': {\n        // query string:\n        //   node: req.url (raw)\n        //   express, koa, nextjs: req.query\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        requestData.query_string = extractQueryParams(req, deps);\n        break;\n      }\n      case 'data': {\n        if (method === 'GET' || method === 'HEAD') {\n          break;\n        }\n        // body data:\n        //   express, koa, nextjs: req.body\n        //\n        //   when using node by itself, you have to read the incoming stream(see\n        //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n        //   where they're going to store the final result, so they'll have to capture this data themselves\n        if (req.body !== undefined) {\n          requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));\n        }\n        break;\n      }\n      default: {\n        if ({}.hasOwnProperty.call(req, key)) {\n          requestData[key] = (req )[key];\n        }\n      }\n    }\n  });\n\n  return requestData;\n}\n\n/**\n * Add data from the given request to the given event\n *\n * @param event The event to which the request data will be added\n * @param req Request object\n * @param options.include Flags to control what data is included\n * @param options.deps Injected platform-specific dependencies\n * @returns The mutated `Event` object\n */\nfunction addRequestDataToEvent(\n  event,\n  req,\n  options,\n) {\n  const include = {\n    ...DEFAULT_INCLUDES,\n    ...(options && options.include),\n  };\n\n  if (include.request) {\n    const extractedRequestData = Array.isArray(include.request)\n      ? extractRequestData(req, { include: include.request, deps: options && options.deps })\n      : extractRequestData(req, { deps: options && options.deps });\n\n    event.request = {\n      ...event.request,\n      ...extractedRequestData,\n    };\n  }\n\n  if (include.user) {\n    const extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};\n\n    if (Object.keys(extractedUser).length) {\n      event.user = {\n        ...event.user,\n        ...extractedUser,\n      };\n    }\n  }\n\n  // client ip:\n  //   node, nextjs: req.socket.remoteAddress\n  //   express, koa: req.ip\n  if (include.ip) {\n    const ip = req.ip || (req.socket && req.socket.remoteAddress);\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n\n  if (include.transaction && !event.transaction) {\n    // TODO do we even need this anymore?\n    // TODO make this work for nextjs\n    event.transaction = extractTransaction(req, include.transaction);\n  }\n\n  return event;\n}\n\nfunction extractQueryParams(\n  req,\n  deps,\n) {\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  let originalUrl = req.originalUrl || req.url || '';\n\n  if (!originalUrl) {\n    return;\n  }\n\n  // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n  // hostname on the beginning. Since the point here is just to grab the query string, it doesn't matter what we use.\n  if (originalUrl.startsWith('/')) {\n    originalUrl = `http://dogs.are.great${originalUrl}`;\n  }\n\n  try {\n    return (\n      req.query ||\n      (typeof URL !== 'undefined' && new URL(originalUrl).search.slice(1)) ||\n      // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node\n      (deps && deps.url && deps.url.parse(originalUrl).query) ||\n      undefined\n    );\n  } catch (e2) {\n    return undefined;\n  }\n}\n\n/**\n * Transforms a `Headers` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into a simple key-value dict.\n * The header keys will be lower case: e.g. A \"Content-Type\" header will be stored as \"content-type\".\n */\n// TODO(v8): Make this function return undefined when the extraction fails.\nfunction winterCGHeadersToDict(winterCGHeaders) {\n  const headers = {};\n  try {\n    winterCGHeaders.forEach((value, key) => {\n      if (typeof value === 'string') {\n        // We check that value is a string even though it might be redundant to make sure prototype pollution is not possible.\n        headers[key] = value;\n      }\n    });\n  } catch (e) {\n    DEBUG_BUILD &&\n      logger.warn('Sentry failed extracting headers from a request object. If you see this, please file an issue.');\n  }\n\n  return headers;\n}\n\n/**\n * Converts a `Request` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into the format that the `RequestData` integration understands.\n */\nfunction winterCGRequestToRequestData(req) {\n  const headers = winterCGHeadersToDict(req.headers);\n  return {\n    method: req.method,\n    url: req.url,\n    headers,\n  };\n}\n\nexport { DEFAULT_USER_INCLUDES, addRequestDataToEvent, addRequestDataToTransaction, extractPathForTransaction, extractRequestData, winterCGHeadersToDict, winterCGRequestToRequestData };\n//# sourceMappingURL=requestdata.js.map\n"],"names":["stripUrlQueryAndFragment","parseCookie","isString","normalize","isPlainObject"],"mappings":"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","x_google_ignoreList":[0]}