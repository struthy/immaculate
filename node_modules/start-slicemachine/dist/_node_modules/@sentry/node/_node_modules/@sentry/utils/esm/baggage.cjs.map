{"version":3,"file":"baggage.cjs","sources":["../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/utils/esm/baggage.js"],"sourcesContent":["import { DEBUG_BUILD } from './debug-build.js';\nimport { isString } from './is.js';\nimport { logger } from './logger.js';\n\nconst BAGGAGE_HEADER_NAME = 'baggage';\n\nconst SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\n\nconst SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nconst MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */\nfunction baggageHeaderToDynamicSamplingContext(\n  // Very liberal definition of what any incoming header might look like\n  baggageHeader,\n) {\n  if (!isString(baggageHeader) && !Array.isArray(baggageHeader)) {\n    return undefined;\n  }\n\n  // Intermediary object to store baggage key value pairs of incoming baggage headers on.\n  // It is later used to read Sentry-DSC-values from.\n  let baggageObject = {};\n\n  if (Array.isArray(baggageHeader)) {\n    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n    baggageObject = baggageHeader.reduce((acc, curr) => {\n      const currBaggageObject = baggageHeaderToObject(curr);\n      for (const key of Object.keys(currBaggageObject)) {\n        acc[key] = currBaggageObject[key];\n      }\n      return acc;\n    }, {});\n  } else {\n    // Return undefined if baggage header is an empty string (technically an empty baggage header is not spec conform but\n    // this is how we choose to handle it)\n    if (!baggageHeader) {\n      return undefined;\n    }\n\n    baggageObject = baggageHeaderToObject(baggageHeader);\n  }\n\n  // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {\n    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n      acc[nonPrefixedKey] = value;\n    }\n    return acc;\n  }, {});\n\n  // Only return a dynamic sampling context object if there are keys in it.\n  // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n  if (Object.keys(dynamicSamplingContext).length > 0) {\n    return dynamicSamplingContext ;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */\nfunction dynamicSamplingContextToSentryBaggageHeader(\n  // this also takes undefined for convenience and bundle size in other places\n  dynamicSamplingContext,\n) {\n  if (!dynamicSamplingContext) {\n    return undefined;\n  }\n\n  // Prefix all DSC keys with \"sentry-\" and put them into a new object\n  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(\n    (acc, [dscKey, dscValue]) => {\n      if (dscValue) {\n        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  return objectToBaggageHeader(sentryPrefixedDSC);\n}\n\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */\nfunction baggageHeaderToObject(baggageHeader) {\n  return baggageHeader\n    .split(',')\n    .map(baggageEntry => baggageEntry.split('=').map(keyOrValue => decodeURIComponent(keyOrValue.trim())))\n    .reduce((acc, [key, value]) => {\n      acc[key] = value;\n      return acc;\n    }, {});\n}\n\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */\nfunction objectToBaggageHeader(object) {\n  if (Object.keys(object).length === 0) {\n    // An empty baggage header is not spec compliant: We return undefined.\n    return undefined;\n  }\n\n  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {\n    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n      DEBUG_BUILD &&\n        logger.warn(\n          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`,\n        );\n      return baggageHeader;\n    } else {\n      return newBaggageHeader;\n    }\n  }, '');\n}\n\nexport { BAGGAGE_HEADER_NAME, MAX_BAGGAGE_STRING_LENGTH, SENTRY_BAGGAGE_KEY_PREFIX, SENTRY_BAGGAGE_KEY_PREFIX_REGEX, baggageHeaderToDynamicSamplingContext, dynamicSamplingContextToSentryBaggageHeader };\n//# sourceMappingURL=baggage.js.map\n"],"names":["isString","DEBUG_BUILD","logger"],"mappings":";;;;;AAMK,MAAC,4BAA4B;AAE7B,MAAC,kCAAkC;AAOnC,MAAC,4BAA4B;AASlC,SAAS,sCAEP,eACA;AACA,MAAI,CAACA,GAAQ,SAAC,aAAa,KAAK,CAAC,MAAM,QAAQ,aAAa,GAAG;AAC7D,WAAO;AAAA,EACR;AAID,MAAI,gBAAgB,CAAA;AAEpB,MAAI,MAAM,QAAQ,aAAa,GAAG;AAEhC,oBAAgB,cAAc,OAAO,CAAC,KAAK,SAAS;AAClD,YAAM,oBAAoB,sBAAsB,IAAI;AACpD,iBAAW,OAAO,OAAO,KAAK,iBAAiB,GAAG;AAChD,YAAI,GAAG,IAAI,kBAAkB,GAAG;AAAA,MACjC;AACD,aAAO;AAAA,IACR,GAAE,CAAE,CAAA;AAAA,EACT,OAAS;AAGL,QAAI,CAAC,eAAe;AAClB,aAAO;AAAA,IACR;AAED,oBAAgB,sBAAsB,aAAa;AAAA,EACpD;AAGD,QAAM,yBAAyB,OAAO,QAAQ,aAAa,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK,MAAM;AACzF,QAAI,IAAI,MAAM,+BAA+B,GAAG;AAC9C,YAAM,iBAAiB,IAAI,MAAM,0BAA0B,MAAM;AACjE,UAAI,cAAc,IAAI;AAAA,IACvB;AACD,WAAO;AAAA,EACR,GAAE,CAAE,CAAA;AAIL,MAAI,OAAO,KAAK,sBAAsB,EAAE,SAAS,GAAG;AAClD,WAAO;AAAA,EACX,OAAS;AACL,WAAO;AAAA,EACR;AACH;AAWA,SAAS,4CAEP,wBACA;AACA,MAAI,CAAC,wBAAwB;AAC3B,WAAO;AAAA,EACR;AAGD,QAAM,oBAAoB,OAAO,QAAQ,sBAAsB,EAAE;AAAA,IAC/D,CAAC,KAAK,CAAC,QAAQ,QAAQ,MAAM;AAC3B,UAAI,UAAU;AACZ,YAAI,GAAG,4BAA4B,QAAQ,IAAI;AAAA,MAChD;AACD,aAAO;AAAA,IACR;AAAA,IACD,CAAE;AAAA,EACN;AAEE,SAAO,sBAAsB,iBAAiB;AAChD;AAQA,SAAS,sBAAsB,eAAe;AAC5C,SAAO,cACJ,MAAM,GAAG,EACT,IAAI,kBAAgB,aAAa,MAAM,GAAG,EAAE,IAAI,gBAAc,mBAAmB,WAAW,KAAI,CAAE,CAAC,CAAC,EACpG,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK,MAAM;AAC7B,QAAI,GAAG,IAAI;AACX,WAAO;AAAA,EACR,GAAE,CAAE,CAAA;AACT;AASA,SAAS,sBAAsB,QAAQ;AACrC,MAAI,OAAO,KAAK,MAAM,EAAE,WAAW,GAAG;AAEpC,WAAO;AAAA,EACR;AAED,SAAO,OAAO,QAAQ,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,WAAW,WAAW,GAAG,iBAAiB;AAC9F,UAAM,eAAe,GAAG,mBAAmB,SAAS,KAAK,mBAAmB,WAAW;AACvF,UAAM,mBAAmB,iBAAiB,IAAI,eAAe,GAAG,iBAAiB;AACjF,QAAI,iBAAiB,SAAS,2BAA2B;AACvDC,iBAAW,eACTC,OAAAA,OAAO;AAAA,QACL,mBAAmB,uBAAuB;AAAA,MACpD;AACM,aAAO;AAAA,IACb,OAAW;AACL,aAAO;AAAA,IACR;AAAA,EACF,GAAE,EAAE;AACP;;;;;;","x_google_ignoreList":[0]}