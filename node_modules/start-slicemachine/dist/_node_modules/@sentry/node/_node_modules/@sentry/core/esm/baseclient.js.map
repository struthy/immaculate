{"version":3,"file":"baseclient.js","sources":["../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/core/esm/baseclient.js"],"sourcesContent":["import { makeDsn, logger, checkOrSetAlreadyCaught, isParameterizedString, isPrimitive, resolvedSyncPromise, addItemToEnvelope, createAttachmentEnvelopeItem, SyncPromise, rejectedSyncPromise, SentryError, isThenable, isPlainObject } from '@sentry/utils';\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope.js';\nimport { getClient } from './exports.js';\nimport { getIsolationScope } from './hub.js';\nimport { setupIntegration, afterSetupIntegrations, setupIntegrations } from './integration.js';\nimport { createMetricEnvelope } from './metrics/envelope.js';\nimport { updateSession } from './session.js';\nimport { getDynamicSamplingContextFromClient } from './tracing/dynamicSamplingContext.js';\nimport { prepareEvent } from './utils/prepareEvent.js';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nclass BaseClient {\n  /**\n   * A reference to a metrics aggregator\n   *\n   * @experimental Note this is alpha API. It may experience breaking changes in the future.\n   */\n\n  /** Options passed to the SDK. */\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n\n  /** Array of set up integrations. */\n\n  /** Indicates whether this client's integrations have been set up. */\n\n  /** Number of calls being processed */\n\n  /** Holds flushable  */\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n   constructor(options) {\n    this._options = options;\n    this._integrations = {};\n    this._integrationsInitialized = false;\n    this._numProcessing = 0;\n    this._outcomes = {};\n    this._hooks = {};\n    this._eventProcessors = [];\n\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    } else {\n      DEBUG_BUILD && logger.warn('No DSN provided, client will not send events.');\n    }\n\n    if (this._dsn) {\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport({\n        tunnel: this._options.tunnel,\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n   captureException(exception, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId = hint && hint.event_id;\n\n    this._process(\n      this.eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureMessage(\n    message,\n    // eslint-disable-next-line deprecation/deprecation\n    level,\n    hint,\n    scope,\n  ) {\n    let eventId = hint && hint.event_id;\n\n    const eventMessage = isParameterizedString(message) ? message : String(message);\n\n    const promisedEvent = isPrimitive(message)\n      ? this.eventFromMessage(eventMessage, level, hint)\n      : this.eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId = hint && hint.event_id;\n\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;\n\n    this._process(\n      this._captureEvent(event, hint, capturedSpanScope || scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureSession(session) {\n    if (!(typeof session.release === 'string')) {\n      DEBUG_BUILD && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this.sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      updateSession(session, { init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getDsn() {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getOptions() {\n    return this._options;\n  }\n\n  /**\n   * @see SdkMetadata in @sentry/types\n   *\n   * @return The metadata of the SDK\n   */\n   getSdkMetadata() {\n    return this._options._metadata;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTransport() {\n    return this._transport;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   flush(timeout) {\n    const transport = this._transport;\n    if (transport) {\n      if (this.metricsAggregator) {\n        this.metricsAggregator.flush();\n      }\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   close(timeout) {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      if (this.metricsAggregator) {\n        this.metricsAggregator.close();\n      }\n      return result;\n    });\n  }\n\n  /** Get all installed event processors. */\n   getEventProcessors() {\n    return this._eventProcessors;\n  }\n\n  /** @inheritDoc */\n   addEventProcessor(eventProcessor) {\n    this._eventProcessors.push(eventProcessor);\n  }\n\n  /**\n   * This is an internal function to setup all integrations that should run on the client.\n   * @deprecated Use `client.init()` instead.\n   */\n   setupIntegrations(forceInitialize) {\n    if ((forceInitialize && !this._integrationsInitialized) || (this._isEnabled() && !this._integrationsInitialized)) {\n      this._setupIntegrations();\n    }\n  }\n\n  /** @inheritdoc */\n   init() {\n    if (this._isEnabled()) {\n      this._setupIntegrations();\n    }\n  }\n\n  /**\n   * Gets an installed integration by its `id`.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n   * @deprecated Use `getIntegrationByName()` instead.\n   */\n   getIntegrationById(integrationId) {\n    return this.getIntegrationByName(integrationId);\n  }\n\n  /**\n   * Gets an installed integration by its name.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `name` was installed.\n   */\n   getIntegrationByName(integrationName) {\n    return this._integrations[integrationName] ;\n  }\n\n  /**\n   * Returns the client's instance of the given integration class, it any.\n   * @deprecated Use `getIntegrationByName()` instead.\n   */\n   getIntegration(integration) {\n    try {\n      return (this._integrations[integration.id] ) || null;\n    } catch (_oO) {\n      DEBUG_BUILD && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addIntegration(integration) {\n    const isAlreadyInstalled = this._integrations[integration.name];\n\n    // This hook takes care of only installing if not already installed\n    setupIntegration(this, integration, this._integrations);\n    // Here we need to check manually to make sure to not run this multiple times\n    if (!isAlreadyInstalled) {\n      afterSetupIntegrations(this, [integration]);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendEvent(event, hint = {}) {\n    this.emit('beforeSendEvent', event, hint);\n\n    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n    for (const attachment of hint.attachments || []) {\n      env = addItemToEnvelope(\n        env,\n        createAttachmentEnvelopeItem(\n          attachment,\n          this._options.transportOptions && this._options.transportOptions.textEncoder,\n        ),\n      );\n    }\n\n    const promise = this._sendEnvelope(env);\n    if (promise) {\n      promise.then(sendResponse => this.emit('afterSendEvent', event, sendResponse), null);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendSession(session) {\n    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n\n    // _sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._sendEnvelope(env);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   recordDroppedEvent(reason, category, _event) {\n    // Note: we use `event` in replay, where we overwrite this hook.\n\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      DEBUG_BUILD && logger.log(`Adding outcome: \"${key}\"`);\n\n      // The following works because undefined + 1 === NaN and NaN is falsy\n      this._outcomes[key] = this._outcomes[key] + 1 || 1;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureAggregateMetrics(metricBucketItems) {\n    DEBUG_BUILD && logger.log(`Flushing aggregated metrics, number of metrics: ${metricBucketItems.length}`);\n    const metricsEnvelope = createMetricEnvelope(\n      metricBucketItems,\n      this._dsn,\n      this._options._metadata,\n      this._options.tunnel,\n    );\n\n    // _sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._sendEnvelope(metricsEnvelope);\n  }\n\n  // Keep on() & emit() signatures in sync with types' client.ts interface\n  /* eslint-disable @typescript-eslint/unified-signatures */\n\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n   on(hook, callback) {\n    if (!this._hooks[hook]) {\n      this._hooks[hook] = [];\n    }\n\n    // @ts-expect-error We assue the types are correct\n    this._hooks[hook].push(callback);\n  }\n\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n   emit(hook, ...rest) {\n    if (this._hooks[hook]) {\n      this._hooks[hook].forEach(callback => callback(...rest));\n    }\n  }\n\n  /* eslint-enable @typescript-eslint/unified-signatures */\n\n  /** Setup integrations for this client. */\n   _setupIntegrations() {\n    const { integrations } = this._options;\n    this._integrations = setupIntegrations(this, integrations);\n    afterSetupIntegrations(this, integrations);\n\n    // TODO v8: We don't need this flag anymore\n    this._integrationsInitialized = true;\n  }\n\n  /** Updates existing session based on the provided event */\n   _updateSessionFromEvent(session, event) {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n   _isClientDoneProcessing(timeout) {\n    return new SyncPromise(resolve => {\n      let ticked = 0;\n      const tick = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a transport is present. */\n   _isEnabled() {\n    return this.getOptions().enabled !== false && this._transport !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n   _prepareEvent(\n    event,\n    hint,\n    scope,\n    isolationScope = getIsolationScope(),\n  ) {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations.length > 0) {\n      hint.integrations = integrations;\n    }\n\n    this.emit('preprocessEvent', event, hint);\n\n    return prepareEvent(options, event, hint, scope, this, isolationScope).then(evt => {\n      if (evt === null) {\n        return evt;\n      }\n\n      const propagationContext = {\n        ...isolationScope.getPropagationContext(),\n        ...(scope ? scope.getPropagationContext() : undefined),\n      };\n\n      const trace = evt.contexts && evt.contexts.trace;\n      if (!trace && propagationContext) {\n        const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;\n        evt.contexts = {\n          trace: {\n            trace_id,\n            span_id: spanId,\n            parent_span_id: parentSpanId,\n          },\n          ...evt.contexts,\n        };\n\n        const dynamicSamplingContext = dsc ? dsc : getDynamicSamplingContextFromClient(trace_id, this, scope);\n\n        evt.sdkProcessingMetadata = {\n          dynamicSamplingContext,\n          ...evt.sdkProcessingMetadata,\n        };\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n   _captureEvent(event, hint = {}, scope) {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if (DEBUG_BUILD) {\n          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n          // control flow, log just the message (no stack) as a log-level log.\n          const sentryError = reason ;\n          if (sentryError.logLevel === 'log') {\n            logger.log(sentryError.message);\n          } else {\n            logger.warn(sentryError);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n   _processEvent(event, hint, scope) {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (isError && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error', event);\n      return rejectedSyncPromise(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n          'log',\n        ),\n      );\n    }\n\n    const dataCategory = eventType === 'replay_event' ? 'replay' : eventType;\n\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;\n\n    return this._prepareEvent(event, hint, scope, capturedSpanIsolationScope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', dataCategory, event);\n          throw new SentryError('An event processor returned `null`, will not send event.', 'log');\n        }\n\n        const isInternalException = hint.data && (hint.data ).__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n\n        const result = processBeforeSend(options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', dataCategory, event);\n          throw new SentryError(`${beforeSendLabel} returned \\`null\\`, will not send event.`, 'log');\n        }\n\n        const session = scope && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n   _process(promise) {\n    this._numProcessing++;\n    void promise.then(\n      value => {\n        this._numProcessing--;\n        return value;\n      },\n      reason => {\n        this._numProcessing--;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n   _sendEnvelope(envelope) {\n    this.emit('beforeEnvelope', envelope);\n\n    if (this._isEnabled() && this._transport) {\n      return this._transport.send(envelope).then(null, reason => {\n        DEBUG_BUILD && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      DEBUG_BUILD && logger.error('Transport disabled');\n    }\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n   _clearOutcomes() {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.keys(outcomes).map(key => {\n      const [reason, category] = key.split(':') ;\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\n}\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult,\n  beforeSendLabel,\n) {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!isPlainObject(event) && event !== null) {\n          throw new SentryError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`${beforeSendLabel} rejected with ${e}`);\n      },\n    );\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw new SentryError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(\n  options,\n  event,\n  hint,\n) {\n  const { beforeSend, beforeSendTransaction } = options;\n\n  if (isErrorEvent(event) && beforeSend) {\n    return beforeSend(event, hint);\n  }\n\n  if (isTransactionEvent(event) && beforeSendTransaction) {\n    return beforeSendTransaction(event, hint);\n  }\n\n  return event;\n}\n\nfunction isErrorEvent(event) {\n  return event.type === undefined;\n}\n\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\n\n/**\n * Add an event processor to the current client.\n * This event processor will run for all events processed by this client.\n */\nfunction addEventProcessor(callback) {\n  const client = getClient();\n\n  if (!client || !client.addEventProcessor) {\n    return;\n  }\n\n  client.addEventProcessor(callback);\n}\n\nexport { BaseClient, addEventProcessor };\n//# sourceMappingURL=baseclient.js.map\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAYA,MAAM,qBAAqB;AAiC3B,MAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0Bd,YAAY,SAAS;AACpB,SAAK,WAAW;AAChB,SAAK,gBAAgB;AACrB,SAAK,2BAA2B;AAChC,SAAK,iBAAiB;AACtB,SAAK,YAAY;AACjB,SAAK,SAAS;AACd,SAAK,mBAAmB;AAExB,QAAI,QAAQ,KAAK;AACf,WAAK,OAAO,QAAQ,QAAQ,GAAG;AAAA,IACrC,OAAW;AACL,qBAAe,OAAO,KAAK,+CAA+C;AAAA,IAC3E;AAED,QAAI,KAAK,MAAM;AACb,YAAM,MAAM,sCAAsC,KAAK,MAAM,OAAO;AACpE,WAAK,aAAa,QAAQ,UAAU;AAAA,QAClC,QAAQ,KAAK,SAAS;AAAA,QACtB,oBAAoB,KAAK,mBAAmB,KAAK,IAAI;AAAA,QACrD,GAAG,QAAQ;AAAA,QACX;AAAA,MACR,CAAO;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB,WAAW,MAAM,OAAO;AAExC,QAAI,wBAAwB,SAAS,GAAG;AACtC,qBAAe,OAAO,IAAI,kBAAkB;AAC5C;AAAA,IACD;AAED,QAAI,UAAU,QAAQ,KAAK;AAE3B,SAAK;AAAA,MACH,KAAK,mBAAmB,WAAW,IAAI,EACpC,KAAK,WAAS,KAAK,cAAc,OAAO,MAAM,KAAK,CAAC,EACpD,KAAK,YAAU;AACd,kBAAU;AAAA,MACpB,CAAS;AAAA,IACT;AAEI,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,eACC,SAEA,OACA,MACA,OACA;AACA,QAAI,UAAU,QAAQ,KAAK;AAE3B,UAAM,eAAe,sBAAsB,OAAO,IAAI,UAAU,OAAO,OAAO;AAE9E,UAAM,gBAAgB,YAAY,OAAO,IACrC,KAAK,iBAAiB,cAAc,OAAO,IAAI,IAC/C,KAAK,mBAAmB,SAAS,IAAI;AAEzC,SAAK;AAAA,MACH,cACG,KAAK,WAAS,KAAK,cAAc,OAAO,MAAM,KAAK,CAAC,EACpD,KAAK,YAAU;AACd,kBAAU;AAAA,MACpB,CAAS;AAAA,IACT;AAEI,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,OAAO,MAAM,OAAO;AAEhC,QAAI,QAAQ,KAAK,qBAAqB,wBAAwB,KAAK,iBAAiB,GAAG;AACrF,qBAAe,OAAO,IAAI,kBAAkB;AAC5C;AAAA,IACD;AAED,QAAI,UAAU,QAAQ,KAAK;AAE3B,UAAM,wBAAwB,MAAM,yBAAyB;AAC7D,UAAM,oBAAoB,sBAAsB;AAEhD,SAAK;AAAA,MACH,KAAK,cAAc,OAAO,MAAM,qBAAqB,KAAK,EAAE,KAAK,YAAU;AACzE,kBAAU;AAAA,MAClB,CAAO;AAAA,IACP;AAEI,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,SAAS;AACvB,QAAI,EAAE,OAAO,QAAQ,YAAY,WAAW;AAC1C,qBAAe,OAAO,KAAK,4DAA4D;AAAA,IAC7F,OAAW;AACL,WAAK,YAAY,OAAO;AAExB,oBAAc,SAAS,EAAE,MAAM,MAAO,CAAA;AAAA,IACvC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS;AACR,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa;AACZ,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiB;AAChB,WAAO,KAAK,SAAS;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe;AACd,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS;AACd,UAAM,YAAY,KAAK;AACvB,QAAI,WAAW;AACb,UAAI,KAAK,mBAAmB;AAC1B,aAAK,kBAAkB;MACxB;AACD,aAAO,KAAK,wBAAwB,OAAO,EAAE,KAAK,oBAAkB;AAClE,eAAO,UAAU,MAAM,OAAO,EAAE,KAAK,sBAAoB,kBAAkB,gBAAgB;AAAA,MACnG,CAAO;AAAA,IACP,OAAW;AACL,aAAO,oBAAoB,IAAI;AAAA,IAChC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS;AACd,WAAO,KAAK,MAAM,OAAO,EAAE,KAAK,YAAU;AACxC,WAAK,WAAU,EAAG,UAAU;AAC5B,UAAI,KAAK,mBAAmB;AAC1B,aAAK,kBAAkB;MACxB;AACD,aAAO;AAAA,IACb,CAAK;AAAA,EACF;AAAA;AAAA,EAGA,qBAAqB;AACpB,WAAO,KAAK;AAAA,EACb;AAAA;AAAA,EAGA,kBAAkB,gBAAgB;AACjC,SAAK,iBAAiB,KAAK,cAAc;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,iBAAiB;AAClC,QAAK,mBAAmB,CAAC,KAAK,4BAA8B,KAAK,gBAAgB,CAAC,KAAK,0BAA2B;AAChH,WAAK,mBAAkB;AAAA,IACxB;AAAA,EACF;AAAA;AAAA,EAGA,OAAO;AACN,QAAI,KAAK,cAAc;AACrB,WAAK,mBAAkB;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,mBAAmB,eAAe;AACjC,WAAO,KAAK,qBAAqB,aAAa;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qBAAqB,iBAAiB;AACrC,WAAO,KAAK,cAAc,eAAe;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,aAAa;AAC3B,QAAI;AACF,aAAQ,KAAK,cAAc,YAAY,EAAE,KAAO;AAAA,IACjD,SAAQ,KAAP;AACA,qBAAe,OAAO,KAAK,+BAA+B,YAAY,4BAA4B;AAClG,aAAO;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,aAAa;AAC3B,UAAM,qBAAqB,KAAK,cAAc,YAAY,IAAI;AAG9D,qBAAiB,MAAM,aAAa,KAAK,aAAa;AAEtD,QAAI,CAAC,oBAAoB;AACvB,6BAAuB,MAAM,CAAC,WAAW,CAAC;AAAA,IAC3C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,OAAO,OAAO,IAAI;AAC3B,SAAK,KAAK,mBAAmB,OAAO,IAAI;AAExC,QAAI,MAAM,oBAAoB,OAAO,KAAK,MAAM,KAAK,SAAS,WAAW,KAAK,SAAS,MAAM;AAE7F,eAAW,cAAc,KAAK,eAAe,CAAA,GAAI;AAC/C,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,UACE;AAAA,UACA,KAAK,SAAS,oBAAoB,KAAK,SAAS,iBAAiB;AAAA,QAClE;AAAA,MACT;AAAA,IACK;AAED,UAAM,UAAU,KAAK,cAAc,GAAG;AACtC,QAAI,SAAS;AACX,cAAQ,KAAK,kBAAgB,KAAK,KAAK,kBAAkB,OAAO,YAAY,GAAG,IAAI;AAAA,IACpF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,SAAS;AACpB,UAAM,MAAM,sBAAsB,SAAS,KAAK,MAAM,KAAK,SAAS,WAAW,KAAK,SAAS,MAAM;AAInG,SAAK,cAAc,GAAG;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB,QAAQ,UAAU,QAAQ;AAG5C,QAAI,KAAK,SAAS,mBAAmB;AAOnC,YAAM,MAAM,GAAG,UAAU;AACzB,qBAAe,OAAO,IAAI,oBAAoB,MAAM;AAGpD,WAAK,UAAU,GAAG,IAAI,KAAK,UAAU,GAAG,IAAI,KAAK;AAAA,IAClD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,wBAAwB,mBAAmB;AAC1C,mBAAe,OAAO,IAAI,mDAAmD,kBAAkB,QAAQ;AACvG,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA,KAAK;AAAA,MACL,KAAK,SAAS;AAAA,MACd,KAAK,SAAS;AAAA,IACpB;AAII,SAAK,cAAc,eAAe;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,GAAG,MAAM,UAAU;AAClB,QAAI,CAAC,KAAK,OAAO,IAAI,GAAG;AACtB,WAAK,OAAO,IAAI,IAAI;IACrB;AAGD,SAAK,OAAO,IAAI,EAAE,KAAK,QAAQ;AAAA,EAChC;AAAA;AAAA;AAAA,EAKA,KAAK,SAAS,MAAM;AACnB,QAAI,KAAK,OAAO,IAAI,GAAG;AACrB,WAAK,OAAO,IAAI,EAAE,QAAQ,cAAY,SAAS,GAAG,IAAI,CAAC;AAAA,IACxD;AAAA,EACF;AAAA;AAAA;AAAA,EAKA,qBAAqB;AACpB,UAAM,EAAE,aAAY,IAAK,KAAK;AAC9B,SAAK,gBAAgB,kBAAkB,MAAM,YAAY;AACzD,2BAAuB,MAAM,YAAY;AAGzC,SAAK,2BAA2B;AAAA,EACjC;AAAA;AAAA,EAGA,wBAAwB,SAAS,OAAO;AACvC,QAAI,UAAU;AACd,QAAI,UAAU;AACd,UAAM,aAAa,MAAM,aAAa,MAAM,UAAU;AAEtD,QAAI,YAAY;AACd,gBAAU;AAEV,iBAAW,MAAM,YAAY;AAC3B,cAAM,YAAY,GAAG;AACrB,YAAI,aAAa,UAAU,YAAY,OAAO;AAC5C,oBAAU;AACV;AAAA,QACD;AAAA,MACF;AAAA,IACF;AAKD,UAAM,qBAAqB,QAAQ,WAAW;AAC9C,UAAM,sBAAuB,sBAAsB,QAAQ,WAAW,KAAO,sBAAsB;AAEnG,QAAI,qBAAqB;AACvB,oBAAc,SAAS;AAAA,QACrB,GAAI,WAAW,EAAE,QAAQ;QACzB,QAAQ,QAAQ,UAAU,OAAO,WAAW,OAAO;AAAA,MAC3D,CAAO;AACD,WAAK,eAAe,OAAO;AAAA,IAC5B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,wBAAwB,SAAS;AAChC,WAAO,IAAI,YAAY,aAAW;AAChC,UAAI,SAAS;AACb,YAAM,OAAO;AAEb,YAAM,WAAW,YAAY,MAAM;AACjC,YAAI,KAAK,kBAAkB,GAAG;AAC5B,wBAAc,QAAQ;AACtB,kBAAQ,IAAI;AAAA,QACtB,OAAe;AACL,oBAAU;AACV,cAAI,WAAW,UAAU,SAAS;AAChC,0BAAc,QAAQ;AACtB,oBAAQ,KAAK;AAAA,UACd;AAAA,QACF;AAAA,MACF,GAAE,IAAI;AAAA,IACb,CAAK;AAAA,EACF;AAAA;AAAA,EAGA,aAAa;AACZ,WAAO,KAAK,aAAa,YAAY,SAAS,KAAK,eAAe;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,cACC,OACA,MACA,OACA,iBAAiB,kBAAmB,GACpC;AACA,UAAM,UAAU,KAAK;AACrB,UAAM,eAAe,OAAO,KAAK,KAAK,aAAa;AACnD,QAAI,CAAC,KAAK,gBAAgB,aAAa,SAAS,GAAG;AACjD,WAAK,eAAe;AAAA,IACrB;AAED,SAAK,KAAK,mBAAmB,OAAO,IAAI;AAExC,WAAO,aAAa,SAAS,OAAO,MAAM,OAAO,MAAM,cAAc,EAAE,KAAK,SAAO;AACjF,UAAI,QAAQ,MAAM;AAChB,eAAO;AAAA,MACR;AAED,YAAM,qBAAqB;AAAA,QACzB,GAAG,eAAe,sBAAuB;AAAA,QACzC,GAAI,QAAQ,MAAM,sBAAqB,IAAK;AAAA,MACpD;AAEM,YAAM,QAAQ,IAAI,YAAY,IAAI,SAAS;AAC3C,UAAI,CAAC,SAAS,oBAAoB;AAChC,cAAM,EAAE,SAAS,UAAU,QAAQ,cAAc,IAAK,IAAG;AACzD,YAAI,WAAW;AAAA,UACb,OAAO;AAAA,YACL;AAAA,YACA,SAAS;AAAA,YACT,gBAAgB;AAAA,UACjB;AAAA,UACD,GAAG,IAAI;AAAA,QACjB;AAEQ,cAAM,yBAAyB,MAAM,MAAM,oCAAoC,UAAU,MAAM,KAAK;AAEpG,YAAI,wBAAwB;AAAA,UAC1B;AAAA,UACA,GAAG,IAAI;AAAA,QACjB;AAAA,MACO;AACD,aAAO;AAAA,IACb,CAAK;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,cAAc,OAAO,OAAO,CAAA,GAAI,OAAO;AACtC,WAAO,KAAK,cAAc,OAAO,MAAM,KAAK,EAAE;AAAA,MAC5C,gBAAc;AACZ,eAAO,WAAW;AAAA,MACnB;AAAA,MACD,YAAU;AACR,YAAI,aAAa;AAGf,gBAAM,cAAc;AACpB,cAAI,YAAY,aAAa,OAAO;AAClC,mBAAO,IAAI,YAAY,OAAO;AAAA,UAC1C,OAAiB;AACL,mBAAO,KAAK,WAAW;AAAA,UACxB;AAAA,QACF;AACD,eAAO;AAAA,MACR;AAAA,IACP;AAAA,EACG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,cAAc,OAAO,MAAM,OAAO;AACjC,UAAM,UAAU,KAAK;AACrB,UAAM,EAAE,WAAY,IAAG;AAEvB,UAAM,gBAAgB,mBAAmB,KAAK;AAC9C,UAAM,UAAU,aAAa,KAAK;AAClC,UAAM,YAAY,MAAM,QAAQ;AAChC,UAAM,kBAAkB,0BAA0B;AAKlD,QAAI,WAAW,OAAO,eAAe,YAAY,KAAK,OAAQ,IAAG,YAAY;AAC3E,WAAK,mBAAmB,eAAe,SAAS,KAAK;AACrD,aAAO;AAAA,QACL,IAAI;AAAA,UACF,oFAAoF;AAAA,UACpF;AAAA,QACD;AAAA,MACT;AAAA,IACK;AAED,UAAM,eAAe,cAAc,iBAAiB,WAAW;AAE/D,UAAM,wBAAwB,MAAM,yBAAyB;AAC7D,UAAM,6BAA6B,sBAAsB;AAEzD,WAAO,KAAK,cAAc,OAAO,MAAM,OAAO,0BAA0B,EACrE,KAAK,cAAY;AAChB,UAAI,aAAa,MAAM;AACrB,aAAK,mBAAmB,mBAAmB,cAAc,KAAK;AAC9D,cAAM,IAAI,YAAY,4DAA4D,KAAK;AAAA,MACxF;AAED,YAAM,sBAAsB,KAAK,QAAS,KAAK,KAAO,eAAe;AACrE,UAAI,qBAAqB;AACvB,eAAO;AAAA,MACR;AAED,YAAM,SAAS,kBAAkB,SAAS,UAAU,IAAI;AACxD,aAAO,0BAA0B,QAAQ,eAAe;AAAA,IAChE,CAAO,EACA,KAAK,oBAAkB;AACtB,UAAI,mBAAmB,MAAM;AAC3B,aAAK,mBAAmB,eAAe,cAAc,KAAK;AAC1D,cAAM,IAAI,YAAY,GAAG,2DAA2D,KAAK;AAAA,MAC1F;AAED,YAAM,UAAU,SAAS,MAAM,WAAU;AACzC,UAAI,CAAC,iBAAiB,SAAS;AAC7B,aAAK,wBAAwB,SAAS,cAAc;AAAA,MACrD;AAKD,YAAM,kBAAkB,eAAe;AACvC,UAAI,iBAAiB,mBAAmB,eAAe,gBAAgB,MAAM,aAAa;AACxF,cAAM,SAAS;AACf,uBAAe,mBAAmB;AAAA,UAChC,GAAG;AAAA,UACH;AAAA,QACZ;AAAA,MACS;AAED,WAAK,UAAU,gBAAgB,IAAI;AACnC,aAAO;AAAA,IACf,CAAO,EACA,KAAK,MAAM,YAAU;AACpB,UAAI,kBAAkB,aAAa;AACjC,cAAM;AAAA,MACP;AAED,WAAK,iBAAiB,QAAQ;AAAA,QAC5B,MAAM;AAAA,UACJ,YAAY;AAAA,QACb;AAAA,QACD,mBAAmB;AAAA,MAC7B,CAAS;AACD,YAAM,IAAI;AAAA,QACR;AAAA,UAA8H;AAAA,MACxI;AAAA,IACA,CAAO;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,SAAS;AACjB,SAAK;AACL,SAAK,QAAQ;AAAA,MACX,WAAS;AACP,aAAK;AACL,eAAO;AAAA,MACR;AAAA,MACD,YAAU;AACR,aAAK;AACL,eAAO;AAAA,MACR;AAAA,IACP;AAAA,EACG;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc,UAAU;AACvB,SAAK,KAAK,kBAAkB,QAAQ;AAEpC,QAAI,KAAK,gBAAgB,KAAK,YAAY;AACxC,aAAO,KAAK,WAAW,KAAK,QAAQ,EAAE,KAAK,MAAM,YAAU;AACzD,uBAAe,OAAO,MAAM,8BAA8B,MAAM;AAAA,MACxE,CAAO;AAAA,IACP,OAAW;AACL,qBAAe,OAAO,MAAM,oBAAoB;AAAA,IACjD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB;AAChB,UAAM,WAAW,KAAK;AACtB,SAAK,YAAY;AACjB,WAAO,OAAO,KAAK,QAAQ,EAAE,IAAI,SAAO;AACtC,YAAM,CAAC,QAAQ,QAAQ,IAAI,IAAI,MAAM,GAAG;AACxC,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,UAAU,SAAS,GAAG;AAAA,MAC9B;AAAA,IACA,CAAK;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAOH;AAKA,SAAS,0BACP,kBACA,iBACA;AACA,QAAM,oBAAoB,GAAG;AAC7B,MAAI,WAAW,gBAAgB,GAAG;AAChC,WAAO,iBAAiB;AAAA,MACtB,WAAS;AACP,YAAI,CAAC,cAAc,KAAK,KAAK,UAAU,MAAM;AAC3C,gBAAM,IAAI,YAAY,iBAAiB;AAAA,QACxC;AACD,eAAO;AAAA,MACR;AAAA,MACD,OAAK;AACH,cAAM,IAAI,YAAY,GAAG,iCAAiC,GAAG;AAAA,MAC9D;AAAA,IACP;AAAA,EACG,WAAU,CAAC,cAAc,gBAAgB,KAAK,qBAAqB,MAAM;AACxE,UAAM,IAAI,YAAY,iBAAiB;AAAA,EACxC;AACD,SAAO;AACT;AAKA,SAAS,kBACP,SACA,OACA,MACA;AACA,QAAM,EAAE,YAAY,sBAAuB,IAAG;AAE9C,MAAI,aAAa,KAAK,KAAK,YAAY;AACrC,WAAO,WAAW,OAAO,IAAI;AAAA,EAC9B;AAED,MAAI,mBAAmB,KAAK,KAAK,uBAAuB;AACtD,WAAO,sBAAsB,OAAO,IAAI;AAAA,EACzC;AAED,SAAO;AACT;AAEA,SAAS,aAAa,OAAO;AAC3B,SAAO,MAAM,SAAS;AACxB;AAEA,SAAS,mBAAmB,OAAO;AACjC,SAAO,MAAM,SAAS;AACxB;","x_google_ignoreList":[0]}