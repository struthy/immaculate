{"version":3,"file":"integration.js","sources":["../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/core/esm/integration.js"],"sourcesContent":["import { arrayify, logger } from '@sentry/utils';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { addGlobalEventProcessor } from './eventProcessors.js';\nimport { getClient } from './exports.js';\nimport { getCurrentHub } from './hub.js';\n\nconst installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  const integrationsByName = {};\n\n  integrations.forEach(currentInstance => {\n    const { name } = currentInstance;\n\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.keys(integrationsByName).map(k => integrationsByName[k]);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations;\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  const finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or\n  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event\n  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore\n  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.\n  const debugIndex = findIndex(finalIntegrations, integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(client, integrations) {\n  const integrationIndex = {};\n\n  integrations.forEach(integration => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(client, integration, integrationIndex);\n    }\n  });\n\n  return integrationIndex;\n}\n\n/**\n * Execute the `afterAllSetup` hooks of the given integrations.\n */\nfunction afterSetupIntegrations(client, integrations) {\n  for (const integration of integrations) {\n    // guard against empty provided integrations\n    if (integration && integration.afterAllSetup) {\n      integration.afterAllSetup(client);\n    }\n  }\n}\n\n/** Setup a single integration.  */\nfunction setupIntegration(client, integration, integrationIndex) {\n  if (integrationIndex[integration.name]) {\n    DEBUG_BUILD && logger.log(`Integration skipped because it was already installed: ${integration.name}`);\n    return;\n  }\n  integrationIndex[integration.name] = integration;\n\n  // `setupOnce` is only called the first time\n  if (installedIntegrations.indexOf(integration.name) === -1) {\n    // eslint-disable-next-line deprecation/deprecation\n    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n    installedIntegrations.push(integration.name);\n  }\n\n  // `setup` is run for each client\n  if (integration.setup && typeof integration.setup === 'function') {\n    integration.setup(client);\n  }\n\n  if (client.on && typeof integration.preprocessEvent === 'function') {\n    const callback = integration.preprocessEvent.bind(integration) ;\n    client.on('preprocessEvent', (event, hint) => callback(event, hint, client));\n  }\n\n  if (client.addEventProcessor && typeof integration.processEvent === 'function') {\n    const callback = integration.processEvent.bind(integration) ;\n\n    const processor = Object.assign((event, hint) => callback(event, hint, client), {\n      id: integration.name,\n    });\n\n    client.addEventProcessor(processor);\n  }\n\n  DEBUG_BUILD && logger.log(`Integration installed: ${integration.name}`);\n}\n\n/** Add an integration to the current hub's client. */\nfunction addIntegration(integration) {\n  const client = getClient();\n\n  if (!client || !client.addIntegration) {\n    DEBUG_BUILD && logger.warn(`Cannot add integration \"${integration.name}\" because no SDK Client is available.`);\n    return;\n  }\n\n  client.addIntegration(integration);\n}\n\n// Polyfill for Array.findIndex(), which is not supported in ES5\nfunction findIndex(arr, callback) {\n  for (let i = 0; i < arr.length; i++) {\n    if (callback(arr[i]) === true) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Convert a new integration function to the legacy class syntax.\n * In v8, we can remove this and instead export the integration functions directly.\n *\n * @deprecated This will be removed in v8!\n */\nfunction convertIntegrationFnToClass(\n  name,\n  fn,\n) {\n  return Object.assign(\n    function ConvertedIntegration(...args) {\n      return fn(...args);\n    },\n    { id: name },\n  ) ;\n}\n\n/**\n * Define an integration function that can be used to create an integration instance.\n * Note that this by design hides the implementation details of the integration, as they are considered internal.\n */\nfunction defineIntegration(fn) {\n  return fn;\n}\n\nexport { addIntegration, afterSetupIntegrations, convertIntegrationFnToClass, defineIntegration, getIntegrationsToSetup, installedIntegrations, setupIntegration, setupIntegrations };\n//# sourceMappingURL=integration.js.map\n"],"names":[],"mappings":";;;;;AAMK,MAAC,wBAAwB,CAAG;AAUjC,SAAS,iBAAiB,cAAc;AACtC,QAAM,qBAAqB,CAAA;AAE3B,eAAa,QAAQ,qBAAmB;AACtC,UAAM,EAAE,KAAM,IAAG;AAEjB,UAAM,mBAAmB,mBAAmB,IAAI;AAIhD,QAAI,oBAAoB,CAAC,iBAAiB,qBAAqB,gBAAgB,mBAAmB;AAChG;AAAA,IACD;AAED,uBAAmB,IAAI,IAAI;AAAA,EAC/B,CAAG;AAED,SAAO,OAAO,KAAK,kBAAkB,EAAE,IAAI,OAAK,mBAAmB,CAAC,CAAC;AACvE;AAGA,SAAS,uBAAuB,SAAS;AACvC,QAAM,sBAAsB,QAAQ,uBAAuB;AAC3D,QAAM,mBAAmB,QAAQ;AAGjC,sBAAoB,QAAQ,iBAAe;AACzC,gBAAY,oBAAoB;AAAA,EACpC,CAAG;AAED,MAAI;AAEJ,MAAI,MAAM,QAAQ,gBAAgB,GAAG;AACnC,mBAAe,CAAC,GAAG,qBAAqB,GAAG,gBAAgB;AAAA,EAC/D,WAAa,OAAO,qBAAqB,YAAY;AACjD,mBAAe,SAAS,iBAAiB,mBAAmB,CAAC;AAAA,EACjE,OAAS;AACL,mBAAe;AAAA,EAChB;AAED,QAAM,oBAAoB,iBAAiB,YAAY;AAMvD,QAAM,aAAa,UAAU,mBAAmB,iBAAe,YAAY,SAAS,OAAO;AAC3F,MAAI,eAAe,IAAI;AACrB,UAAM,CAAC,aAAa,IAAI,kBAAkB,OAAO,YAAY,CAAC;AAC9D,sBAAkB,KAAK,aAAa;AAAA,EACrC;AAED,SAAO;AACT;AAQA,SAAS,kBAAkB,QAAQ,cAAc;AAC/C,QAAM,mBAAmB,CAAA;AAEzB,eAAa,QAAQ,iBAAe;AAElC,QAAI,aAAa;AACf,uBAAiB,QAAQ,aAAa,gBAAgB;AAAA,IACvD;AAAA,EACL,CAAG;AAED,SAAO;AACT;AAKA,SAAS,uBAAuB,QAAQ,cAAc;AACpD,aAAW,eAAe,cAAc;AAEtC,QAAI,eAAe,YAAY,eAAe;AAC5C,kBAAY,cAAc,MAAM;AAAA,IACjC;AAAA,EACF;AACH;AAGA,SAAS,iBAAiB,QAAQ,aAAa,kBAAkB;AAC/D,MAAI,iBAAiB,YAAY,IAAI,GAAG;AACtC,mBAAe,OAAO,IAAI,yDAAyD,YAAY,MAAM;AACrG;AAAA,EACD;AACD,mBAAiB,YAAY,IAAI,IAAI;AAGrC,MAAI,sBAAsB,QAAQ,YAAY,IAAI,MAAM,IAAI;AAE1D,gBAAY,UAAU,yBAAyB,aAAa;AAC5D,0BAAsB,KAAK,YAAY,IAAI;AAAA,EAC5C;AAGD,MAAI,YAAY,SAAS,OAAO,YAAY,UAAU,YAAY;AAChE,gBAAY,MAAM,MAAM;AAAA,EACzB;AAED,MAAI,OAAO,MAAM,OAAO,YAAY,oBAAoB,YAAY;AAClE,UAAM,WAAW,YAAY,gBAAgB,KAAK,WAAW;AAC7D,WAAO,GAAG,mBAAmB,CAAC,OAAO,SAAS,SAAS,OAAO,MAAM,MAAM,CAAC;AAAA,EAC5E;AAED,MAAI,OAAO,qBAAqB,OAAO,YAAY,iBAAiB,YAAY;AAC9E,UAAM,WAAW,YAAY,aAAa,KAAK,WAAW;AAE1D,UAAM,YAAY,OAAO,OAAO,CAAC,OAAO,SAAS,SAAS,OAAO,MAAM,MAAM,GAAG;AAAA,MAC9E,IAAI,YAAY;AAAA,IACtB,CAAK;AAED,WAAO,kBAAkB,SAAS;AAAA,EACnC;AAED,iBAAe,OAAO,IAAI,0BAA0B,YAAY,MAAM;AACxE;AAeA,SAAS,UAAU,KAAK,UAAU;AAChC,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,QAAI,SAAS,IAAI,CAAC,CAAC,MAAM,MAAM;AAC7B,aAAO;AAAA,IACR;AAAA,EACF;AAED,SAAO;AACT;AAQA,SAAS,4BACP,MACA,IACA;AACA,SAAO,OAAO;AAAA,IACZ,SAAS,wBAAwB,MAAM;AACrC,aAAO,GAAG,GAAG,IAAI;AAAA,IAClB;AAAA,IACD,EAAE,IAAI,KAAM;AAAA,EAChB;AACA;AAMA,SAAS,kBAAkB,IAAI;AAC7B,SAAO;AACT;","x_google_ignoreList":[0]}