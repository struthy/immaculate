{"version":3,"file":"aggregator.cjs","sources":["../../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/core/esm/metrics/aggregator.js"],"sourcesContent":["import { timestampInSeconds } from '@sentry/utils';\nimport { DEFAULT_FLUSH_INTERVAL, SET_METRIC_TYPE, MAX_WEIGHT } from './constants.js';\nimport { METRIC_MAP } from './instance.js';\nimport { updateMetricSummaryOnActiveSpan } from './metric-summary.js';\nimport { sanitizeMetricKey, sanitizeTags, sanitizeUnit, getBucketKey } from './utils.js';\n\n/**\n * A metrics aggregator that aggregates metrics in memory and flushes them periodically.\n */\nclass MetricsAggregator  {\n  // TODO(@anonrig): Use FinalizationRegistry to have a proper way of flushing the buckets\n  // when the aggregator is garbage collected.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n\n  // Different metrics have different weights. We use this to limit the number of metrics\n  // that we store in memory.\n\n  // Cast to any so that it can use Node.js timeout\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  // SDKs are required to shift the flush interval by random() * rollup_in_seconds.\n  // That shift is determined once per startup to create jittering.\n\n  // An SDK is required to perform force flushing ahead of scheduled time if the memory\n  // pressure is too high. There is no rule for this other than that SDKs should be tracking\n  // abstract aggregation complexity (eg: a counter only carries a single float, whereas a\n  // distribution is a float per emission).\n  //\n  // Force flush is used on either shutdown, flush() or when we exceed the max weight.\n\n   constructor(  _client) {this._client = _client;\n    this._buckets = new Map();\n    this._bucketsTotalWeight = 0;\n\n    this._interval = setInterval(() => this._flush(), DEFAULT_FLUSH_INTERVAL) ;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (this._interval.unref) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      this._interval.unref();\n    }\n\n    this._flushShift = Math.floor((Math.random() * DEFAULT_FLUSH_INTERVAL) / 1000);\n    this._forceFlush = false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   add(\n    metricType,\n    unsanitizedName,\n    value,\n    unsanitizedUnit = 'none',\n    unsanitizedTags = {},\n    maybeFloatTimestamp = timestampInSeconds(),\n  ) {\n    const timestamp = Math.floor(maybeFloatTimestamp);\n    const name = sanitizeMetricKey(unsanitizedName);\n    const tags = sanitizeTags(unsanitizedTags);\n    const unit = sanitizeUnit(unsanitizedUnit );\n\n    const bucketKey = getBucketKey(metricType, name, unit, tags);\n\n    let bucketItem = this._buckets.get(bucketKey);\n    // If this is a set metric, we need to calculate the delta from the previous weight.\n    const previousWeight = bucketItem && metricType === SET_METRIC_TYPE ? bucketItem.metric.weight : 0;\n\n    if (bucketItem) {\n      bucketItem.metric.add(value);\n      // TODO(abhi): Do we need this check?\n      if (bucketItem.timestamp < timestamp) {\n        bucketItem.timestamp = timestamp;\n      }\n    } else {\n      bucketItem = {\n        // @ts-expect-error we don't need to narrow down the type of value here, saves bundle size.\n        metric: new METRIC_MAP[metricType](value),\n        timestamp,\n        metricType,\n        name,\n        unit,\n        tags,\n      };\n      this._buckets.set(bucketKey, bucketItem);\n    }\n\n    // If value is a string, it's a set metric so calculate the delta from the previous weight.\n    const val = typeof value === 'string' ? bucketItem.metric.weight - previousWeight : value;\n    updateMetricSummaryOnActiveSpan(metricType, name, val, unit, unsanitizedTags, bucketKey);\n\n    // We need to keep track of the total weight of the buckets so that we can\n    // flush them when we exceed the max weight.\n    this._bucketsTotalWeight += bucketItem.metric.weight;\n\n    if (this._bucketsTotalWeight >= MAX_WEIGHT) {\n      this.flush();\n    }\n  }\n\n  /**\n   * Flushes the current metrics to the transport via the transport.\n   */\n   flush() {\n    this._forceFlush = true;\n    this._flush();\n  }\n\n  /**\n   * Shuts down metrics aggregator and clears all metrics.\n   */\n   close() {\n    this._forceFlush = true;\n    clearInterval(this._interval);\n    this._flush();\n  }\n\n  /**\n   * Flushes the buckets according to the internal state of the aggregator.\n   * If it is a force flush, which happens on shutdown, it will flush all buckets.\n   * Otherwise, it will only flush buckets that are older than the flush interval,\n   * and according to the flush shift.\n   *\n   * This function mutates `_forceFlush` and `_bucketsTotalWeight` properties.\n   */\n   _flush() {\n    // TODO(@anonrig): Add Atomics for locking to avoid having force flush and regular flush\n    // running at the same time.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics\n\n    // This path eliminates the need for checking for timestamps since we're forcing a flush.\n    // Remember to reset the flag, or it will always flush all metrics.\n    if (this._forceFlush) {\n      this._forceFlush = false;\n      this._bucketsTotalWeight = 0;\n      this._captureMetrics(this._buckets);\n      this._buckets.clear();\n      return;\n    }\n    const cutoffSeconds = Math.floor(timestampInSeconds()) - DEFAULT_FLUSH_INTERVAL / 1000 - this._flushShift;\n    // TODO(@anonrig): Optimization opportunity.\n    // Convert this map to an array and store key in the bucketItem.\n    const flushedBuckets = new Map();\n    for (const [key, bucket] of this._buckets) {\n      if (bucket.timestamp <= cutoffSeconds) {\n        flushedBuckets.set(key, bucket);\n        this._bucketsTotalWeight -= bucket.metric.weight;\n      }\n    }\n\n    for (const [key] of flushedBuckets) {\n      this._buckets.delete(key);\n    }\n\n    this._captureMetrics(flushedBuckets);\n  }\n\n  /**\n   * Only captures a subset of the buckets passed to this function.\n   * @param flushedBuckets\n   */\n   _captureMetrics(flushedBuckets) {\n    if (flushedBuckets.size > 0 && this._client.captureAggregateMetrics) {\n      // TODO(@anonrig): Optimization opportunity.\n      // This copy operation can be avoided if we store the key in the bucketItem.\n      const buckets = Array.from(flushedBuckets).map(([, bucketItem]) => bucketItem);\n      this._client.captureAggregateMetrics(buckets);\n    }\n  }\n}\n\nexport { MetricsAggregator };\n//# sourceMappingURL=aggregator.js.map\n"],"names":["DEFAULT_FLUSH_INTERVAL","timestampInSeconds","sanitizeMetricKey","sanitizeTags","sanitizeUnit","getBucketKey","SET_METRIC_TYPE","METRIC_MAP","updateMetricSummaryOnActiveSpan","MAX_WEIGHT"],"mappings":"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","x_google_ignoreList":[0]}