{"version":3,"file":"prepareEvent.cjs","sources":["../../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/core/esm/utils/prepareEvent.js"],"sourcesContent":["import { uuid4, dateTimestampInSeconds, addExceptionMechanism, truncate, GLOBAL_OBJ, normalize } from '@sentry/utils';\nimport { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getGlobalEventProcessors, notifyEventProcessors } from '../eventProcessors.js';\nimport { getGlobalScope, Scope } from '../scope.js';\nimport { mergeScopeData, applyScopeDataToEvent } from './applyScopeDataToEvent.js';\nimport { spanToJSON } from './spanUtils.js';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * Note: This also triggers callbacks for `addGlobalEventProcessor`, but not `beforeSend`.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(\n  options,\n  event,\n  hint,\n  scope,\n  client,\n  isolationScope,\n) {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n\n  const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Hub.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getGlobalScope().getScopeData();\n\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    mergeScopeData(data, isolationData);\n  }\n\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    mergeScopeData(data, finalScopeData);\n  }\n\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n\n  applyScopeDataToEvent(prepared, data);\n\n  // TODO (v8): Update this order to be: Global > Client > Scope\n  const eventProcessors = [\n    ...clientEventProcessors,\n    // eslint-disable-next-line deprecation/deprecation\n    ...getGlobalEventProcessors(),\n    // Run scope event processors _after_ all other processors\n    ...data.eventProcessors,\n  ];\n\n  const result = notifyEventProcessors(eventProcessors, prepared, hint);\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  if (!('environment' in event)) {\n    event.environment = 'environment' in options ? environment : DEFAULT_ENVIRONMENT;\n  }\n\n  if (event.release === undefined && release !== undefined) {\n    event.release = release;\n  }\n\n  if (event.dist === undefined && dist !== undefined) {\n    event.dist = dist;\n  }\n\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n\n  const exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n\n  const request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\nconst debugIdStackParserCache = new WeakMap();\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n\n  if (!debugIdMap) {\n    return;\n  }\n\n  let debugIdStackFramesCache;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {\n    let parsedStack;\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      if (stackFrame.filename) {\n        acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (frame.filename) {\n          frame.debug_id = filenameDebugIdMap[frame.filename];\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap = {};\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (frame.debug_id) {\n          if (frame.abs_path) {\n            filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n          } else if (frame.filename) {\n            filenameDebugIdMap[frame.filename] = frame.debug_id;\n          }\n          delete frame.debug_id;\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.keys(filenameDebugIdMap).forEach(filename => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id: filenameDebugIdMap[filename],\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      const data = spanToJSON(span).data;\n\n      if (data) {\n        // This is a bit weird, as we generally have `Span` instances here, but to be safe we do not assume so\n        // eslint-disable-next-line deprecation/deprecation\n        span.data = normalize(data, depth, maxBreadth);\n      }\n\n      return span;\n    });\n  }\n\n  return normalized;\n}\n\nfunction getFinalScope(scope, captureContext) {\n  if (!captureContext) {\n    return scope;\n  }\n\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nfunction parseEventHintOrCaptureContext(\n  hint,\n) {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return { captureContext: hint };\n  }\n\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint,\n    };\n  }\n\n  return hint;\n}\n\nfunction hintIsScopeOrFunction(\n  hint,\n) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\n\nconst captureContextKeys = [\n  'user',\n  'level',\n  'extra',\n  'contexts',\n  'tags',\n  'fingerprint',\n  'requestSession',\n  'propagationContext',\n] ;\n\nfunction hintIsScopeContext(hint) {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key ));\n}\n\nexport { applyDebugIds, applyDebugMeta, parseEventHintOrCaptureContext, prepareEvent };\n//# sourceMappingURL=prepareEvent.js.map\n"],"names":["scope","uuid4","dateTimestampInSeconds","addExceptionMechanism","getGlobalScope","mergeScopeData","applyScopeDataToEvent","eventProcessors","getGlobalEventProcessors","notifyEventProcessors","DEFAULT_ENVIRONMENT","truncate","GLOBAL_OBJ","normalize","spanToJSON","Scope"],"mappings":"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","x_google_ignoreList":[0]}