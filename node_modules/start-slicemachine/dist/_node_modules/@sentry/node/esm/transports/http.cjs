"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const http = require("http");
const https = require("https");
const stream = require("stream");
const url = require("url");
const zlib = require("zlib");
const index = require("../proxy/index.cjs");
const logger = require('./../../_node_modules/@sentry/utils/esm/logger.cjs');
const base = require('./../../_node_modules/@sentry/core/esm/transports/base.cjs');
const _nullishCoalesce = require('./../../_node_modules/@sentry/utils/esm/buildPolyfills/_nullishCoalesce.cjs');
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const http__namespace = /* @__PURE__ */ _interopNamespaceDefault(http);
const https__namespace = /* @__PURE__ */ _interopNamespaceDefault(https);
const GZIP_THRESHOLD = 1024 * 32;
function streamFromBody(body) {
  return new stream.Readable({
    read() {
      this.push(body);
      this.push(null);
    }
  });
}
function makeNodeTransport(options) {
  let urlSegments;
  try {
    urlSegments = new url.URL(options.url);
  } catch (e) {
    logger.consoleSandbox(() => {
      console.warn(
        "[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used."
      );
    });
    return base.createTransport(options, () => Promise.resolve({}));
  }
  const isHttps = urlSegments.protocol === "https:";
  const proxy = applyNoProxyOption(
    urlSegments,
    options.proxy || (isHttps ? process.env.https_proxy : void 0) || process.env.http_proxy
  );
  const nativeHttpModule = isHttps ? https__namespace : http__namespace;
  const keepAlive = options.keepAlive === void 0 ? false : options.keepAlive;
  const agent = proxy ? new index.HttpsProxyAgent(proxy) : new nativeHttpModule.Agent({ keepAlive, maxSockets: 30, timeout: 2e3 });
  const requestExecutor = createRequestExecutor(options, _nullishCoalesce._nullishCoalesce(options.httpModule, () => nativeHttpModule), agent);
  return base.createTransport(options, requestExecutor);
}
function applyNoProxyOption(transportUrlSegments, proxy) {
  const { no_proxy } = process.env;
  const urlIsExemptFromProxy = no_proxy && no_proxy.split(",").some(
    (exemption) => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption)
  );
  if (urlIsExemptFromProxy) {
    return void 0;
  } else {
    return proxy;
  }
}
function createRequestExecutor(options, httpModule, agent) {
  const { hostname, pathname, port, protocol, search } = new url.URL(options.url);
  return function makeRequest(request) {
    return new Promise((resolve, reject) => {
      let body = streamFromBody(request.body);
      const headers = { ...options.headers };
      if (request.body.length > GZIP_THRESHOLD) {
        headers["content-encoding"] = "gzip";
        body = body.pipe(zlib.createGzip());
      }
      const req = httpModule.request(
        {
          method: "POST",
          agent,
          headers,
          hostname,
          path: `${pathname}${search}`,
          port,
          protocol,
          ca: options.caCerts
        },
        (res) => {
          res.on("data", () => {
          });
          res.on("end", () => {
          });
          res.setEncoding("utf8");
          const retryAfterHeader = _nullishCoalesce._nullishCoalesce(res.headers["retry-after"], () => null);
          const rateLimitsHeader = _nullishCoalesce._nullishCoalesce(res.headers["x-sentry-rate-limits"], () => null);
          resolve({
            statusCode: res.statusCode,
            headers: {
              "retry-after": retryAfterHeader,
              "x-sentry-rate-limits": Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader
            }
          });
        }
      );
      req.on("error", reject);
      body.pipe(req);
    });
  };
}
exports.makeNodeTransport = makeNodeTransport;
//# sourceMappingURL=http.cjs.map
