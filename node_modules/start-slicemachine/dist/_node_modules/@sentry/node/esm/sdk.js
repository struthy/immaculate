import { setNodeAsyncContextStrategy } from "./async/index.js";
import { NodeClient } from "./client.js";
import { consoleIntegration } from "./integrations/console.js";
import { nodeContextIntegration } from "./integrations/context.js";
import { contextLinesIntegration } from "./integrations/contextlines.js";
import { httpIntegration } from "./integrations/http.js";
import { localVariablesIntegration } from "./integrations/local-variables/index.js";
import { modulesIntegration } from "./integrations/modules.js";
import { onUncaughtExceptionIntegration } from "./integrations/onuncaughtexception.js";
import { onUnhandledRejectionIntegration } from "./integrations/onunhandledrejection.js";
import { spotlightIntegration } from "./integrations/spotlight.js";
import { nativeNodeFetchintegration } from "./integrations/undici/index.js";
import { createGetModuleFromFilename } from "./module.js";
import { makeNodeTransport } from "./transports/http.js";
import { inboundFiltersIntegration } from './../_node_modules/@sentry/core/esm/integrations/inboundfilters.js';
import { functionToStringIntegration } from './../_node_modules/@sentry/core/esm/integrations/functiontostring.js';
import { linkedErrorsIntegration } from './../_node_modules/@sentry/core/esm/integrations/linkederrors.js';
import { requestDataIntegration } from './../_node_modules/@sentry/core/esm/integrations/requestdata.js';
import { stackParserFromStackParserOptions, createStackParser, nodeStackLineParser } from './../_node_modules/@sentry/utils/esm/stacktrace.js';
import { getIntegrationsToSetup } from './../_node_modules/@sentry/core/esm/integration.js';
import { initAndBind } from './../_node_modules/@sentry/core/esm/sdk.js';
import { getClient, startSession, endSession, getCurrentScope } from './../_node_modules/@sentry/core/esm/exports.js';
import { GLOBAL_OBJ } from './../_node_modules/@sentry/utils/esm/worldwide.js';
import { getIsolationScope, getMainCarrier } from './../_node_modules/@sentry/core/esm/hub.js';
import { propagationContextFromHeaders } from './../_node_modules/@sentry/utils/esm/tracing.js';
import { _optionalChain } from './../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js';
const defaultIntegrations = [
  // Common
  inboundFiltersIntegration(),
  functionToStringIntegration(),
  linkedErrorsIntegration(),
  requestDataIntegration(),
  // Native Wrappers
  consoleIntegration(),
  httpIntegration(),
  nativeNodeFetchintegration(),
  // Global Handlers
  onUncaughtExceptionIntegration(),
  onUnhandledRejectionIntegration(),
  // Event Info
  contextLinesIntegration(),
  localVariablesIntegration(),
  nodeContextIntegration(),
  modulesIntegration()
];
function getDefaultIntegrations(_options) {
  const carrier = getMainCarrier();
  const autoloadedIntegrations = _optionalChain([carrier, "access", (_) => _.__SENTRY__, "optionalAccess", (_2) => _2.integrations]) || [];
  return [
    // eslint-disable-next-line deprecation/deprecation
    ...defaultIntegrations,
    ...autoloadedIntegrations
  ];
}
function init(options = {}) {
  setNodeAsyncContextStrategy();
  if (options.defaultIntegrations === void 0) {
    options.defaultIntegrations = getDefaultIntegrations();
  }
  if (options.dsn === void 0 && process.env.SENTRY_DSN) {
    options.dsn = process.env.SENTRY_DSN;
  }
  const sentryTracesSampleRate = process.env.SENTRY_TRACES_SAMPLE_RATE;
  if (options.tracesSampleRate === void 0 && sentryTracesSampleRate) {
    const tracesSampleRate = parseFloat(sentryTracesSampleRate);
    if (isFinite(tracesSampleRate)) {
      options.tracesSampleRate = tracesSampleRate;
    }
  }
  if (options.release === void 0) {
    const detectedRelease = getSentryRelease();
    if (detectedRelease !== void 0) {
      options.release = detectedRelease;
    } else {
      options.autoSessionTracking = false;
    }
  }
  if (options.environment === void 0 && process.env.SENTRY_ENVIRONMENT) {
    options.environment = process.env.SENTRY_ENVIRONMENT;
  }
  if (options.autoSessionTracking === void 0 && options.dsn !== void 0) {
    options.autoSessionTracking = true;
  }
  if (options.instrumenter === void 0) {
    options.instrumenter = "sentry";
  }
  const clientOptions = {
    ...options,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup(options),
    transport: options.transport || makeNodeTransport
  };
  initAndBind(options.clientClass || NodeClient, clientOptions);
  if (options.autoSessionTracking) {
    startSessionTracking();
  }
  updateScopeFromEnvVariables();
  if (options.spotlight) {
    const client = getClient();
    if (client && client.addIntegration) {
      const integrations = client.getOptions().integrations;
      for (const integration of integrations) {
        client.addIntegration(integration);
      }
      client.addIntegration(
        spotlightIntegration({ sidecarUrl: typeof options.spotlight === "string" ? options.spotlight : void 0 })
      );
    }
  }
}
function getSentryRelease(fallback) {
  if (process.env.SENTRY_RELEASE) {
    return process.env.SENTRY_RELEASE;
  }
  if (GLOBAL_OBJ.SENTRY_RELEASE && GLOBAL_OBJ.SENTRY_RELEASE.id) {
    return GLOBAL_OBJ.SENTRY_RELEASE.id;
  }
  return (
    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables
    process.env.GITHUB_SHA || // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata
    process.env.COMMIT_REF || // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables
    process.env.VERCEL_GIT_COMMIT_SHA || process.env.VERCEL_GITHUB_COMMIT_SHA || process.env.VERCEL_GITLAB_COMMIT_SHA || process.env.VERCEL_BITBUCKET_COMMIT_SHA || // Zeit (now known as Vercel)
    process.env.ZEIT_GITHUB_COMMIT_SHA || process.env.ZEIT_GITLAB_COMMIT_SHA || process.env.ZEIT_BITBUCKET_COMMIT_SHA || // Cloudflare Pages - https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables
    process.env.CF_PAGES_COMMIT_SHA || fallback
  );
}
const defaultStackParser = createStackParser(nodeStackLineParser(createGetModuleFromFilename()));
function startSessionTracking() {
  startSession();
  process.on("beforeExit", () => {
    const session = getIsolationScope().getSession();
    const terminalStates = ["exited", "crashed"];
    if (session && !terminalStates.includes(session.status)) {
      endSession();
    }
  });
}
function updateScopeFromEnvVariables() {
  const sentryUseEnvironment = (process.env.SENTRY_USE_ENVIRONMENT || "").toLowerCase();
  if (!["false", "n", "no", "off", "0"].includes(sentryUseEnvironment)) {
    const sentryTraceEnv = process.env.SENTRY_TRACE;
    const baggageEnv = process.env.SENTRY_BAGGAGE;
    const propagationContext = propagationContextFromHeaders(sentryTraceEnv, baggageEnv);
    getCurrentScope().setPropagationContext(propagationContext);
  }
}
export {
  defaultIntegrations,
  defaultStackParser,
  getDefaultIntegrations,
  getSentryRelease,
  init
};
//# sourceMappingURL=sdk.js.map
