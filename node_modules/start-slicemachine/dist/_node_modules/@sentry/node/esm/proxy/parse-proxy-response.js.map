{"version":3,"file":"parse-proxy-response.js","sources":["../../../../../../../../node_modules/@sentry/node/esm/proxy/parse-proxy-response.js"],"sourcesContent":["import { logger } from '@sentry/utils';\n\nfunction debug(...args) {\n  logger.log('[https-proxy-agent:parse-proxy-response]', ...args);\n}\n\nfunction parseProxyResponse(socket) {\n  return new Promise((resolve, reject) => {\n    // we need to buffer any HTTP traffic that happens with the proxy before we get\n    // the CONNECT response, so that if the response is anything other than an \"200\"\n    // response code, then we can re-play the \"data\" events on the socket once the\n    // HTTP parser is hooked up...\n    let buffersLength = 0;\n    const buffers = [];\n\n    function read() {\n      const b = socket.read();\n      if (b) ondata(b);\n      else socket.once('readable', read);\n    }\n\n    function cleanup() {\n      socket.removeListener('end', onend);\n      socket.removeListener('error', onerror);\n      socket.removeListener('readable', read);\n    }\n\n    function onend() {\n      cleanup();\n      debug('onend');\n      reject(new Error('Proxy connection ended before receiving CONNECT response'));\n    }\n\n    function onerror(err) {\n      cleanup();\n      debug('onerror %o', err);\n      reject(err);\n    }\n\n    function ondata(b) {\n      buffers.push(b);\n      buffersLength += b.length;\n\n      const buffered = Buffer.concat(buffers, buffersLength);\n      const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n\n      if (endOfHeaders === -1) {\n        // keep buffering\n        debug('have not received end of HTTP headers yet...');\n        read();\n        return;\n      }\n\n      const headerParts = buffered.slice(0, endOfHeaders).toString('ascii').split('\\r\\n');\n      const firstLine = headerParts.shift();\n      if (!firstLine) {\n        socket.destroy();\n        return reject(new Error('No header received from proxy CONNECT response'));\n      }\n      const firstLineParts = firstLine.split(' ');\n      const statusCode = +firstLineParts[1];\n      const statusText = firstLineParts.slice(2).join(' ');\n      const headers = {};\n      for (const header of headerParts) {\n        if (!header) continue;\n        const firstColon = header.indexOf(':');\n        if (firstColon === -1) {\n          socket.destroy();\n          return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\n        }\n        const key = header.slice(0, firstColon).toLowerCase();\n        const value = header.slice(firstColon + 1).trimStart();\n        const current = headers[key];\n        if (typeof current === 'string') {\n          headers[key] = [current, value];\n        } else if (Array.isArray(current)) {\n          current.push(value);\n        } else {\n          headers[key] = value;\n        }\n      }\n      debug('got proxy server response: %o %o', firstLine, headers);\n      cleanup();\n      resolve({\n        connect: {\n          statusCode,\n          statusText,\n          headers,\n        },\n        buffered,\n      });\n    }\n\n    socket.on('error', onerror);\n    socket.on('end', onend);\n\n    read();\n  });\n}\n\nexport { parseProxyResponse };\n//# sourceMappingURL=parse-proxy-response.js.map\n"],"names":[],"mappings":";AAEA,SAAS,SAAS,MAAM;AACtB,SAAO,IAAI,4CAA4C,GAAG,IAAI;AAChE;AAEA,SAAS,mBAAmB,QAAQ;AAClC,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AAKtC,QAAI,gBAAgB;AACpB,UAAM,UAAU,CAAA;AAEhB,aAAS,OAAO;AACd,YAAM,IAAI,OAAO;AACjB,UAAI;AAAG,eAAO,CAAC;AAAA;AACV,eAAO,KAAK,YAAY,IAAI;AAAA,IAClC;AAED,aAAS,UAAU;AACjB,aAAO,eAAe,OAAO,KAAK;AAClC,aAAO,eAAe,SAAS,OAAO;AACtC,aAAO,eAAe,YAAY,IAAI;AAAA,IACvC;AAED,aAAS,QAAQ;AACf;AACA,YAAM,OAAO;AACb,aAAO,IAAI,MAAM,0DAA0D,CAAC;AAAA,IAC7E;AAED,aAAS,QAAQ,KAAK;AACpB;AACA,YAAM,cAAc,GAAG;AACvB,aAAO,GAAG;AAAA,IACX;AAED,aAAS,OAAO,GAAG;AACjB,cAAQ,KAAK,CAAC;AACd,uBAAiB,EAAE;AAEnB,YAAM,WAAW,OAAO,OAAO,SAAS,aAAa;AACrD,YAAM,eAAe,SAAS,QAAQ,UAAU;AAEhD,UAAI,iBAAiB,IAAI;AAEvB,cAAM,8CAA8C;AACpD;AACA;AAAA,MACD;AAED,YAAM,cAAc,SAAS,MAAM,GAAG,YAAY,EAAE,SAAS,OAAO,EAAE,MAAM,MAAM;AAClF,YAAM,YAAY,YAAY;AAC9B,UAAI,CAAC,WAAW;AACd,eAAO,QAAO;AACd,eAAO,OAAO,IAAI,MAAM,gDAAgD,CAAC;AAAA,MAC1E;AACD,YAAM,iBAAiB,UAAU,MAAM,GAAG;AAC1C,YAAM,aAAa,CAAC,eAAe,CAAC;AACpC,YAAM,aAAa,eAAe,MAAM,CAAC,EAAE,KAAK,GAAG;AACnD,YAAM,UAAU,CAAA;AAChB,iBAAW,UAAU,aAAa;AAChC,YAAI,CAAC;AAAQ;AACb,cAAM,aAAa,OAAO,QAAQ,GAAG;AACrC,YAAI,eAAe,IAAI;AACrB,iBAAO,QAAO;AACd,iBAAO,OAAO,IAAI,MAAM,gDAAgD,SAAS,CAAC;AAAA,QACnF;AACD,cAAM,MAAM,OAAO,MAAM,GAAG,UAAU,EAAE;AACxC,cAAM,QAAQ,OAAO,MAAM,aAAa,CAAC,EAAE;AAC3C,cAAM,UAAU,QAAQ,GAAG;AAC3B,YAAI,OAAO,YAAY,UAAU;AAC/B,kBAAQ,GAAG,IAAI,CAAC,SAAS,KAAK;AAAA,QAC/B,WAAU,MAAM,QAAQ,OAAO,GAAG;AACjC,kBAAQ,KAAK,KAAK;AAAA,QAC5B,OAAe;AACL,kBAAQ,GAAG,IAAI;AAAA,QAChB;AAAA,MACF;AACD,YAAM,oCAAoC,WAAW,OAAO;AAC5D;AACA,cAAQ;AAAA,QACN,SAAS;AAAA,UACP;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAAA,QACD;AAAA,MACR,CAAO;AAAA,IACF;AAED,WAAO,GAAG,SAAS,OAAO;AAC1B,WAAO,GAAG,OAAO,KAAK;AAEtB;EACJ,CAAG;AACH;","x_google_ignoreList":[0]}