"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const net = require("net");
const tls = require("tls");
const url = require("url");
const base = require("./base.cjs");
const parseProxyResponse = require("./parse-proxy-response.cjs");
const _nullishCoalesce = require('./../../_node_modules/@sentry/utils/esm/buildPolyfills/_nullishCoalesce.cjs');
const _optionalChain = require('./../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.cjs');
const logger = require('./../../_node_modules/@sentry/utils/esm/logger.cjs');
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const net__namespace = /* @__PURE__ */ _interopNamespaceDefault(net);
const tls__namespace = /* @__PURE__ */ _interopNamespaceDefault(tls);
function debug(...args) {
  logger.logger.log("[https-proxy-agent]", ...args);
}
class HttpsProxyAgent extends base.Agent {
  static __initStatic() {
    this.protocols = ["http", "https"];
  }
  constructor(proxy, opts) {
    super(opts);
    this.options = {};
    this.proxy = typeof proxy === "string" ? new url.URL(proxy) : proxy;
    this.proxyHeaders = _nullishCoalesce._nullishCoalesce(_optionalChain._optionalChain([opts, "optionalAccess", (_2) => _2.headers]), () => ({}));
    debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      // Attempt to negotiate http/1.1 for proxy servers that support http/2
      ALPNProtocols: ["http/1.1"],
      ...opts ? omit(opts, "headers") : null,
      host,
      port
    };
  }
  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   */
  async connect(req, opts) {
    const { proxy } = this;
    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }
    let socket;
    if (proxy.protocol === "https:") {
      debug("Creating `tls.Socket`: %o", this.connectOpts);
      const servername = this.connectOpts.servername || this.connectOpts.host;
      socket = tls__namespace.connect({
        ...this.connectOpts,
        servername: servername && net__namespace.isIP(servername) ? void 0 : servername
      });
    } else {
      debug("Creating `net.Socket`: %o", this.connectOpts);
      socket = net__namespace.connect(this.connectOpts);
    }
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host = net__namespace.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    headers.Host = `${host}:${opts.port}`;
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name of Object.keys(headers)) {
      payload += `${name}: ${headers[name]}\r
`;
    }
    const proxyResponsePromise = parseProxyResponse.parseProxyResponse(socket);
    socket.write(`${payload}\r
`);
    const { connect, buffered } = await proxyResponsePromise;
    req.emit("proxyConnect", connect);
    this.emit("proxyConnect", connect, req);
    if (connect.statusCode === 200) {
      req.once("socket", resume);
      if (opts.secureEndpoint) {
        debug("Upgrading socket connection to TLS");
        const servername = opts.servername || opts.host;
        return tls__namespace.connect({
          ...omit(opts, "host", "path", "port"),
          socket,
          servername: net__namespace.isIP(servername) ? void 0 : servername
        });
      }
      return socket;
    }
    socket.destroy();
    const fakeSocket = new net__namespace.Socket({ writable: false });
    fakeSocket.readable = true;
    req.once("socket", (s) => {
      debug("Replaying proxy buffer for failed request");
      s.push(buffered);
      s.push(null);
    });
    return fakeSocket;
  }
}
HttpsProxyAgent.__initStatic();
function resume(socket) {
  socket.resume();
}
function omit(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
exports.HttpsProxyAgent = HttpsProxyAgent;
//# sourceMappingURL=index.cjs.map
