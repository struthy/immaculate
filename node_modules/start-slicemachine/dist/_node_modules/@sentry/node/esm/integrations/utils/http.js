import { URL } from "url";
import { NODE_VERSION } from "../../nodeVersion.js";
import { _optionalChain } from './../../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js';
function extractRawUrl(requestOptions) {
  const { protocol, hostname, port } = parseRequestOptions(requestOptions);
  const path = requestOptions.path ? requestOptions.path : "/";
  return `${protocol}//${hostname}${port}${path}`;
}
function extractUrl(requestOptions) {
  const { protocol, hostname, port } = parseRequestOptions(requestOptions);
  const path = requestOptions.pathname || "/";
  const authority = requestOptions.auth ? redactAuthority(requestOptions.auth) : "";
  return `${protocol}//${authority}${hostname}${port}${path}`;
}
function redactAuthority(auth) {
  const [user, password] = auth.split(":");
  return `${user ? "[Filtered]" : ""}:${password ? "[Filtered]" : ""}@`;
}
function cleanSpanDescription(description, requestOptions, request) {
  if (!description) {
    return description;
  }
  let [method, requestUrl] = description.split(" ");
  if (requestOptions.host && !requestOptions.protocol) {
    requestOptions.protocol = _optionalChain([request, "optionalAccess", (_) => _.agent, "optionalAccess", (_2) => _2.protocol]);
    requestUrl = extractUrl(requestOptions);
  }
  if (_optionalChain([requestUrl, "optionalAccess", (_3) => _3.startsWith, "call", (_4) => _4("///")])) {
    requestUrl = requestUrl.slice(2);
  }
  return `${method} ${requestUrl}`;
}
function urlToOptions(url) {
  const options = {
    protocol: url.protocol,
    hostname: typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
    hash: url.hash,
    search: url.search,
    pathname: url.pathname,
    path: `${url.pathname || ""}${url.search || ""}`,
    href: url.href
  };
  if (url.port !== "") {
    options.port = Number(url.port);
  }
  if (url.username || url.password) {
    options.auth = `${url.username}:${url.password}`;
  }
  return options;
}
function normalizeRequestArgs(httpModule, requestArgs) {
  let callback, requestOptions;
  if (typeof requestArgs[requestArgs.length - 1] === "function") {
    callback = requestArgs.pop();
  }
  if (typeof requestArgs[0] === "string") {
    requestOptions = urlToOptions(new URL(requestArgs[0]));
  } else if (requestArgs[0] instanceof URL) {
    requestOptions = urlToOptions(requestArgs[0]);
  } else {
    requestOptions = requestArgs[0];
    try {
      const parsed = new URL(
        requestOptions.path || "",
        `${requestOptions.protocol || "http:"}//${requestOptions.hostname}`
      );
      requestOptions = {
        pathname: parsed.pathname,
        search: parsed.search,
        hash: parsed.hash,
        ...requestOptions
      };
    } catch (e) {
    }
  }
  if (requestArgs.length === 2) {
    requestOptions = { ...requestOptions, ...requestArgs[1] };
  }
  if (requestOptions.protocol === void 0) {
    if (NODE_VERSION.major > 8) {
      requestOptions.protocol = _optionalChain([_optionalChain([httpModule, "optionalAccess", (_5) => _5.globalAgent]), "optionalAccess", (_6) => _6.protocol]) || _optionalChain([requestOptions.agent, "optionalAccess", (_7) => _7.protocol]) || _optionalChain([requestOptions._defaultAgent, "optionalAccess", (_8) => _8.protocol]);
    } else {
      requestOptions.protocol = _optionalChain([requestOptions.agent, "optionalAccess", (_9) => _9.protocol]) || _optionalChain([requestOptions._defaultAgent, "optionalAccess", (_10) => _10.protocol]) || _optionalChain([_optionalChain([httpModule, "optionalAccess", (_11) => _11.globalAgent]), "optionalAccess", (_12) => _12.protocol]);
    }
  }
  if (callback) {
    return [requestOptions, callback];
  } else {
    return [requestOptions];
  }
}
function parseRequestOptions(requestOptions) {
  const protocol = requestOptions.protocol || "";
  const hostname = requestOptions.hostname || requestOptions.host || "";
  const port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 || /^(.*):(\d+)$/.test(hostname) ? "" : `:${requestOptions.port}`;
  return { protocol, hostname, port };
}
export {
  cleanSpanDescription,
  extractRawUrl,
  extractUrl,
  normalizeRequestArgs,
  urlToOptions
};
//# sourceMappingURL=http.js.map
