"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const url = require("url");
const nodeVersion = require("../../nodeVersion.cjs");
const _optionalChain = require('./../../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.cjs');
function extractRawUrl(requestOptions) {
  const { protocol, hostname, port } = parseRequestOptions(requestOptions);
  const path = requestOptions.path ? requestOptions.path : "/";
  return `${protocol}//${hostname}${port}${path}`;
}
function extractUrl(requestOptions) {
  const { protocol, hostname, port } = parseRequestOptions(requestOptions);
  const path = requestOptions.pathname || "/";
  const authority = requestOptions.auth ? redactAuthority(requestOptions.auth) : "";
  return `${protocol}//${authority}${hostname}${port}${path}`;
}
function redactAuthority(auth) {
  const [user, password] = auth.split(":");
  return `${user ? "[Filtered]" : ""}:${password ? "[Filtered]" : ""}@`;
}
function cleanSpanDescription(description, requestOptions, request) {
  if (!description) {
    return description;
  }
  let [method, requestUrl] = description.split(" ");
  if (requestOptions.host && !requestOptions.protocol) {
    requestOptions.protocol = _optionalChain._optionalChain([request, "optionalAccess", (_) => _.agent, "optionalAccess", (_2) => _2.protocol]);
    requestUrl = extractUrl(requestOptions);
  }
  if (_optionalChain._optionalChain([requestUrl, "optionalAccess", (_3) => _3.startsWith, "call", (_4) => _4("///")])) {
    requestUrl = requestUrl.slice(2);
  }
  return `${method} ${requestUrl}`;
}
function urlToOptions(url2) {
  const options = {
    protocol: url2.protocol,
    hostname: typeof url2.hostname === "string" && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname,
    hash: url2.hash,
    search: url2.search,
    pathname: url2.pathname,
    path: `${url2.pathname || ""}${url2.search || ""}`,
    href: url2.href
  };
  if (url2.port !== "") {
    options.port = Number(url2.port);
  }
  if (url2.username || url2.password) {
    options.auth = `${url2.username}:${url2.password}`;
  }
  return options;
}
function normalizeRequestArgs(httpModule, requestArgs) {
  let callback, requestOptions;
  if (typeof requestArgs[requestArgs.length - 1] === "function") {
    callback = requestArgs.pop();
  }
  if (typeof requestArgs[0] === "string") {
    requestOptions = urlToOptions(new url.URL(requestArgs[0]));
  } else if (requestArgs[0] instanceof url.URL) {
    requestOptions = urlToOptions(requestArgs[0]);
  } else {
    requestOptions = requestArgs[0];
    try {
      const parsed = new url.URL(
        requestOptions.path || "",
        `${requestOptions.protocol || "http:"}//${requestOptions.hostname}`
      );
      requestOptions = {
        pathname: parsed.pathname,
        search: parsed.search,
        hash: parsed.hash,
        ...requestOptions
      };
    } catch (e) {
    }
  }
  if (requestArgs.length === 2) {
    requestOptions = { ...requestOptions, ...requestArgs[1] };
  }
  if (requestOptions.protocol === void 0) {
    if (nodeVersion.NODE_VERSION.major > 8) {
      requestOptions.protocol = _optionalChain._optionalChain([_optionalChain._optionalChain([httpModule, "optionalAccess", (_5) => _5.globalAgent]), "optionalAccess", (_6) => _6.protocol]) || _optionalChain._optionalChain([requestOptions.agent, "optionalAccess", (_7) => _7.protocol]) || _optionalChain._optionalChain([requestOptions._defaultAgent, "optionalAccess", (_8) => _8.protocol]);
    } else {
      requestOptions.protocol = _optionalChain._optionalChain([requestOptions.agent, "optionalAccess", (_9) => _9.protocol]) || _optionalChain._optionalChain([requestOptions._defaultAgent, "optionalAccess", (_10) => _10.protocol]) || _optionalChain._optionalChain([_optionalChain._optionalChain([httpModule, "optionalAccess", (_11) => _11.globalAgent]), "optionalAccess", (_12) => _12.protocol]);
    }
  }
  if (callback) {
    return [requestOptions, callback];
  } else {
    return [requestOptions];
  }
}
function parseRequestOptions(requestOptions) {
  const protocol = requestOptions.protocol || "";
  const hostname = requestOptions.hostname || requestOptions.host || "";
  const port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 || /^(.*):(\d+)$/.test(hostname) ? "" : `:${requestOptions.port}`;
  return { protocol, hostname, port };
}
exports.cleanSpanDescription = cleanSpanDescription;
exports.extractRawUrl = extractRawUrl;
exports.extractUrl = extractUrl;
exports.normalizeRequestArgs = normalizeRequestArgs;
exports.urlToOptions = urlToOptions;
//# sourceMappingURL=http.cjs.map
