import { NODE_VERSION } from "../../nodeVersion.js";
import { defineIntegration } from './../../../_node_modules/@sentry/core/esm/integration.js';
import { LRUMap } from './../../../_node_modules/@sentry/utils/esm/lru.js';
import { hasTracingEnabled } from './../../../_node_modules/@sentry/core/esm/utils/hasTracingEnabled.js';
import { _optionalChain } from './../../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js';
import { getClient, getCurrentScope, addBreadcrumb } from './../../../_node_modules/@sentry/core/esm/exports.js';
import { isSentryRequestUrl } from './../../../_node_modules/@sentry/core/esm/utils/isSentryRequestUrl.js';
import { getIsolationScope } from './../../../_node_modules/@sentry/core/esm/hub.js';
import { getActiveSpan } from './../../../_node_modules/@sentry/core/esm/tracing/trace.js';
import { spanToTraceHeader } from './../../../_node_modules/@sentry/core/esm/utils/spanUtils.js';
import { generateSentryTraceHeader } from './../../../_node_modules/@sentry/utils/esm/tracing.js';
import { dynamicSamplingContextToSentryBaggageHeader } from './../../../_node_modules/@sentry/utils/esm/baggage.js';
import { getDynamicSamplingContextFromSpan, getDynamicSamplingContextFromClient } from './../../../_node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.js';
import { setHttpStatus } from './../../../_node_modules/@sentry/core/esm/tracing/spanstatus.js';
import { parseUrl, getSanitizedUrlString } from './../../../_node_modules/@sentry/utils/esm/url.js';
import { stringMatchesSomePattern } from './../../../_node_modules/@sentry/utils/esm/string.js';
var ChannelName;
(function(ChannelName2) {
  const RequestCreate = "undici:request:create";
  ChannelName2["RequestCreate"] = RequestCreate;
  const RequestEnd = "undici:request:headers";
  ChannelName2["RequestEnd"] = RequestEnd;
  const RequestError = "undici:request:error";
  ChannelName2["RequestError"] = RequestError;
})(ChannelName || (ChannelName = {}));
const _nativeNodeFetchintegration = (options) => {
  return new Undici(options);
};
const nativeNodeFetchintegration = defineIntegration(_nativeNodeFetchintegration);
class Undici {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Undici";
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line deprecation/deprecation
  __init() {
    this.name = Undici.id;
  }
  __init2() {
    this._createSpanUrlMap = new LRUMap(100);
  }
  __init3() {
    this._headersUrlMap = new LRUMap(100);
  }
  constructor(_options = {}) {
    Undici.prototype.__init.call(this);
    Undici.prototype.__init2.call(this);
    Undici.prototype.__init3.call(this);
    Undici.prototype.__init4.call(this);
    Undici.prototype.__init5.call(this);
    Undici.prototype.__init6.call(this);
    this._options = {
      breadcrumbs: _options.breadcrumbs === void 0 ? true : _options.breadcrumbs,
      tracing: _options.tracing,
      shouldCreateSpanForRequest: _options.shouldCreateSpanForRequest
    };
  }
  /**
   * @inheritDoc
   */
  setupOnce(_addGlobalEventProcessor) {
    if (NODE_VERSION.major < 16) {
      return;
    }
    let ds;
    try {
      ds = require("diagnostics_channel");
    } catch (e) {
    }
    if (!ds || !ds.subscribe) {
      return;
    }
    ds.subscribe(ChannelName.RequestCreate, this._onRequestCreate);
    ds.subscribe(ChannelName.RequestEnd, this._onRequestEnd);
    ds.subscribe(ChannelName.RequestError, this._onRequestError);
  }
  /** Helper that wraps shouldCreateSpanForRequest option */
  _shouldCreateSpan(url) {
    if (this._options.tracing === false || this._options.tracing === void 0 && !hasTracingEnabled()) {
      return false;
    }
    if (this._options.shouldCreateSpanForRequest === void 0) {
      return true;
    }
    const cachedDecision = this._createSpanUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = this._options.shouldCreateSpanForRequest(url);
    this._createSpanUrlMap.set(url, decision);
    return decision;
  }
  __init4() {
    this._onRequestCreate = (message) => {
      if (!_optionalChain([getClient, "call", (_10) => _10(), "optionalAccess", (_11) => _11.getIntegration, "call", (_12) => _12(Undici)])) {
        return;
      }
      const { request } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      const client = getClient();
      if (!client) {
        return;
      }
      if (isSentryRequestUrl(stringUrl, client) || request.__sentry_span__ !== void 0) {
        return;
      }
      const clientOptions = client.getOptions();
      const scope = getCurrentScope();
      const isolationScope = getIsolationScope();
      const parentSpan = getActiveSpan();
      const span = this._shouldCreateSpan(stringUrl) ? createRequestSpan(parentSpan, request, stringUrl) : void 0;
      if (span) {
        request.__sentry_span__ = span;
      }
      const shouldAttachTraceData = (url) => {
        if (clientOptions.tracePropagationTargets === void 0) {
          return true;
        }
        const cachedDecision = this._headersUrlMap.get(url);
        if (cachedDecision !== void 0) {
          return cachedDecision;
        }
        const decision = stringMatchesSomePattern(url, clientOptions.tracePropagationTargets);
        this._headersUrlMap.set(url, decision);
        return decision;
      };
      if (shouldAttachTraceData(stringUrl)) {
        const { traceId, spanId, sampled, dsc } = {
          ...isolationScope.getPropagationContext(),
          ...scope.getPropagationContext()
        };
        const sentryTraceHeader = span ? spanToTraceHeader(span) : generateSentryTraceHeader(traceId, spanId, sampled);
        const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(
          dsc || (span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromClient(traceId, client, scope))
        );
        setHeadersOnRequest(request, sentryTraceHeader, sentryBaggageHeader);
      }
    };
  }
  __init5() {
    this._onRequestEnd = (message) => {
      if (!_optionalChain([getClient, "call", (_13) => _13(), "optionalAccess", (_14) => _14.getIntegration, "call", (_15) => _15(Undici)])) {
        return;
      }
      const { request, response } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      if (isSentryRequestUrl(stringUrl, getClient())) {
        return;
      }
      const span = request.__sentry_span__;
      if (span) {
        setHttpStatus(span, response.statusCode);
        span.end();
      }
      if (this._options.breadcrumbs) {
        addBreadcrumb(
          {
            category: "http",
            data: {
              method: request.method,
              status_code: response.statusCode,
              url: stringUrl
            },
            type: "http"
          },
          {
            event: "response",
            request,
            response
          }
        );
      }
    };
  }
  __init6() {
    this._onRequestError = (message) => {
      if (!_optionalChain([getClient, "call", (_16) => _16(), "optionalAccess", (_17) => _17.getIntegration, "call", (_18) => _18(Undici)])) {
        return;
      }
      const { request } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      if (isSentryRequestUrl(stringUrl, getClient())) {
        return;
      }
      const span = request.__sentry_span__;
      if (span) {
        span.setStatus("internal_error");
        span.end();
      }
      if (this._options.breadcrumbs) {
        addBreadcrumb(
          {
            category: "http",
            data: {
              method: request.method,
              url: stringUrl
            },
            level: "error",
            type: "http"
          },
          {
            event: "error",
            request
          }
        );
      }
    };
  }
}
Undici.__initStatic();
function setHeadersOnRequest(request, sentryTrace, sentryBaggageHeader) {
  let hasSentryHeaders;
  if (Array.isArray(request.headers)) {
    hasSentryHeaders = request.headers.some((headerLine) => headerLine === "sentry-trace");
  } else {
    const headerLines = request.headers.split("\r\n");
    hasSentryHeaders = headerLines.some((headerLine) => headerLine.startsWith("sentry-trace:"));
  }
  if (hasSentryHeaders) {
    return;
  }
  request.addHeader("sentry-trace", sentryTrace);
  if (sentryBaggageHeader) {
    request.addHeader("baggage", sentryBaggageHeader);
  }
}
function createRequestSpan(activeSpan, request, stringUrl) {
  const url = parseUrl(stringUrl);
  const method = request.method || "GET";
  const data = {
    "http.method": method
  };
  if (url.search) {
    data["http.query"] = url.search;
  }
  if (url.hash) {
    data["http.fragment"] = url.hash;
  }
  return _optionalChain([activeSpan, "optionalAccess", (_19) => _19.startChild, "call", (_20) => _20({
    op: "http.client",
    origin: "auto.http.node.undici",
    description: `${method} ${getSanitizedUrlString(url)}`,
    data
  })]);
}
export {
  ChannelName,
  Undici,
  nativeNodeFetchintegration
};
//# sourceMappingURL=index.js.map
