import { readFile } from "fs";
import { defineIntegration, convertIntegrationFnToClass } from './../../_node_modules/@sentry/core/esm/integration.js';
import { _optionalChain } from './../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js';
import { addContextToFrame } from './../../_node_modules/@sentry/utils/esm/misc.js';
import { LRUMap } from './../../_node_modules/@sentry/utils/esm/lru.js';
const FILE_CONTENT_CACHE = new LRUMap(100);
const DEFAULT_LINES_OF_CONTEXT = 7;
const INTEGRATION_NAME = "ContextLines";
function readTextFileAsync(path) {
  return new Promise((resolve, reject) => {
    readFile(path, "utf8", (err, data) => {
      if (err)
        reject(err);
      else
        resolve(data);
    });
  });
}
const _contextLinesIntegration = (options = {}) => {
  const contextLines = options.frameContextLines !== void 0 ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
  return {
    name: INTEGRATION_NAME,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    processEvent(event) {
      return addSourceContext(event, contextLines);
    }
  };
};
const contextLinesIntegration = defineIntegration(_contextLinesIntegration);
convertIntegrationFnToClass(INTEGRATION_NAME, contextLinesIntegration);
async function addSourceContext(event, contextLines) {
  const enqueuedReadSourceFileTasks = {};
  const readSourceFileTasks = [];
  if (contextLines > 0 && _optionalChain([event, "access", (_2) => _2.exception, "optionalAccess", (_3) => _3.values])) {
    for (const exception of event.exception.values) {
      if (!_optionalChain([exception, "access", (_4) => _4.stacktrace, "optionalAccess", (_5) => _5.frames])) {
        continue;
      }
      for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {
        const frame = exception.stacktrace.frames[i];
        if (frame.filename && !enqueuedReadSourceFileTasks[frame.filename] && !FILE_CONTENT_CACHE.get(frame.filename)) {
          readSourceFileTasks.push(_readSourceFile(frame.filename));
          enqueuedReadSourceFileTasks[frame.filename] = 1;
        }
      }
    }
  }
  if (readSourceFileTasks.length > 0) {
    await Promise.all(readSourceFileTasks);
  }
  if (contextLines > 0 && _optionalChain([event, "access", (_6) => _6.exception, "optionalAccess", (_7) => _7.values])) {
    for (const exception of event.exception.values) {
      if (exception.stacktrace && exception.stacktrace.frames) {
        await addSourceContextToFrames(exception.stacktrace.frames, contextLines);
      }
    }
  }
  return event;
}
function addSourceContextToFrames(frames, contextLines) {
  for (const frame of frames) {
    if (frame.filename && frame.context_line === void 0) {
      const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);
      if (sourceFileLines) {
        try {
          addContextToFrame(sourceFileLines, frame, contextLines);
        } catch (e) {
        }
      }
    }
  }
}
async function _readSourceFile(filename) {
  const cachedFile = FILE_CONTENT_CACHE.get(filename);
  if (cachedFile === null) {
    return null;
  }
  if (cachedFile !== void 0) {
    return cachedFile;
  }
  let content = null;
  try {
    const rawFileContents = await readTextFileAsync(filename);
    content = rawFileContents.split("\n");
  } catch (_) {
  }
  FILE_CONTENT_CACHE.set(filename, content);
  return content;
}
export {
  contextLinesIntegration
};
//# sourceMappingURL=contextlines.js.map
