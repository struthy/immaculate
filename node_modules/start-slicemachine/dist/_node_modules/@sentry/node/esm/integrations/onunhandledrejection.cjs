"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const errorhandling = require("./utils/errorhandling.cjs");
const integration = require('./../../_node_modules/@sentry/core/esm/integration.cjs');
const exports$1 = require('./../../_node_modules/@sentry/core/esm/exports.cjs');
const logger = require('./../../_node_modules/@sentry/utils/esm/logger.cjs');
const INTEGRATION_NAME = "OnUnhandledRejection";
const _onUnhandledRejectionIntegration = (options = {}) => {
  const mode = options.mode || "warn";
  return {
    name: INTEGRATION_NAME,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    setup(client) {
      global.process.on("unhandledRejection", makeUnhandledPromiseHandler(client, { mode }));
    }
  };
};
const onUnhandledRejectionIntegration = integration.defineIntegration(_onUnhandledRejectionIntegration);
integration.convertIntegrationFnToClass(
  INTEGRATION_NAME,
  onUnhandledRejectionIntegration
);
function makeUnhandledPromiseHandler(client, options) {
  return function sendUnhandledPromise(reason, promise) {
    if (exports$1.getClient() !== client) {
      return;
    }
    exports$1.captureException(reason, {
      originalException: promise,
      captureContext: {
        extra: { unhandledPromiseRejection: true }
      },
      mechanism: {
        handled: false,
        type: "onunhandledrejection"
      }
    });
    handleRejection(reason, options);
  };
}
function handleRejection(reason, options) {
  const rejectionWarning = "This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";
  if (options.mode === "warn") {
    logger.consoleSandbox(() => {
      console.warn(rejectionWarning);
      console.error(reason && reason.stack ? reason.stack : reason);
    });
  } else if (options.mode === "strict") {
    logger.consoleSandbox(() => {
      console.warn(rejectionWarning);
    });
    errorhandling.logAndExitProcess(reason);
  }
}
exports.makeUnhandledPromiseHandler = makeUnhandledPromiseHandler;
exports.onUnhandledRejectionIntegration = onUnhandledRejectionIntegration;
//# sourceMappingURL=onunhandledrejection.cjs.map
