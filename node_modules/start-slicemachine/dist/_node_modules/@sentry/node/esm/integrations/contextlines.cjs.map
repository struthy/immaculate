{"version":3,"file":"contextlines.cjs","sources":["../../../../../../../../node_modules/@sentry/node/esm/integrations/contextlines.js"],"sourcesContent":["import { _optionalChain } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { defineIntegration, convertIntegrationFnToClass } from '@sentry/core';\nimport { LRUMap, addContextToFrame } from '@sentry/utils';\n\nconst FILE_CONTENT_CACHE = new LRUMap(100);\nconst DEFAULT_LINES_OF_CONTEXT = 7;\nconst INTEGRATION_NAME = 'ContextLines';\n\n// TODO: Replace with promisify when minimum supported node >= v8\nfunction readTextFileAsync(path) {\n  return new Promise((resolve, reject) => {\n    readFile(path, 'utf8', (err, data) => {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n}\n\nconst _contextLinesIntegration = ((options = {}) => {\n  const contextLines = options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    processEvent(event) {\n      return addSourceContext(event, contextLines);\n    },\n  };\n}) ;\n\nconst contextLinesIntegration = defineIntegration(_contextLinesIntegration);\n\n/**\n * Add node modules / packages to the event.\n * @deprecated Use `contextLinesIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst ContextLines = convertIntegrationFnToClass(INTEGRATION_NAME, contextLinesIntegration)\n\n;\n\nasync function addSourceContext(event, contextLines) {\n  // keep a lookup map of which files we've already enqueued to read,\n  // so we don't enqueue the same file multiple times which would cause multiple i/o reads\n  const enqueuedReadSourceFileTasks = {};\n  const readSourceFileTasks = [];\n\n  if (contextLines > 0 && _optionalChain([event, 'access', _2 => _2.exception, 'optionalAccess', _3 => _3.values])) {\n    for (const exception of event.exception.values) {\n      if (!_optionalChain([exception, 'access', _4 => _4.stacktrace, 'optionalAccess', _5 => _5.frames])) {\n        continue;\n      }\n\n      // We want to iterate in reverse order as calling cache.get will bump the file in our LRU cache.\n      // This ends up prioritizes source context for frames at the top of the stack instead of the bottom.\n      for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {\n        const frame = exception.stacktrace.frames[i];\n        // Call cache.get to bump the file to the top of the cache and ensure we have not already\n        // enqueued a read operation for this filename\n        if (frame.filename && !enqueuedReadSourceFileTasks[frame.filename] && !FILE_CONTENT_CACHE.get(frame.filename)) {\n          readSourceFileTasks.push(_readSourceFile(frame.filename));\n          enqueuedReadSourceFileTasks[frame.filename] = 1;\n        }\n      }\n    }\n  }\n\n  // check if files to read > 0, if so, await all of them to be read before adding source contexts.\n  // Normally, Promise.all here could be short circuited if one of the promises rejects, but we\n  // are guarding from that by wrapping the i/o read operation in a try/catch.\n  if (readSourceFileTasks.length > 0) {\n    await Promise.all(readSourceFileTasks);\n  }\n\n  // Perform the same loop as above, but this time we can assume all files are in the cache\n  // and attempt to add source context to frames.\n  if (contextLines > 0 && _optionalChain([event, 'access', _6 => _6.exception, 'optionalAccess', _7 => _7.values])) {\n    for (const exception of event.exception.values) {\n      if (exception.stacktrace && exception.stacktrace.frames) {\n        await addSourceContextToFrames(exception.stacktrace.frames, contextLines);\n      }\n    }\n  }\n\n  return event;\n}\n\n/** Adds context lines to frames */\nfunction addSourceContextToFrames(frames, contextLines) {\n  for (const frame of frames) {\n    // Only add context if we have a filename and it hasn't already been added\n    if (frame.filename && frame.context_line === undefined) {\n      const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);\n\n      if (sourceFileLines) {\n        try {\n          addContextToFrame(sourceFileLines, frame, contextLines);\n        } catch (e) {\n          // anomaly, being defensive in case\n          // unlikely to ever happen in practice but can definitely happen in theory\n        }\n      }\n    }\n  }\n}\n\n// eslint-disable-next-line deprecation/deprecation\n\n/**\n * Reads file contents and caches them in a global LRU cache.\n * If reading fails, mark the file as null in the cache so we don't try again.\n *\n * @param filename filepath to read content from.\n */\nasync function _readSourceFile(filename) {\n  const cachedFile = FILE_CONTENT_CACHE.get(filename);\n\n  // We have already attempted to read this file and failed, do not try again\n  if (cachedFile === null) {\n    return null;\n  }\n\n  // We have a cache hit, return it\n  if (cachedFile !== undefined) {\n    return cachedFile;\n  }\n\n  // Guard from throwing if readFile fails, this enables us to use Promise.all and\n  // not have it short circuiting if one of the promises rejects + since context lines are added\n  // on a best effort basis, we want to throw here anyways.\n\n  // If we made it to here, it means that our file is not cache nor marked as failed, so attempt to read it\n  let content = null;\n  try {\n    const rawFileContents = await readTextFileAsync(filename);\n    content = rawFileContents.split('\\n');\n  } catch (_) {\n    // if we fail, we will mark the file as null in the cache and short circuit next time we try to read it\n  }\n\n  FILE_CONTENT_CACHE.set(filename, content);\n  return content;\n}\n\nexport { ContextLines, contextLinesIntegration };\n//# sourceMappingURL=contextlines.js.map\n"],"names":["LRUMap","readFile","defineIntegration","convertIntegrationFnToClass","_optionalChain","addContextToFrame"],"mappings":";;;;;;;AAKA,MAAM,qBAAqB,IAAIA,WAAO,GAAG;AACzC,MAAM,2BAA2B;AACjC,MAAM,mBAAmB;AAGzB,SAAS,kBAAkB,MAAM;AAC/B,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtCC,OAAAA,SAAS,MAAM,QAAQ,CAAC,KAAK,SAAS;AACpC,UAAI;AAAK,eAAO,GAAG;AAAA;AACd,gBAAQ,IAAI;AAAA,IACvB,CAAK;AAAA,EACL,CAAG;AACH;AAEA,MAAM,2BAA4B,CAAC,UAAU,OAAO;AAClD,QAAM,eAAe,QAAQ,sBAAsB,SAAY,QAAQ,oBAAoB;AAE3F,SAAO;AAAA,IACL,MAAM;AAAA;AAAA,IAEN,YAAY;AAAA,IAAE;AAAA;AAAA,IACd,aAAa,OAAO;AAClB,aAAO,iBAAiB,OAAO,YAAY;AAAA,IAC5C;AAAA,EACL;AACA;AAEK,MAAC,0BAA0BC,YAAiB,kBAAC,wBAAwB;AAOrDC,YAAAA,4BAA4B,kBAAkB,uBAAuB;AAI1F,eAAe,iBAAiB,OAAO,cAAc;AAGnD,QAAM,8BAA8B,CAAA;AACpC,QAAM,sBAAsB,CAAA;AAE5B,MAAI,eAAe,KAAKC,eAAc,eAAC,CAAC,OAAO,UAAU,QAAM,GAAG,WAAW,kBAAkB,QAAM,GAAG,MAAM,CAAC,GAAG;AAChH,eAAW,aAAa,MAAM,UAAU,QAAQ;AAC9C,UAAI,CAACA,eAAAA,eAAe,CAAC,WAAW,UAAU,QAAM,GAAG,YAAY,kBAAkB,QAAM,GAAG,MAAM,CAAC,GAAG;AAClG;AAAA,MACD;AAID,eAAS,IAAI,UAAU,WAAW,OAAO,SAAS,GAAG,KAAK,GAAG,KAAK;AAChE,cAAM,QAAQ,UAAU,WAAW,OAAO,CAAC;AAG3C,YAAI,MAAM,YAAY,CAAC,4BAA4B,MAAM,QAAQ,KAAK,CAAC,mBAAmB,IAAI,MAAM,QAAQ,GAAG;AAC7G,8BAAoB,KAAK,gBAAgB,MAAM,QAAQ,CAAC;AACxD,sCAA4B,MAAM,QAAQ,IAAI;AAAA,QAC/C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAKD,MAAI,oBAAoB,SAAS,GAAG;AAClC,UAAM,QAAQ,IAAI,mBAAmB;AAAA,EACtC;AAID,MAAI,eAAe,KAAKA,eAAc,eAAC,CAAC,OAAO,UAAU,QAAM,GAAG,WAAW,kBAAkB,QAAM,GAAG,MAAM,CAAC,GAAG;AAChH,eAAW,aAAa,MAAM,UAAU,QAAQ;AAC9C,UAAI,UAAU,cAAc,UAAU,WAAW,QAAQ;AACvD,cAAM,yBAAyB,UAAU,WAAW,QAAQ,YAAY;AAAA,MACzE;AAAA,IACF;AAAA,EACF;AAED,SAAO;AACT;AAGA,SAAS,yBAAyB,QAAQ,cAAc;AACtD,aAAW,SAAS,QAAQ;AAE1B,QAAI,MAAM,YAAY,MAAM,iBAAiB,QAAW;AACtD,YAAM,kBAAkB,mBAAmB,IAAI,MAAM,QAAQ;AAE7D,UAAI,iBAAiB;AACnB,YAAI;AACFC,eAAAA,kBAAkB,iBAAiB,OAAO,YAAY;AAAA,QACvD,SAAQ,GAAP;AAAA,QAGD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACH;AAUA,eAAe,gBAAgB,UAAU;AACvC,QAAM,aAAa,mBAAmB,IAAI,QAAQ;AAGlD,MAAI,eAAe,MAAM;AACvB,WAAO;AAAA,EACR;AAGD,MAAI,eAAe,QAAW;AAC5B,WAAO;AAAA,EACR;AAOD,MAAI,UAAU;AACd,MAAI;AACF,UAAM,kBAAkB,MAAM,kBAAkB,QAAQ;AACxD,cAAU,gBAAgB,MAAM,IAAI;AAAA,EACrC,SAAQ,GAAP;AAAA,EAED;AAED,qBAAmB,IAAI,UAAU,OAAO;AACxC,SAAO;AACT;;","x_google_ignoreList":[0]}