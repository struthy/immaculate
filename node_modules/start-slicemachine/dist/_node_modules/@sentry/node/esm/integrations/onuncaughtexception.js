import { DEBUG_BUILD } from "../debug-build.js";
import { logAndExitProcess } from "./utils/errorhandling.js";
import { defineIntegration, convertIntegrationFnToClass } from './../../_node_modules/@sentry/core/esm/integration.js';
import { getClient, captureException } from './../../_node_modules/@sentry/core/esm/exports.js';
import { logger } from './../../_node_modules/@sentry/utils/esm/logger.js';
const INTEGRATION_NAME = "OnUncaughtException";
const _onUncaughtExceptionIntegration = (options = {}) => {
  const _options = {
    exitEvenIfOtherHandlersAreRegistered: true,
    ...options
  };
  return {
    name: INTEGRATION_NAME,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    setup(client) {
      global.process.on("uncaughtException", makeErrorHandler(client, _options));
    }
  };
};
const onUncaughtExceptionIntegration = defineIntegration(_onUncaughtExceptionIntegration);
convertIntegrationFnToClass(
  INTEGRATION_NAME,
  onUncaughtExceptionIntegration
);
function makeErrorHandler(client, options) {
  const timeout = 2e3;
  let caughtFirstError = false;
  let caughtSecondError = false;
  let calledFatalError = false;
  let firstError;
  const clientOptions = client.getOptions();
  return Object.assign(
    (error) => {
      let onFatalError = logAndExitProcess;
      if (options.onFatalError) {
        onFatalError = options.onFatalError;
      } else if (clientOptions.onFatalError) {
        onFatalError = clientOptions.onFatalError;
      }
      const userProvidedListenersCount = global.process.listeners("uncaughtException").reduce((acc, listener) => {
        if (
          // There are 3 listeners we ignore:
          listener.name === "domainUncaughtExceptionClear" || // as soon as we're using domains this listener is attached by node itself
          listener.tag && listener.tag === "sentry_tracingErrorCallback" || // the handler we register for tracing
          listener._errorHandler
        ) {
          return acc;
        } else {
          return acc + 1;
        }
      }, 0);
      const processWouldExit = userProvidedListenersCount === 0;
      const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;
      if (!caughtFirstError) {
        firstError = error;
        caughtFirstError = true;
        if (getClient() === client) {
          captureException(error, {
            originalException: error,
            captureContext: {
              level: "fatal"
            },
            mechanism: {
              handled: false,
              type: "onuncaughtexception"
            }
          });
        }
        if (!calledFatalError && shouldApplyFatalHandlingLogic) {
          calledFatalError = true;
          onFatalError(error);
        }
      } else {
        if (shouldApplyFatalHandlingLogic) {
          if (calledFatalError) {
            DEBUG_BUILD && logger.warn(
              "uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown"
            );
            logAndExitProcess(error);
          } else if (!caughtSecondError) {
            caughtSecondError = true;
            setTimeout(() => {
              if (!calledFatalError) {
                calledFatalError = true;
                onFatalError(firstError, error);
              }
            }, timeout);
          }
        }
      }
    },
    { _errorHandler: true }
  );
}
export {
  makeErrorHandler,
  onUncaughtExceptionIntegration
};
//# sourceMappingURL=onuncaughtexception.js.map
