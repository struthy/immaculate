{"version":3,"file":"onuncaughtexception.js","sources":["../../../../../../../../node_modules/@sentry/node/esm/integrations/onuncaughtexception.js"],"sourcesContent":["import { defineIntegration, convertIntegrationFnToClass, getClient, captureException } from '@sentry/core';\nimport { logger } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { logAndExitProcess } from './utils/errorhandling.js';\n\nconst INTEGRATION_NAME = 'OnUncaughtException';\n\nconst _onUncaughtExceptionIntegration = ((options = {}) => {\n  const _options = {\n    exitEvenIfOtherHandlersAreRegistered: true,\n    ...options,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    setup(client) {\n      global.process.on('uncaughtException', makeErrorHandler(client, _options));\n    },\n  };\n}) ;\n\nconst onUncaughtExceptionIntegration = defineIntegration(_onUncaughtExceptionIntegration);\n\n/**\n * Global Exception handler.\n * @deprecated Use `onUncaughtExceptionIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst OnUncaughtException = convertIntegrationFnToClass(\n  INTEGRATION_NAME,\n  onUncaughtExceptionIntegration,\n)\n\n;\n\n// eslint-disable-next-line deprecation/deprecation\n\n/** Exported only for tests */\nfunction makeErrorHandler(client, options) {\n  const timeout = 2000;\n  let caughtFirstError = false;\n  let caughtSecondError = false;\n  let calledFatalError = false;\n  let firstError;\n\n  const clientOptions = client.getOptions();\n\n  return Object.assign(\n    (error) => {\n      let onFatalError = logAndExitProcess;\n\n      if (options.onFatalError) {\n        onFatalError = options.onFatalError;\n      } else if (clientOptions.onFatalError) {\n        onFatalError = clientOptions.onFatalError ;\n      }\n\n      // Attaching a listener to `uncaughtException` will prevent the node process from exiting. We generally do not\n      // want to alter this behaviour so we check for other listeners that users may have attached themselves and adjust\n      // exit behaviour of the SDK accordingly:\n      // - If other listeners are attached, do not exit.\n      // - If the only listener attached is ours, exit.\n      const userProvidedListenersCount = (\n        global.process.listeners('uncaughtException')\n      ).reduce((acc, listener) => {\n        if (\n          // There are 3 listeners we ignore:\n          listener.name === 'domainUncaughtExceptionClear' || // as soon as we're using domains this listener is attached by node itself\n          (listener.tag && listener.tag === 'sentry_tracingErrorCallback') || // the handler we register for tracing\n          (listener )._errorHandler // the handler we register in this integration\n        ) {\n          return acc;\n        } else {\n          return acc + 1;\n        }\n      }, 0);\n\n      const processWouldExit = userProvidedListenersCount === 0;\n      const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;\n\n      if (!caughtFirstError) {\n        // this is the first uncaught error and the ultimate reason for shutting down\n        // we want to do absolutely everything possible to ensure it gets captured\n        // also we want to make sure we don't go recursion crazy if more errors happen after this one\n        firstError = error;\n        caughtFirstError = true;\n\n        if (getClient() === client) {\n          captureException(error, {\n            originalException: error,\n            captureContext: {\n              level: 'fatal',\n            },\n            mechanism: {\n              handled: false,\n              type: 'onuncaughtexception',\n            },\n          });\n        }\n\n        if (!calledFatalError && shouldApplyFatalHandlingLogic) {\n          calledFatalError = true;\n          onFatalError(error);\n        }\n      } else {\n        if (shouldApplyFatalHandlingLogic) {\n          if (calledFatalError) {\n            // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n            DEBUG_BUILD &&\n              logger.warn(\n                'uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown',\n              );\n            logAndExitProcess(error);\n          } else if (!caughtSecondError) {\n            // two cases for how we can hit this branch:\n            //   - capturing of first error blew up and we just caught the exception from that\n            //     - quit trying to capture, proceed with shutdown\n            //   - a second independent error happened while waiting for first error to capture\n            //     - want to avoid causing premature shutdown before first error capture finishes\n            // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n            // so let's instead just delay a bit before we proceed with our action here\n            // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n            // in case 2, the delay hopefully made us wait long enough for the capture to finish\n            // two potential nonideal outcomes:\n            //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n            //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n            // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n            //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n            caughtSecondError = true;\n            setTimeout(() => {\n              if (!calledFatalError) {\n                // it was probably case 1, let's treat err as the sendErr and call onFatalError\n                calledFatalError = true;\n                onFatalError(firstError, error);\n              }\n            }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n          }\n        }\n      }\n    },\n    { _errorHandler: true },\n  );\n}\n\nexport { OnUncaughtException, makeErrorHandler, onUncaughtExceptionIntegration };\n//# sourceMappingURL=onuncaughtexception.js.map\n"],"names":[],"mappings":";;;;;AAKA,MAAM,mBAAmB;AAEzB,MAAM,kCAAmC,CAAC,UAAU,OAAO;AACzD,QAAM,WAAW;AAAA,IACf,sCAAsC;AAAA,IACtC,GAAG;AAAA,EACP;AAEE,SAAO;AAAA,IACL,MAAM;AAAA;AAAA,IAEN,YAAY;AAAA,IAAE;AAAA;AAAA,IACd,MAAM,QAAQ;AACZ,aAAO,QAAQ,GAAG,qBAAqB,iBAAiB,QAAQ,QAAQ,CAAC;AAAA,IAC1E;AAAA,EACL;AACA;AAEK,MAAC,iCAAiC,kBAAkB,+BAA+B;AAO5D;AAAA,EAC1B;AAAA,EACA;AACF;AAOA,SAAS,iBAAiB,QAAQ,SAAS;AACzC,QAAM,UAAU;AAChB,MAAI,mBAAmB;AACvB,MAAI,oBAAoB;AACxB,MAAI,mBAAmB;AACvB,MAAI;AAEJ,QAAM,gBAAgB,OAAO;AAE7B,SAAO,OAAO;AAAA,IACZ,CAAC,UAAU;AACT,UAAI,eAAe;AAEnB,UAAI,QAAQ,cAAc;AACxB,uBAAe,QAAQ;AAAA,MAC/B,WAAiB,cAAc,cAAc;AACrC,uBAAe,cAAc;AAAA,MAC9B;AAOD,YAAM,6BACJ,OAAO,QAAQ,UAAU,mBAAmB,EAC5C,OAAO,CAAC,KAAK,aAAa;AAC1B;AAAA;AAAA,UAEE,SAAS,SAAS;AAAA,UACjB,SAAS,OAAO,SAAS,QAAQ;AAAA,UACjC,SAAW;AAAA,UACZ;AACA,iBAAO;AAAA,QACjB,OAAe;AACL,iBAAO,MAAM;AAAA,QACd;AAAA,MACF,GAAE,CAAC;AAEJ,YAAM,mBAAmB,+BAA+B;AACxD,YAAM,gCAAgC,QAAQ,wCAAwC;AAEtF,UAAI,CAAC,kBAAkB;AAIrB,qBAAa;AACb,2BAAmB;AAEnB,YAAI,UAAW,MAAK,QAAQ;AAC1B,2BAAiB,OAAO;AAAA,YACtB,mBAAmB;AAAA,YACnB,gBAAgB;AAAA,cACd,OAAO;AAAA,YACR;AAAA,YACD,WAAW;AAAA,cACT,SAAS;AAAA,cACT,MAAM;AAAA,YACP;AAAA,UACb,CAAW;AAAA,QACF;AAED,YAAI,CAAC,oBAAoB,+BAA+B;AACtD,6BAAmB;AACnB,uBAAa,KAAK;AAAA,QACnB;AAAA,MACT,OAAa;AACL,YAAI,+BAA+B;AACjC,cAAI,kBAAkB;AAEpB,2BACE,OAAO;AAAA,cACL;AAAA,YAChB;AACY,8BAAkB,KAAK;AAAA,UACnC,WAAqB,CAAC,mBAAmB;AAe7B,gCAAoB;AACpB,uBAAW,MAAM;AACf,kBAAI,CAAC,kBAAkB;AAErB,mCAAmB;AACnB,6BAAa,YAAY,KAAK;AAAA,cAC/B;AAAA,YACF,GAAE,OAAO;AAAA,UACX;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACD,EAAE,eAAe,KAAM;AAAA,EAC3B;AACA;","x_google_ignoreList":[0]}