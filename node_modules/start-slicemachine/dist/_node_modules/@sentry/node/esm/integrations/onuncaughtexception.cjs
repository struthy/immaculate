"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const debugBuild = require("../debug-build.cjs");
const errorhandling = require("./utils/errorhandling.cjs");
const integration = require('./../../_node_modules/@sentry/core/esm/integration.cjs');
const exports$1 = require('./../../_node_modules/@sentry/core/esm/exports.cjs');
const logger = require('./../../_node_modules/@sentry/utils/esm/logger.cjs');
const INTEGRATION_NAME = "OnUncaughtException";
const _onUncaughtExceptionIntegration = (options = {}) => {
  const _options = {
    exitEvenIfOtherHandlersAreRegistered: true,
    ...options
  };
  return {
    name: INTEGRATION_NAME,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    setup(client) {
      global.process.on("uncaughtException", makeErrorHandler(client, _options));
    }
  };
};
const onUncaughtExceptionIntegration = integration.defineIntegration(_onUncaughtExceptionIntegration);
integration.convertIntegrationFnToClass(
  INTEGRATION_NAME,
  onUncaughtExceptionIntegration
);
function makeErrorHandler(client, options) {
  const timeout = 2e3;
  let caughtFirstError = false;
  let caughtSecondError = false;
  let calledFatalError = false;
  let firstError;
  const clientOptions = client.getOptions();
  return Object.assign(
    (error) => {
      let onFatalError = errorhandling.logAndExitProcess;
      if (options.onFatalError) {
        onFatalError = options.onFatalError;
      } else if (clientOptions.onFatalError) {
        onFatalError = clientOptions.onFatalError;
      }
      const userProvidedListenersCount = global.process.listeners("uncaughtException").reduce((acc, listener) => {
        if (
          // There are 3 listeners we ignore:
          listener.name === "domainUncaughtExceptionClear" || // as soon as we're using domains this listener is attached by node itself
          listener.tag && listener.tag === "sentry_tracingErrorCallback" || // the handler we register for tracing
          listener._errorHandler
        ) {
          return acc;
        } else {
          return acc + 1;
        }
      }, 0);
      const processWouldExit = userProvidedListenersCount === 0;
      const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;
      if (!caughtFirstError) {
        firstError = error;
        caughtFirstError = true;
        if (exports$1.getClient() === client) {
          exports$1.captureException(error, {
            originalException: error,
            captureContext: {
              level: "fatal"
            },
            mechanism: {
              handled: false,
              type: "onuncaughtexception"
            }
          });
        }
        if (!calledFatalError && shouldApplyFatalHandlingLogic) {
          calledFatalError = true;
          onFatalError(error);
        }
      } else {
        if (shouldApplyFatalHandlingLogic) {
          if (calledFatalError) {
            debugBuild.DEBUG_BUILD && logger.logger.warn(
              "uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown"
            );
            errorhandling.logAndExitProcess(error);
          } else if (!caughtSecondError) {
            caughtSecondError = true;
            setTimeout(() => {
              if (!calledFatalError) {
                calledFatalError = true;
                onFatalError(firstError, error);
              }
            }, timeout);
          }
        }
      }
    },
    { _errorHandler: true }
  );
}
exports.makeErrorHandler = makeErrorHandler;
exports.onUncaughtExceptionIntegration = onUncaughtExceptionIntegration;
//# sourceMappingURL=onuncaughtexception.cjs.map
