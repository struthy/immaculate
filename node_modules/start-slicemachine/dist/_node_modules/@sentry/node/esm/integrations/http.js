import { DEBUG_BUILD } from "../debug-build.js";
import { NODE_VERSION } from "../nodeVersion.js";
import { normalizeRequestArgs, extractRawUrl, extractUrl, cleanSpanDescription } from "./utils/http.js";
import { defineIntegration } from './../../_node_modules/@sentry/core/esm/integration.js';
import { _optionalChain } from './../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js';
import { logger } from './../../_node_modules/@sentry/utils/esm/logger.js';
import { fill, dropUndefinedKeys } from './../../_node_modules/@sentry/utils/esm/object.js';
import { getClient, getCurrentScope, addBreadcrumb } from './../../_node_modules/@sentry/core/esm/exports.js';
import { isSentryRequestUrl } from './../../_node_modules/@sentry/core/esm/utils/isSentryRequestUrl.js';
import { getIsolationScope, getCurrentHub } from './../../_node_modules/@sentry/core/esm/hub.js';
import { getActiveSpan } from './../../_node_modules/@sentry/core/esm/tracing/trace.js';
import { spanToTraceHeader, spanToJSON } from './../../_node_modules/@sentry/core/esm/utils/spanUtils.js';
import { generateSentryTraceHeader } from './../../_node_modules/@sentry/utils/esm/tracing.js';
import { dynamicSamplingContextToSentryBaggageHeader } from './../../_node_modules/@sentry/utils/esm/baggage.js';
import { getDynamicSamplingContextFromSpan, getDynamicSamplingContextFromClient } from './../../_node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.js';
import { setHttpStatus } from './../../_node_modules/@sentry/core/esm/tracing/spanstatus.js';
import { hasTracingEnabled } from './../../_node_modules/@sentry/core/esm/utils/hasTracingEnabled.js';
import { stringMatchesSomePattern } from './../../_node_modules/@sentry/utils/esm/string.js';
import { LRUMap } from './../../_node_modules/@sentry/utils/esm/lru.js';
const _httpIntegration = (options = {}) => {
  const { breadcrumbs, tracing, shouldCreateSpanForRequest } = options;
  const convertedOptions = {
    breadcrumbs,
    tracing: tracing === false ? false : dropUndefinedKeys({
      // If tracing is forced to `true`, we don't want to set `enableIfHasTracingEnabled`
      enableIfHasTracingEnabled: tracing === true ? void 0 : true,
      shouldCreateSpanForRequest
    })
  };
  return new Http(convertedOptions);
};
const httpIntegration = defineIntegration(_httpIntegration);
class Http {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Http";
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line deprecation/deprecation
  __init() {
    this.name = Http.id;
  }
  /**
   * @inheritDoc
   */
  constructor(options = {}) {
    Http.prototype.__init.call(this);
    this._breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
    this._tracing = !options.tracing ? void 0 : options.tracing === true ? {} : options.tracing;
  }
  /**
   * @inheritDoc
   */
  setupOnce(_addGlobalEventProcessor, setupOnceGetCurrentHub) {
    const clientOptions = _optionalChain([setupOnceGetCurrentHub, "call", (_) => _(), "access", (_2) => _2.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
    const shouldCreateSpans = _shouldCreateSpans(this._tracing, clientOptions);
    if (!this._breadcrumbs && !shouldCreateSpans) {
      return;
    }
    if (clientOptions && clientOptions.instrumenter !== "sentry") {
      DEBUG_BUILD && logger.log("HTTP Integration is skipped because of instrumenter configuration.");
      return;
    }
    const shouldCreateSpanForRequest = _getShouldCreateSpanForRequest(shouldCreateSpans, this._tracing, clientOptions);
    const tracePropagationTargets = _optionalChain([clientOptions, "optionalAccess", (_6) => _6.tracePropagationTargets]) || _optionalChain([this, "access", (_7) => _7._tracing, "optionalAccess", (_8) => _8.tracePropagationTargets]);
    const httpModule = require("http");
    const wrappedHttpHandlerMaker = _createWrappedRequestMethodFactory(
      httpModule,
      this._breadcrumbs,
      shouldCreateSpanForRequest,
      tracePropagationTargets
    );
    fill(httpModule, "get", wrappedHttpHandlerMaker);
    fill(httpModule, "request", wrappedHttpHandlerMaker);
    if (NODE_VERSION.major > 8) {
      const httpsModule = require("https");
      const wrappedHttpsHandlerMaker = _createWrappedRequestMethodFactory(
        httpsModule,
        this._breadcrumbs,
        shouldCreateSpanForRequest,
        tracePropagationTargets
      );
      fill(httpsModule, "get", wrappedHttpsHandlerMaker);
      fill(httpsModule, "request", wrappedHttpsHandlerMaker);
    }
  }
}
Http.__initStatic();
function _createWrappedRequestMethodFactory(httpModule, breadcrumbsEnabled, shouldCreateSpanForRequest, tracePropagationTargets) {
  const createSpanUrlMap = new LRUMap(100);
  const headersUrlMap = new LRUMap(100);
  const shouldCreateSpan = (url) => {
    if (shouldCreateSpanForRequest === void 0) {
      return true;
    }
    const cachedDecision = createSpanUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = shouldCreateSpanForRequest(url);
    createSpanUrlMap.set(url, decision);
    return decision;
  };
  const shouldAttachTraceData = (url) => {
    if (tracePropagationTargets === void 0) {
      return true;
    }
    const cachedDecision = headersUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = stringMatchesSomePattern(url, tracePropagationTargets);
    headersUrlMap.set(url, decision);
    return decision;
  };
  function addRequestBreadcrumb(event, requestSpanData, req, res) {
    if (!getCurrentHub().getIntegration(Http)) {
      return;
    }
    addBreadcrumb(
      {
        category: "http",
        data: {
          status_code: res && res.statusCode,
          ...requestSpanData
        },
        type: "http"
      },
      {
        event,
        request: req,
        response: res
      }
    );
  }
  return function wrappedRequestMethodFactory(originalRequestMethod) {
    return function wrappedMethod(...args) {
      const requestArgs = normalizeRequestArgs(httpModule, args);
      const requestOptions = requestArgs[0];
      const rawRequestUrl = extractRawUrl(requestOptions);
      const requestUrl = extractUrl(requestOptions);
      const client = getClient();
      if (isSentryRequestUrl(requestUrl, client)) {
        return originalRequestMethod.apply(httpModule, requestArgs);
      }
      const scope = getCurrentScope();
      const isolationScope = getIsolationScope();
      const parentSpan = getActiveSpan();
      const data = getRequestSpanData(requestUrl, requestOptions);
      const requestSpan = shouldCreateSpan(rawRequestUrl) ? (
        // eslint-disable-next-line deprecation/deprecation
        _optionalChain([parentSpan, "optionalAccess", (_9) => _9.startChild, "call", (_10) => _10({
          op: "http.client",
          origin: "auto.http.node.http",
          description: `${data["http.method"]} ${data.url}`,
          data
        })])
      ) : void 0;
      if (client && shouldAttachTraceData(rawRequestUrl)) {
        const { traceId, spanId, sampled, dsc } = {
          ...isolationScope.getPropagationContext(),
          ...scope.getPropagationContext()
        };
        const sentryTraceHeader = requestSpan ? spanToTraceHeader(requestSpan) : generateSentryTraceHeader(traceId, spanId, sampled);
        const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(
          dsc || (requestSpan ? getDynamicSamplingContextFromSpan(requestSpan) : getDynamicSamplingContextFromClient(traceId, client, scope))
        );
        addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader);
      } else {
        DEBUG_BUILD && logger.log(
          `[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`
        );
      }
      return originalRequestMethod.apply(httpModule, requestArgs).once("response", function(res) {
        const req = this;
        if (breadcrumbsEnabled) {
          addRequestBreadcrumb("response", data, req, res);
        }
        if (requestSpan) {
          if (res.statusCode) {
            setHttpStatus(requestSpan, res.statusCode);
          }
          requestSpan.updateName(
            cleanSpanDescription(spanToJSON(requestSpan).description || "", requestOptions, req) || ""
          );
          requestSpan.end();
        }
      }).once("error", function() {
        const req = this;
        if (breadcrumbsEnabled) {
          addRequestBreadcrumb("error", data, req);
        }
        if (requestSpan) {
          setHttpStatus(requestSpan, 500);
          requestSpan.updateName(
            cleanSpanDescription(spanToJSON(requestSpan).description || "", requestOptions, req) || ""
          );
          requestSpan.end();
        }
      });
    };
  };
}
function addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader) {
  const headers = requestOptions.headers || {};
  if (headers["sentry-trace"]) {
    return;
  }
  DEBUG_BUILD && logger.log(`[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to "${requestUrl}": `);
  requestOptions.headers = {
    ...requestOptions.headers,
    "sentry-trace": sentryTraceHeader,
    // Setting a header to `undefined` will crash in node so we only set the baggage header when it's defined
    ...sentryBaggageHeader && sentryBaggageHeader.length > 0 && { baggage: normalizeBaggageHeader(requestOptions, sentryBaggageHeader) }
  };
}
function getRequestSpanData(requestUrl, requestOptions) {
  const method = requestOptions.method || "GET";
  const data = {
    url: requestUrl,
    "http.method": method
  };
  if (requestOptions.hash) {
    data["http.fragment"] = requestOptions.hash.substring(1);
  }
  if (requestOptions.search) {
    data["http.query"] = requestOptions.search.substring(1);
  }
  return data;
}
function normalizeBaggageHeader(requestOptions, sentryBaggageHeader) {
  if (!requestOptions.headers || !requestOptions.headers.baggage) {
    return sentryBaggageHeader;
  } else if (!sentryBaggageHeader) {
    return requestOptions.headers.baggage;
  } else if (Array.isArray(requestOptions.headers.baggage)) {
    return [...requestOptions.headers.baggage, sentryBaggageHeader];
  }
  return [requestOptions.headers.baggage, sentryBaggageHeader];
}
function _shouldCreateSpans(tracingOptions, clientOptions) {
  return tracingOptions === void 0 ? false : tracingOptions.enableIfHasTracingEnabled ? hasTracingEnabled(clientOptions) : true;
}
function _getShouldCreateSpanForRequest(shouldCreateSpans, tracingOptions, clientOptions) {
  const handler = shouldCreateSpans ? (
    // eslint-disable-next-line deprecation/deprecation
    _optionalChain([tracingOptions, "optionalAccess", (_11) => _11.shouldCreateSpanForRequest]) || _optionalChain([clientOptions, "optionalAccess", (_12) => _12.shouldCreateSpanForRequest])
  ) : () => false;
  return handler;
}
export {
  Http,
  _getShouldCreateSpanForRequest,
  _shouldCreateSpans,
  httpIntegration
};
//# sourceMappingURL=http.js.map
