"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const fs = require("fs");
const integration = require('./../../_node_modules/@sentry/core/esm/integration.cjs');
const _optionalChain = require('./../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.cjs');
const misc = require('./../../_node_modules/@sentry/utils/esm/misc.cjs');
const lru = require('./../../_node_modules/@sentry/utils/esm/lru.cjs');
const FILE_CONTENT_CACHE = new lru.LRUMap(100);
const DEFAULT_LINES_OF_CONTEXT = 7;
const INTEGRATION_NAME = "ContextLines";
function readTextFileAsync(path) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, "utf8", (err, data) => {
      if (err)
        reject(err);
      else
        resolve(data);
    });
  });
}
const _contextLinesIntegration = (options = {}) => {
  const contextLines = options.frameContextLines !== void 0 ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
  return {
    name: INTEGRATION_NAME,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    processEvent(event) {
      return addSourceContext(event, contextLines);
    }
  };
};
const contextLinesIntegration = integration.defineIntegration(_contextLinesIntegration);
integration.convertIntegrationFnToClass(INTEGRATION_NAME, contextLinesIntegration);
async function addSourceContext(event, contextLines) {
  const enqueuedReadSourceFileTasks = {};
  const readSourceFileTasks = [];
  if (contextLines > 0 && _optionalChain._optionalChain([event, "access", (_2) => _2.exception, "optionalAccess", (_3) => _3.values])) {
    for (const exception of event.exception.values) {
      if (!_optionalChain._optionalChain([exception, "access", (_4) => _4.stacktrace, "optionalAccess", (_5) => _5.frames])) {
        continue;
      }
      for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {
        const frame = exception.stacktrace.frames[i];
        if (frame.filename && !enqueuedReadSourceFileTasks[frame.filename] && !FILE_CONTENT_CACHE.get(frame.filename)) {
          readSourceFileTasks.push(_readSourceFile(frame.filename));
          enqueuedReadSourceFileTasks[frame.filename] = 1;
        }
      }
    }
  }
  if (readSourceFileTasks.length > 0) {
    await Promise.all(readSourceFileTasks);
  }
  if (contextLines > 0 && _optionalChain._optionalChain([event, "access", (_6) => _6.exception, "optionalAccess", (_7) => _7.values])) {
    for (const exception of event.exception.values) {
      if (exception.stacktrace && exception.stacktrace.frames) {
        await addSourceContextToFrames(exception.stacktrace.frames, contextLines);
      }
    }
  }
  return event;
}
function addSourceContextToFrames(frames, contextLines) {
  for (const frame of frames) {
    if (frame.filename && frame.context_line === void 0) {
      const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);
      if (sourceFileLines) {
        try {
          misc.addContextToFrame(sourceFileLines, frame, contextLines);
        } catch (e) {
        }
      }
    }
  }
}
async function _readSourceFile(filename) {
  const cachedFile = FILE_CONTENT_CACHE.get(filename);
  if (cachedFile === null) {
    return null;
  }
  if (cachedFile !== void 0) {
    return cachedFile;
  }
  let content = null;
  try {
    const rawFileContents = await readTextFileAsync(filename);
    content = rawFileContents.split("\n");
  } catch (_) {
  }
  FILE_CONTENT_CACHE.set(filename, content);
  return content;
}
exports.contextLinesIntegration = contextLinesIntegration;
//# sourceMappingURL=contextlines.cjs.map
