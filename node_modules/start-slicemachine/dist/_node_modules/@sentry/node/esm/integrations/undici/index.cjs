"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const nodeVersion = require("../../nodeVersion.cjs");
const integration = require('./../../../_node_modules/@sentry/core/esm/integration.cjs');
const lru = require('./../../../_node_modules/@sentry/utils/esm/lru.cjs');
const hasTracingEnabled = require('./../../../_node_modules/@sentry/core/esm/utils/hasTracingEnabled.cjs');
const _optionalChain = require('./../../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.cjs');
const exports$1 = require('./../../../_node_modules/@sentry/core/esm/exports.cjs');
const isSentryRequestUrl = require('./../../../_node_modules/@sentry/core/esm/utils/isSentryRequestUrl.cjs');
const hub = require('./../../../_node_modules/@sentry/core/esm/hub.cjs');
const trace = require('./../../../_node_modules/@sentry/core/esm/tracing/trace.cjs');
const spanUtils = require('./../../../_node_modules/@sentry/core/esm/utils/spanUtils.cjs');
const tracing = require('./../../../_node_modules/@sentry/utils/esm/tracing.cjs');
const baggage = require('./../../../_node_modules/@sentry/utils/esm/baggage.cjs');
const dynamicSamplingContext = require('./../../../_node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.cjs');
const spanstatus = require('./../../../_node_modules/@sentry/core/esm/tracing/spanstatus.cjs');
const url = require('./../../../_node_modules/@sentry/utils/esm/url.cjs');
const string = require('./../../../_node_modules/@sentry/utils/esm/string.cjs');
exports.ChannelName = void 0;
(function(ChannelName) {
  const RequestCreate = "undici:request:create";
  ChannelName["RequestCreate"] = RequestCreate;
  const RequestEnd = "undici:request:headers";
  ChannelName["RequestEnd"] = RequestEnd;
  const RequestError = "undici:request:error";
  ChannelName["RequestError"] = RequestError;
})(exports.ChannelName || (exports.ChannelName = {}));
const _nativeNodeFetchintegration = (options) => {
  return new Undici(options);
};
const nativeNodeFetchintegration = integration.defineIntegration(_nativeNodeFetchintegration);
class Undici {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Undici";
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line deprecation/deprecation
  __init() {
    this.name = Undici.id;
  }
  __init2() {
    this._createSpanUrlMap = new lru.LRUMap(100);
  }
  __init3() {
    this._headersUrlMap = new lru.LRUMap(100);
  }
  constructor(_options = {}) {
    Undici.prototype.__init.call(this);
    Undici.prototype.__init2.call(this);
    Undici.prototype.__init3.call(this);
    Undici.prototype.__init4.call(this);
    Undici.prototype.__init5.call(this);
    Undici.prototype.__init6.call(this);
    this._options = {
      breadcrumbs: _options.breadcrumbs === void 0 ? true : _options.breadcrumbs,
      tracing: _options.tracing,
      shouldCreateSpanForRequest: _options.shouldCreateSpanForRequest
    };
  }
  /**
   * @inheritDoc
   */
  setupOnce(_addGlobalEventProcessor) {
    if (nodeVersion.NODE_VERSION.major < 16) {
      return;
    }
    let ds;
    try {
      ds = require("diagnostics_channel");
    } catch (e) {
    }
    if (!ds || !ds.subscribe) {
      return;
    }
    ds.subscribe(exports.ChannelName.RequestCreate, this._onRequestCreate);
    ds.subscribe(exports.ChannelName.RequestEnd, this._onRequestEnd);
    ds.subscribe(exports.ChannelName.RequestError, this._onRequestError);
  }
  /** Helper that wraps shouldCreateSpanForRequest option */
  _shouldCreateSpan(url2) {
    if (this._options.tracing === false || this._options.tracing === void 0 && !hasTracingEnabled.hasTracingEnabled()) {
      return false;
    }
    if (this._options.shouldCreateSpanForRequest === void 0) {
      return true;
    }
    const cachedDecision = this._createSpanUrlMap.get(url2);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = this._options.shouldCreateSpanForRequest(url2);
    this._createSpanUrlMap.set(url2, decision);
    return decision;
  }
  __init4() {
    this._onRequestCreate = (message) => {
      if (!_optionalChain._optionalChain([exports$1.getClient, "call", (_10) => _10(), "optionalAccess", (_11) => _11.getIntegration, "call", (_12) => _12(Undici)])) {
        return;
      }
      const { request } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      const client = exports$1.getClient();
      if (!client) {
        return;
      }
      if (isSentryRequestUrl.isSentryRequestUrl(stringUrl, client) || request.__sentry_span__ !== void 0) {
        return;
      }
      const clientOptions = client.getOptions();
      const scope = exports$1.getCurrentScope();
      const isolationScope = hub.getIsolationScope();
      const parentSpan = trace.getActiveSpan();
      const span = this._shouldCreateSpan(stringUrl) ? createRequestSpan(parentSpan, request, stringUrl) : void 0;
      if (span) {
        request.__sentry_span__ = span;
      }
      const shouldAttachTraceData = (url2) => {
        if (clientOptions.tracePropagationTargets === void 0) {
          return true;
        }
        const cachedDecision = this._headersUrlMap.get(url2);
        if (cachedDecision !== void 0) {
          return cachedDecision;
        }
        const decision = string.stringMatchesSomePattern(url2, clientOptions.tracePropagationTargets);
        this._headersUrlMap.set(url2, decision);
        return decision;
      };
      if (shouldAttachTraceData(stringUrl)) {
        const { traceId, spanId, sampled, dsc } = {
          ...isolationScope.getPropagationContext(),
          ...scope.getPropagationContext()
        };
        const sentryTraceHeader = span ? spanUtils.spanToTraceHeader(span) : tracing.generateSentryTraceHeader(traceId, spanId, sampled);
        const sentryBaggageHeader = baggage.dynamicSamplingContextToSentryBaggageHeader(
          dsc || (span ? dynamicSamplingContext.getDynamicSamplingContextFromSpan(span) : dynamicSamplingContext.getDynamicSamplingContextFromClient(traceId, client, scope))
        );
        setHeadersOnRequest(request, sentryTraceHeader, sentryBaggageHeader);
      }
    };
  }
  __init5() {
    this._onRequestEnd = (message) => {
      if (!_optionalChain._optionalChain([exports$1.getClient, "call", (_13) => _13(), "optionalAccess", (_14) => _14.getIntegration, "call", (_15) => _15(Undici)])) {
        return;
      }
      const { request, response } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      if (isSentryRequestUrl.isSentryRequestUrl(stringUrl, exports$1.getClient())) {
        return;
      }
      const span = request.__sentry_span__;
      if (span) {
        spanstatus.setHttpStatus(span, response.statusCode);
        span.end();
      }
      if (this._options.breadcrumbs) {
        exports$1.addBreadcrumb(
          {
            category: "http",
            data: {
              method: request.method,
              status_code: response.statusCode,
              url: stringUrl
            },
            type: "http"
          },
          {
            event: "response",
            request,
            response
          }
        );
      }
    };
  }
  __init6() {
    this._onRequestError = (message) => {
      if (!_optionalChain._optionalChain([exports$1.getClient, "call", (_16) => _16(), "optionalAccess", (_17) => _17.getIntegration, "call", (_18) => _18(Undici)])) {
        return;
      }
      const { request } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      if (isSentryRequestUrl.isSentryRequestUrl(stringUrl, exports$1.getClient())) {
        return;
      }
      const span = request.__sentry_span__;
      if (span) {
        span.setStatus("internal_error");
        span.end();
      }
      if (this._options.breadcrumbs) {
        exports$1.addBreadcrumb(
          {
            category: "http",
            data: {
              method: request.method,
              url: stringUrl
            },
            level: "error",
            type: "http"
          },
          {
            event: "error",
            request
          }
        );
      }
    };
  }
}
Undici.__initStatic();
function setHeadersOnRequest(request, sentryTrace, sentryBaggageHeader) {
  let hasSentryHeaders;
  if (Array.isArray(request.headers)) {
    hasSentryHeaders = request.headers.some((headerLine) => headerLine === "sentry-trace");
  } else {
    const headerLines = request.headers.split("\r\n");
    hasSentryHeaders = headerLines.some((headerLine) => headerLine.startsWith("sentry-trace:"));
  }
  if (hasSentryHeaders) {
    return;
  }
  request.addHeader("sentry-trace", sentryTrace);
  if (sentryBaggageHeader) {
    request.addHeader("baggage", sentryBaggageHeader);
  }
}
function createRequestSpan(activeSpan, request, stringUrl) {
  const url$1 = url.parseUrl(stringUrl);
  const method = request.method || "GET";
  const data = {
    "http.method": method
  };
  if (url$1.search) {
    data["http.query"] = url$1.search;
  }
  if (url$1.hash) {
    data["http.fragment"] = url$1.hash;
  }
  return _optionalChain._optionalChain([activeSpan, "optionalAccess", (_19) => _19.startChild, "call", (_20) => _20({
    op: "http.client",
    origin: "auto.http.node.undici",
    description: `${method} ${url.getSanitizedUrlString(url$1)}`,
    data
  })]);
}
exports.Undici = Undici;
exports.nativeNodeFetchintegration = nativeNodeFetchintegration;
//# sourceMappingURL=index.cjs.map
