{"version":3,"file":"http.js","sources":["../../../../../../../../../node_modules/@sentry/node/esm/integrations/utils/http.js"],"sourcesContent":["import { _optionalChain } from '@sentry/utils';\nimport { URL } from 'url';\nimport { NODE_VERSION } from '../../nodeVersion.js';\n\n/**\n * Assembles a URL that's passed to the users to filter on.\n * It can include raw (potentially PII containing) data, which we'll allow users to access to filter\n * but won't include in spans or breadcrumbs.\n *\n * @param requestOptions RequestOptions object containing the component parts for a URL\n * @returns Fully-formed URL\n */\n// TODO (v8): This function should include auth, query and fragment (it's breaking, so we need to wait for v8)\nfunction extractRawUrl(requestOptions) {\n  const { protocol, hostname, port } = parseRequestOptions(requestOptions);\n  const path = requestOptions.path ? requestOptions.path : '/';\n  return `${protocol}//${hostname}${port}${path}`;\n}\n\n/**\n * Assemble a URL to be used for breadcrumbs and spans.\n *\n * @param requestOptions RequestOptions object containing the component parts for a URL\n * @returns Fully-formed URL\n */\nfunction extractUrl(requestOptions) {\n  const { protocol, hostname, port } = parseRequestOptions(requestOptions);\n\n  const path = requestOptions.pathname || '/';\n\n  // always filter authority, see https://develop.sentry.dev/sdk/data-handling/#structuring-data\n  const authority = requestOptions.auth ? redactAuthority(requestOptions.auth) : '';\n\n  return `${protocol}//${authority}${hostname}${port}${path}`;\n}\n\nfunction redactAuthority(auth) {\n  const [user, password] = auth.split(':');\n  return `${user ? '[Filtered]' : ''}:${password ? '[Filtered]' : ''}@`;\n}\n\n/**\n * Handle various edge cases in the span description (for spans representing http(s) requests).\n *\n * @param description current `description` property of the span representing the request\n * @param requestOptions Configuration data for the request\n * @param Request Request object\n *\n * @returns The cleaned description\n */\nfunction cleanSpanDescription(\n  description,\n  requestOptions,\n  request,\n) {\n  // nothing to clean\n  if (!description) {\n    return description;\n  }\n\n  // eslint-disable-next-line prefer-const\n  let [method, requestUrl] = description.split(' ');\n\n  // superagent sticks the protocol in a weird place (we check for host because if both host *and* protocol are missing,\n  // we're likely dealing with an internal route and this doesn't apply)\n  if (requestOptions.host && !requestOptions.protocol) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    requestOptions.protocol = _optionalChain([(request ), 'optionalAccess', _ => _.agent, 'optionalAccess', _2 => _2.protocol]); // worst comes to worst, this is undefined and nothing changes\n    // This URL contains the filtered authority ([filtered]:[filtered]@example.com) but no fragment or query params\n    requestUrl = extractUrl(requestOptions);\n  }\n\n  // internal routes can end up starting with a triple slash rather than a single one\n  if (_optionalChain([requestUrl, 'optionalAccess', _3 => _3.startsWith, 'call', _4 => _4('///')])) {\n    requestUrl = requestUrl.slice(2);\n  }\n\n  return `${method} ${requestUrl}`;\n}\n\n// the node types are missing a few properties which node's `urlToOptions` function spits out\n\n/**\n * Convert a URL object into a RequestOptions object.\n *\n * Copied from Node's internals (where it's used in http(s).request() and http(s).get()), modified only to use the\n * RequestOptions type above.\n *\n * See https://github.com/nodejs/node/blob/master/lib/internal/url.js.\n */\nfunction urlToOptions(url) {\n  const options = {\n    protocol: url.protocol,\n    hostname:\n      typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname || ''}${url.search || ''}`,\n    href: url.href,\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`;\n  }\n  return options;\n}\n\n/**\n * Normalize inputs to `http(s).request()` and `http(s).get()`.\n *\n * Legal inputs to `http(s).request()` and `http(s).get()` can take one of ten forms:\n *     [ RequestOptions | string | URL ],\n *     [ RequestOptions | string | URL, RequestCallback ],\n *     [ string | URL, RequestOptions ], and\n *     [ string | URL, RequestOptions, RequestCallback ].\n *\n * This standardizes to one of two forms: [ RequestOptions ] and [ RequestOptions, RequestCallback ]. A similar thing is\n * done as the first step of `http(s).request()` and `http(s).get()`; this just does it early so that we can interact\n * with the args in a standard way.\n *\n * @param requestArgs The inputs to `http(s).request()` or `http(s).get()`, as an array.\n *\n * @returns Equivalent args of the form [ RequestOptions ] or [ RequestOptions, RequestCallback ].\n */\nfunction normalizeRequestArgs(\n  httpModule,\n  requestArgs,\n) {\n  let callback, requestOptions;\n\n  // pop off the callback, if there is one\n  if (typeof requestArgs[requestArgs.length - 1] === 'function') {\n    callback = requestArgs.pop() ;\n  }\n\n  // create a RequestOptions object of whatever's at index 0\n  if (typeof requestArgs[0] === 'string') {\n    requestOptions = urlToOptions(new URL(requestArgs[0]));\n  } else if (requestArgs[0] instanceof URL) {\n    requestOptions = urlToOptions(requestArgs[0]);\n  } else {\n    requestOptions = requestArgs[0];\n\n    try {\n      const parsed = new URL(\n        requestOptions.path || '',\n        `${requestOptions.protocol || 'http:'}//${requestOptions.hostname}`,\n      );\n      requestOptions = {\n        pathname: parsed.pathname,\n        search: parsed.search,\n        hash: parsed.hash,\n        ...requestOptions,\n      };\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  // if the options were given separately from the URL, fold them in\n  if (requestArgs.length === 2) {\n    requestOptions = { ...requestOptions, ...requestArgs[1] };\n  }\n\n  // Figure out the protocol if it's currently missing\n  if (requestOptions.protocol === undefined) {\n    // Worst case we end up populating protocol with undefined, which it already is\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */\n\n    // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.\n    // Because of that, we cannot rely on `httpModule` to provide us with valid protocol,\n    // as it will always return `http`, even when using `https` module.\n    //\n    // See test/integrations/http.test.ts for more details on Node <=v8 protocol issue.\n    if (NODE_VERSION.major > 8) {\n      requestOptions.protocol =\n        _optionalChain([(_optionalChain([httpModule, 'optionalAccess', _5 => _5.globalAgent]) ), 'optionalAccess', _6 => _6.protocol]) ||\n        _optionalChain([(requestOptions.agent ), 'optionalAccess', _7 => _7.protocol]) ||\n        _optionalChain([(requestOptions._defaultAgent ), 'optionalAccess', _8 => _8.protocol]);\n    } else {\n      requestOptions.protocol =\n        _optionalChain([(requestOptions.agent ), 'optionalAccess', _9 => _9.protocol]) ||\n        _optionalChain([(requestOptions._defaultAgent ), 'optionalAccess', _10 => _10.protocol]) ||\n        _optionalChain([(_optionalChain([httpModule, 'optionalAccess', _11 => _11.globalAgent]) ), 'optionalAccess', _12 => _12.protocol]);\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */\n  }\n\n  // return args in standardized form\n  if (callback) {\n    return [requestOptions, callback];\n  } else {\n    return [requestOptions];\n  }\n}\n\nfunction parseRequestOptions(requestOptions)\n\n {\n  const protocol = requestOptions.protocol || '';\n  const hostname = requestOptions.hostname || requestOptions.host || '';\n  // Don't log standard :80 (http) and :443 (https) ports to reduce the noise\n  // Also don't add port if the hostname already includes a port\n  const port =\n    !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 || /^(.*):(\\d+)$/.test(hostname)\n      ? ''\n      : `:${requestOptions.port}`;\n\n  return { protocol, hostname, port };\n}\n\nexport { cleanSpanDescription, extractRawUrl, extractUrl, normalizeRequestArgs, urlToOptions };\n//# sourceMappingURL=http.js.map\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}