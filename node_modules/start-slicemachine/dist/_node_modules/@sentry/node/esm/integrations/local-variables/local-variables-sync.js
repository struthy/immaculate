import { NODE_VERSION } from "../../nodeVersion.js";
import { createRateLimiter, hashFromStack, hashFrames, functionNamesMatch } from "./common.js";
import { defineIntegration, convertIntegrationFnToClass } from './../../../_node_modules/@sentry/core/esm/integration.js';
import { getClient } from './../../../_node_modules/@sentry/core/esm/exports.js';
import { _optionalChain } from './../../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js';
import { logger } from './../../../_node_modules/@sentry/utils/esm/logger.js';
import { LRUMap } from './../../../_node_modules/@sentry/utils/esm/lru.js';
function createCallbackList(complete) {
  let callbacks = [];
  let completedCalled = false;
  function checkedComplete(result) {
    callbacks = [];
    if (completedCalled) {
      return;
    }
    completedCalled = true;
    complete(result);
  }
  callbacks.push(checkedComplete);
  function add(fn) {
    callbacks.push(fn);
  }
  function next(result) {
    const popped = callbacks.pop() || checkedComplete;
    try {
      popped(result);
    } catch (_) {
      checkedComplete(result);
    }
  }
  return { add, next };
}
class AsyncSession {
  /** Throws if inspector API is not available */
  constructor() {
    const { Session } = require("inspector");
    this._session = new Session();
  }
  /** @inheritdoc */
  configureAndConnect(onPause, captureAll) {
    this._session.connect();
    this._session.on("Debugger.paused", (event) => {
      onPause(event, () => {
        this._session.post("Debugger.resume");
      });
    });
    this._session.post("Debugger.enable");
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  setPauseOnExceptions(captureAll) {
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  /** @inheritdoc */
  getLocalVariables(objectId, complete) {
    this._getProperties(objectId, (props) => {
      const { add, next } = createCallbackList(complete);
      for (const prop of props) {
        if (_optionalChain([prop, "optionalAccess", (_2) => _2.value, "optionalAccess", (_3) => _3.objectId]) && _optionalChain([prop, "optionalAccess", (_4) => _4.value, "access", (_5) => _5.className]) === "Array") {
          const id = prop.value.objectId;
          add((vars) => this._unrollArray(id, prop.name, vars, next));
        } else if (_optionalChain([prop, "optionalAccess", (_6) => _6.value, "optionalAccess", (_7) => _7.objectId]) && _optionalChain([prop, "optionalAccess", (_8) => _8.value, "optionalAccess", (_9) => _9.className]) === "Object") {
          const id = prop.value.objectId;
          add((vars) => this._unrollObject(id, prop.name, vars, next));
        } else if (_optionalChain([prop, "optionalAccess", (_10) => _10.value, "optionalAccess", (_11) => _11.value]) != null || _optionalChain([prop, "optionalAccess", (_12) => _12.value, "optionalAccess", (_13) => _13.description]) != null) {
          add((vars) => this._unrollOther(prop, vars, next));
        }
      }
      next({});
    });
  }
  /**
   * Gets all the PropertyDescriptors of an object
   */
  _getProperties(objectId, next) {
    this._session.post(
      "Runtime.getProperties",
      {
        objectId,
        ownProperties: true
      },
      (err, params) => {
        if (err) {
          next([]);
        } else {
          next(params.result);
        }
      }
    );
  }
  /**
   * Unrolls an array property
   */
  _unrollArray(objectId, name, vars, next) {
    this._getProperties(objectId, (props) => {
      vars[name] = props.filter((v) => v.name !== "length" && !isNaN(parseInt(v.name, 10))).sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10)).map((v) => _optionalChain([v, "optionalAccess", (_14) => _14.value, "optionalAccess", (_15) => _15.value]));
      next(vars);
    });
  }
  /**
   * Unrolls an object property
   */
  _unrollObject(objectId, name, vars, next) {
    this._getProperties(objectId, (props) => {
      vars[name] = props.map((v) => [v.name, _optionalChain([v, "optionalAccess", (_16) => _16.value, "optionalAccess", (_17) => _17.value])]).reduce((obj, [key, val]) => {
        obj[key] = val;
        return obj;
      }, {});
      next(vars);
    });
  }
  /**
   * Unrolls other properties
   */
  _unrollOther(prop, vars, next) {
    if (_optionalChain([prop, "optionalAccess", (_18) => _18.value, "optionalAccess", (_19) => _19.value]) != null) {
      vars[prop.name] = prop.value.value;
    } else if (_optionalChain([prop, "optionalAccess", (_20) => _20.value, "optionalAccess", (_21) => _21.description]) != null && _optionalChain([prop, "optionalAccess", (_22) => _22.value, "optionalAccess", (_23) => _23.type]) !== "function") {
      vars[prop.name] = `<${prop.value.description}>`;
    }
    next(vars);
  }
}
function tryNewAsyncSession() {
  try {
    return new AsyncSession();
  } catch (e) {
    return void 0;
  }
}
const INTEGRATION_NAME = "LocalVariables";
const _localVariablesSyncIntegration = (options = {}, session = tryNewAsyncSession()) => {
  const cachedFrames = new LRUMap(20);
  let rateLimiter;
  let shouldProcessEvent = false;
  function handlePaused(stackParser, { params: { reason, data, callFrames } }, complete) {
    if (reason !== "exception" && reason !== "promiseRejection") {
      complete();
      return;
    }
    _optionalChain([rateLimiter, "optionalCall", (_24) => _24()]);
    const exceptionHash = hashFromStack(stackParser, _optionalChain([data, "optionalAccess", (_25) => _25.description]));
    if (exceptionHash == void 0) {
      complete();
      return;
    }
    const { add, next } = createCallbackList((frames) => {
      cachedFrames.set(exceptionHash, frames);
      complete();
    });
    for (let i = 0; i < Math.min(callFrames.length, 5); i++) {
      const { scopeChain, functionName, this: obj } = callFrames[i];
      const localScope = scopeChain.find((scope) => scope.type === "local");
      const fn = obj.className === "global" || !obj.className ? functionName : `${obj.className}.${functionName}`;
      if (_optionalChain([localScope, "optionalAccess", (_26) => _26.object, "access", (_27) => _27.objectId]) === void 0) {
        add((frames) => {
          frames[i] = { function: fn };
          next(frames);
        });
      } else {
        const id = localScope.object.objectId;
        add(
          (frames) => _optionalChain([session, "optionalAccess", (_28) => _28.getLocalVariables, "call", (_29) => _29(id, (vars) => {
            frames[i] = { function: fn, vars };
            next(frames);
          })])
        );
      }
    }
    next([]);
  }
  function addLocalVariablesToException(exception) {
    const hash = hashFrames(_optionalChain([exception, "optionalAccess", (_30) => _30.stacktrace, "optionalAccess", (_31) => _31.frames]));
    if (hash === void 0) {
      return;
    }
    const cachedFrame = cachedFrames.remove(hash);
    if (cachedFrame === void 0) {
      return;
    }
    const frames = (_optionalChain([exception, "access", (_32) => _32.stacktrace, "optionalAccess", (_33) => _33.frames]) || []).filter((frame) => frame.function !== "new Promise");
    for (let i = 0; i < frames.length; i++) {
      const frameIndex = frames.length - i - 1;
      if (!frames[frameIndex] || !cachedFrame[i]) {
        break;
      }
      if (
        // We need to have vars to add
        cachedFrame[i].vars === void 0 || // We're not interested in frames that are not in_app because the vars are not relevant
        frames[frameIndex].in_app === false || // The function names need to match
        !functionNamesMatch(frames[frameIndex].function, cachedFrame[i].function)
      ) {
        continue;
      }
      frames[frameIndex].vars = cachedFrame[i].vars;
    }
  }
  function addLocalVariablesToEvent(event) {
    for (const exception of _optionalChain([event, "optionalAccess", (_34) => _34.exception, "optionalAccess", (_35) => _35.values]) || []) {
      addLocalVariablesToException(exception);
    }
    return event;
  }
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      const client = getClient();
      const clientOptions = _optionalChain([client, "optionalAccess", (_36) => _36.getOptions, "call", (_37) => _37()]);
      if (session && _optionalChain([clientOptions, "optionalAccess", (_38) => _38.includeLocalVariables])) {
        const unsupportedNodeVersion = NODE_VERSION.major < 18;
        if (unsupportedNodeVersion) {
          logger.log("The `LocalVariables` integration is only supported on Node >= v18.");
          return;
        }
        const captureAll = options.captureAllExceptions !== false;
        session.configureAndConnect(
          (ev, complete) => handlePaused(clientOptions.stackParser, ev, complete),
          captureAll
        );
        if (captureAll) {
          const max = options.maxExceptionsPerSecond || 50;
          rateLimiter = createRateLimiter(
            max,
            () => {
              logger.log("Local variables rate-limit lifted.");
              _optionalChain([session, "optionalAccess", (_39) => _39.setPauseOnExceptions, "call", (_40) => _40(true)]);
            },
            (seconds) => {
              logger.log(
                `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`
              );
              _optionalChain([session, "optionalAccess", (_41) => _41.setPauseOnExceptions, "call", (_42) => _42(false)]);
            }
          );
        }
        shouldProcessEvent = true;
      }
    },
    processEvent(event) {
      if (shouldProcessEvent) {
        return addLocalVariablesToEvent(event);
      }
      return event;
    },
    // These are entirely for testing
    _getCachedFramesCount() {
      return cachedFrames.size;
    },
    _getFirstCachedFrame() {
      return cachedFrames.values()[0];
    }
  };
};
const localVariablesSyncIntegration = defineIntegration(_localVariablesSyncIntegration);
convertIntegrationFnToClass(
  INTEGRATION_NAME,
  localVariablesSyncIntegration
);
export {
  createCallbackList,
  localVariablesSyncIntegration
};
//# sourceMappingURL=local-variables-sync.js.map
