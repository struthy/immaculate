"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const debugBuild = require("../debug-build.cjs");
const nodeVersion = require("../nodeVersion.cjs");
const http = require("./utils/http.cjs");
const integration = require('./../../_node_modules/@sentry/core/esm/integration.cjs');
const _optionalChain = require('./../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.cjs');
const logger = require('./../../_node_modules/@sentry/utils/esm/logger.cjs');
const object = require('./../../_node_modules/@sentry/utils/esm/object.cjs');
const exports$1 = require('./../../_node_modules/@sentry/core/esm/exports.cjs');
const isSentryRequestUrl = require('./../../_node_modules/@sentry/core/esm/utils/isSentryRequestUrl.cjs');
const hub = require('./../../_node_modules/@sentry/core/esm/hub.cjs');
const trace = require('./../../_node_modules/@sentry/core/esm/tracing/trace.cjs');
const spanUtils = require('./../../_node_modules/@sentry/core/esm/utils/spanUtils.cjs');
const tracing = require('./../../_node_modules/@sentry/utils/esm/tracing.cjs');
const baggage = require('./../../_node_modules/@sentry/utils/esm/baggage.cjs');
const dynamicSamplingContext = require('./../../_node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.cjs');
const spanstatus = require('./../../_node_modules/@sentry/core/esm/tracing/spanstatus.cjs');
const hasTracingEnabled = require('./../../_node_modules/@sentry/core/esm/utils/hasTracingEnabled.cjs');
const string = require('./../../_node_modules/@sentry/utils/esm/string.cjs');
const lru = require('./../../_node_modules/@sentry/utils/esm/lru.cjs');
const _httpIntegration = (options = {}) => {
  const { breadcrumbs, tracing: tracing2, shouldCreateSpanForRequest } = options;
  const convertedOptions = {
    breadcrumbs,
    tracing: tracing2 === false ? false : object.dropUndefinedKeys({
      // If tracing is forced to `true`, we don't want to set `enableIfHasTracingEnabled`
      enableIfHasTracingEnabled: tracing2 === true ? void 0 : true,
      shouldCreateSpanForRequest
    })
  };
  return new Http(convertedOptions);
};
const httpIntegration = integration.defineIntegration(_httpIntegration);
class Http {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Http";
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line deprecation/deprecation
  __init() {
    this.name = Http.id;
  }
  /**
   * @inheritDoc
   */
  constructor(options = {}) {
    Http.prototype.__init.call(this);
    this._breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
    this._tracing = !options.tracing ? void 0 : options.tracing === true ? {} : options.tracing;
  }
  /**
   * @inheritDoc
   */
  setupOnce(_addGlobalEventProcessor, setupOnceGetCurrentHub) {
    const clientOptions = _optionalChain._optionalChain([setupOnceGetCurrentHub, "call", (_) => _(), "access", (_2) => _2.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
    const shouldCreateSpans = _shouldCreateSpans(this._tracing, clientOptions);
    if (!this._breadcrumbs && !shouldCreateSpans) {
      return;
    }
    if (clientOptions && clientOptions.instrumenter !== "sentry") {
      debugBuild.DEBUG_BUILD && logger.logger.log("HTTP Integration is skipped because of instrumenter configuration.");
      return;
    }
    const shouldCreateSpanForRequest = _getShouldCreateSpanForRequest(shouldCreateSpans, this._tracing, clientOptions);
    const tracePropagationTargets = _optionalChain._optionalChain([clientOptions, "optionalAccess", (_6) => _6.tracePropagationTargets]) || _optionalChain._optionalChain([this, "access", (_7) => _7._tracing, "optionalAccess", (_8) => _8.tracePropagationTargets]);
    const httpModule = require("http");
    const wrappedHttpHandlerMaker = _createWrappedRequestMethodFactory(
      httpModule,
      this._breadcrumbs,
      shouldCreateSpanForRequest,
      tracePropagationTargets
    );
    object.fill(httpModule, "get", wrappedHttpHandlerMaker);
    object.fill(httpModule, "request", wrappedHttpHandlerMaker);
    if (nodeVersion.NODE_VERSION.major > 8) {
      const httpsModule = require("https");
      const wrappedHttpsHandlerMaker = _createWrappedRequestMethodFactory(
        httpsModule,
        this._breadcrumbs,
        shouldCreateSpanForRequest,
        tracePropagationTargets
      );
      object.fill(httpsModule, "get", wrappedHttpsHandlerMaker);
      object.fill(httpsModule, "request", wrappedHttpsHandlerMaker);
    }
  }
}
Http.__initStatic();
function _createWrappedRequestMethodFactory(httpModule, breadcrumbsEnabled, shouldCreateSpanForRequest, tracePropagationTargets) {
  const createSpanUrlMap = new lru.LRUMap(100);
  const headersUrlMap = new lru.LRUMap(100);
  const shouldCreateSpan = (url) => {
    if (shouldCreateSpanForRequest === void 0) {
      return true;
    }
    const cachedDecision = createSpanUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = shouldCreateSpanForRequest(url);
    createSpanUrlMap.set(url, decision);
    return decision;
  };
  const shouldAttachTraceData = (url) => {
    if (tracePropagationTargets === void 0) {
      return true;
    }
    const cachedDecision = headersUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = string.stringMatchesSomePattern(url, tracePropagationTargets);
    headersUrlMap.set(url, decision);
    return decision;
  };
  function addRequestBreadcrumb(event, requestSpanData, req, res) {
    if (!hub.getCurrentHub().getIntegration(Http)) {
      return;
    }
    exports$1.addBreadcrumb(
      {
        category: "http",
        data: {
          status_code: res && res.statusCode,
          ...requestSpanData
        },
        type: "http"
      },
      {
        event,
        request: req,
        response: res
      }
    );
  }
  return function wrappedRequestMethodFactory(originalRequestMethod) {
    return function wrappedMethod(...args) {
      const requestArgs = http.normalizeRequestArgs(httpModule, args);
      const requestOptions = requestArgs[0];
      const rawRequestUrl = http.extractRawUrl(requestOptions);
      const requestUrl = http.extractUrl(requestOptions);
      const client = exports$1.getClient();
      if (isSentryRequestUrl.isSentryRequestUrl(requestUrl, client)) {
        return originalRequestMethod.apply(httpModule, requestArgs);
      }
      const scope = exports$1.getCurrentScope();
      const isolationScope = hub.getIsolationScope();
      const parentSpan = trace.getActiveSpan();
      const data = getRequestSpanData(requestUrl, requestOptions);
      const requestSpan = shouldCreateSpan(rawRequestUrl) ? (
        // eslint-disable-next-line deprecation/deprecation
        _optionalChain._optionalChain([parentSpan, "optionalAccess", (_9) => _9.startChild, "call", (_10) => _10({
          op: "http.client",
          origin: "auto.http.node.http",
          description: `${data["http.method"]} ${data.url}`,
          data
        })])
      ) : void 0;
      if (client && shouldAttachTraceData(rawRequestUrl)) {
        const { traceId, spanId, sampled, dsc } = {
          ...isolationScope.getPropagationContext(),
          ...scope.getPropagationContext()
        };
        const sentryTraceHeader = requestSpan ? spanUtils.spanToTraceHeader(requestSpan) : tracing.generateSentryTraceHeader(traceId, spanId, sampled);
        const sentryBaggageHeader = baggage.dynamicSamplingContextToSentryBaggageHeader(
          dsc || (requestSpan ? dynamicSamplingContext.getDynamicSamplingContextFromSpan(requestSpan) : dynamicSamplingContext.getDynamicSamplingContextFromClient(traceId, client, scope))
        );
        addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader);
      } else {
        debugBuild.DEBUG_BUILD && logger.logger.log(
          `[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`
        );
      }
      return originalRequestMethod.apply(httpModule, requestArgs).once("response", function(res) {
        const req = this;
        if (breadcrumbsEnabled) {
          addRequestBreadcrumb("response", data, req, res);
        }
        if (requestSpan) {
          if (res.statusCode) {
            spanstatus.setHttpStatus(requestSpan, res.statusCode);
          }
          requestSpan.updateName(
            http.cleanSpanDescription(spanUtils.spanToJSON(requestSpan).description || "", requestOptions, req) || ""
          );
          requestSpan.end();
        }
      }).once("error", function() {
        const req = this;
        if (breadcrumbsEnabled) {
          addRequestBreadcrumb("error", data, req);
        }
        if (requestSpan) {
          spanstatus.setHttpStatus(requestSpan, 500);
          requestSpan.updateName(
            http.cleanSpanDescription(spanUtils.spanToJSON(requestSpan).description || "", requestOptions, req) || ""
          );
          requestSpan.end();
        }
      });
    };
  };
}
function addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader) {
  const headers = requestOptions.headers || {};
  if (headers["sentry-trace"]) {
    return;
  }
  debugBuild.DEBUG_BUILD && logger.logger.log(`[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to "${requestUrl}": `);
  requestOptions.headers = {
    ...requestOptions.headers,
    "sentry-trace": sentryTraceHeader,
    // Setting a header to `undefined` will crash in node so we only set the baggage header when it's defined
    ...sentryBaggageHeader && sentryBaggageHeader.length > 0 && { baggage: normalizeBaggageHeader(requestOptions, sentryBaggageHeader) }
  };
}
function getRequestSpanData(requestUrl, requestOptions) {
  const method = requestOptions.method || "GET";
  const data = {
    url: requestUrl,
    "http.method": method
  };
  if (requestOptions.hash) {
    data["http.fragment"] = requestOptions.hash.substring(1);
  }
  if (requestOptions.search) {
    data["http.query"] = requestOptions.search.substring(1);
  }
  return data;
}
function normalizeBaggageHeader(requestOptions, sentryBaggageHeader) {
  if (!requestOptions.headers || !requestOptions.headers.baggage) {
    return sentryBaggageHeader;
  } else if (!sentryBaggageHeader) {
    return requestOptions.headers.baggage;
  } else if (Array.isArray(requestOptions.headers.baggage)) {
    return [...requestOptions.headers.baggage, sentryBaggageHeader];
  }
  return [requestOptions.headers.baggage, sentryBaggageHeader];
}
function _shouldCreateSpans(tracingOptions, clientOptions) {
  return tracingOptions === void 0 ? false : tracingOptions.enableIfHasTracingEnabled ? hasTracingEnabled.hasTracingEnabled(clientOptions) : true;
}
function _getShouldCreateSpanForRequest(shouldCreateSpans, tracingOptions, clientOptions) {
  const handler = shouldCreateSpans ? (
    // eslint-disable-next-line deprecation/deprecation
    _optionalChain._optionalChain([tracingOptions, "optionalAccess", (_11) => _11.shouldCreateSpanForRequest]) || _optionalChain._optionalChain([clientOptions, "optionalAccess", (_12) => _12.shouldCreateSpanForRequest])
  ) : () => false;
  return handler;
}
exports.Http = Http;
exports._getShouldCreateSpanForRequest = _getShouldCreateSpanForRequest;
exports._shouldCreateSpans = _shouldCreateSpans;
exports.httpIntegration = httpIntegration;
//# sourceMappingURL=http.cjs.map
