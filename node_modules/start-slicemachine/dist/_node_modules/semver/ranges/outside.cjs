"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const semver = require("../classes/semver.cjs");
const comparator = require("../classes/comparator.cjs");
const range = require("../classes/range.cjs");
const satisfies$1 = require("../functions/satisfies.cjs");
const gt$1 = require("../functions/gt.cjs");
const lt$1 = require("../functions/lt.cjs");
const lte$1 = require("../functions/lte.cjs");
const gte$1 = require("../functions/gte.cjs");
const SemVer = semver.semver;
const Comparator = comparator.__require();
const { ANY } = Comparator;
const Range = range.__require();
const satisfies = satisfies$1.satisfies_1;
const gt = gt$1.gt_1;
const lt = lt$1.lt_1;
const lte = lte$1.lte_1;
const gte = gte$1.gte_1;
const outside = (version, range2, hilo, options) => {
  version = new SemVer(version, options);
  range2 = new Range(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies(version, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY) {
        comparator2 = new Comparator(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside;
exports.outside_1 = outside_1;
//# sourceMappingURL=outside.cjs.map
