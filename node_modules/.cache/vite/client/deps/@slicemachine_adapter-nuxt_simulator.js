import {
  defineComponent,
  h,
  onMounted,
  onUnmounted,
  ref
} from "./chunk-2435C5CU.js";
import {
  __commonJS,
  __toESM
} from "./chunk-UV5CTPV7.js";

// node_modules/statuses/codes.json
var require_codes = __commonJS({
  "node_modules/statuses/codes.json"(exports, module) {
    module.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/statuses/index.js
var require_statuses = __commonJS({
  "node_modules/statuses/index.js"(exports, module) {
    "use strict";
    var codes = require_codes();
    module.exports = status;
    status.message = codes;
    status.code = createMessageToStatusCodeMap(codes);
    status.codes = createStatusCodeList(codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map = {};
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        map[message.toLowerCase()] = status2;
      });
      return map;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code) {
        return Number(code);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status.code[msg];
    }
    function getStatusMessage(code) {
      if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
        throw new Error("invalid status code: " + code);
      }
      return status.message[code];
    }
    function status(code) {
      if (typeof code === "number") {
        return getStatusMessage(code);
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        return getStatusMessage(n);
      }
      return getStatusCode(code);
    }
  }
});

// node_modules/@prismicio/simulator/dist/lib/throttle.js
var throttle = (fn, delay = 16) => {
  let lastExec = 0;
  let timer = null;
  return function(...args) {
    const now = Date.now();
    const delta = now - lastExec;
    if (delta >= delay) {
      fn.apply(this, args);
      lastExec = now;
    } else {
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(() => {
        fn.apply(this, args);
        lastExec = Date.now();
      }, delay - delta);
    }
  };
};

// node_modules/@prismicio/simulator/dist/types.js
var APIRequestType;
(function(APIRequestType2) {
  APIRequestType2["SetActiveSlice"] = "setActiveSlice";
  APIRequestType2["SetSliceZoneSize"] = "setSliceZoneSize";
})(APIRequestType || (APIRequestType = {}));
var ClientRequestType;
(function(ClientRequestType2) {
  ClientRequestType2["Ping"] = "ping";
  ClientRequestType2["SetSliceZone"] = "setSliceZone";
  ClientRequestType2["ScrollToSlice"] = "scrollToSlice";
})(ClientRequestType || (ClientRequestType = {}));

// node_modules/@prismicio/simulator/dist/kit/types.js
var StateEventType;
(function(StateEventType2) {
  StateEventType2["Slices"] = "slices";
  StateEventType2["ActiveSlice"] = "activeSlice";
  StateEventType2["Message"] = "message";
})(StateEventType || (StateEventType = {}));

// node_modules/@prismicio/simulator/dist/SimulatorAPI.js
var import_statuses2 = __toESM(require_statuses(), 1);

// node_modules/@prismicio/simulator/dist/channel/types.js
var InternalEmitterRequestType;
(function(InternalEmitterRequestType2) {
  InternalEmitterRequestType2["Connect"] = "connect";
})(InternalEmitterRequestType || (InternalEmitterRequestType = {}));
var InternalReceiverRequestType;
(function(InternalReceiverRequestType2) {
  InternalReceiverRequestType2["Ready"] = "ready";
})(InternalReceiverRequestType || (InternalReceiverRequestType = {}));

// node_modules/@prismicio/simulator/dist/channel/errors.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ResponseError = class extends Error {
  constructor(errorResponse) {
    super(errorResponse.msg);
    __publicField(this, "response");
    this.response = errorResponse;
  }
};
var TooManyConcurrentRequestsError = class extends Error {
  constructor(request) {
    super(`Too many concurrent requests`);
    __publicField(this, "request");
    this.request = request;
  }
};
var RequestTimeoutError = class extends Error {
  constructor(request) {
    super(`Request \`${request.requestID}\` timed out`);
    __publicField(this, "request");
    this.request = request;
  }
};
var NotReadyError = class extends Error {
};
var PortNotSetError = class extends Error {
  constructor() {
    super("Port is not set");
  }
};

// node_modules/@prismicio/simulator/dist/channel/messages.js
var import_statuses = __toESM(require_statuses(), 1);
var requestID = 0;
var createRequestMessage = (type, data, prefix = "") => {
  return {
    requestID: `${prefix}${requestID++}`,
    type,
    data
  };
};
var createSuccessResponseMessage = (requestID2, data, status = 200) => {
  var _a2;
  if (status >= 400) {
    throw new TypeError(`Invalid success status code, expected status to be within \`[100;400[\`, got \`${status}\``);
  }
  return {
    requestID: requestID2,
    status,
    msg: ((_a2 = import_statuses.default.message[status]) == null ? void 0 : _a2.replace(/\.$/, "").toLowerCase()) ?? "",
    data
  };
};
var createErrorResponseMessage = (requestID2, error, status = 400) => {
  var _a2;
  if (status < 400) {
    throw new TypeError(`Invalid error status code, expected status to be within \`[500;600[\`, got \`${status}\``);
  }
  return {
    requestID: requestID2,
    status,
    msg: ((_a2 = import_statuses.default.message[status]) == null ? void 0 : _a2.replace(/\.$/, "").toLowerCase()) ?? "",
    error
  };
};
var validateMessage = (message) => {
  if (typeof message !== "object" || message === null) {
    throw new TypeError(`Invalid message received, expected message to be of type \`object\`, got \`${typeof message}\``);
  } else if (!Object.keys(message).every((key) => ["requestID", "type", "data", "status", "msg", "error"].includes(key))) {
    throw new TypeError(`Invalid message received: ${JSON.stringify(message)}`);
  } else if (typeof message.requestID !== "string") {
    throw new TypeError(`Invalid message received, expected \`message.requestID\` to be of type \`string\`, got \`${typeof message.id}\``);
  }
  return message;
};
var isRequestMessage = (message) => {
  return "type" in message;
};
var isResponseMessage = (message) => {
  return !("type" in message);
};
var isSuccessResponseMessage = (message) => {
  return isResponseMessage(message) && !("error" in message);
};

// node_modules/@prismicio/simulator/dist/channel/ChannelNetwork.js
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var channelNetworkDefaultOptions = {
  debug: false,
  maximumRequestConcurrency: 20,
  defaultTimeout: 5e3,
  requestIDPrefix: "channel-"
};
var ChannelNetwork = class {
  constructor(requestHandlers, options) {
    __publicField2(this, "requestHandlers");
    __publicField2(this, "options");
    __publicField2(this, "_port", null);
    __publicField2(this, "_pendingRequests", /* @__PURE__ */ new Map());
    this.requestHandlers = requestHandlers;
    this.options = { ...channelNetworkDefaultOptions, ...options };
  }
  get port() {
    if (!this._port) {
      throw new PortNotSetError();
    }
    return this._port;
  }
  set port(port) {
    if (this._port) {
      this._port.onmessage = null;
    }
    this._port = port;
    if (this._port) {
      this._port.onmessage = this.onMessage.bind(this);
    }
  }
  createRequestMessage(type, data) {
    return createRequestMessage(type, data, this.options.requestIDPrefix);
  }
  async onMessage(event) {
    if (this.options.debug) {
      console.debug(event.data);
    }
    try {
      const message = validateMessage(event.data);
      if (isRequestMessage(message)) {
        if (!this.requestHandlers[message.type]) {
          this.postResponse(createErrorResponseMessage(message.requestID, void 0, 501));
        } else {
          try {
            const response = await this.requestHandlers[message.type](message, {
              success: createSuccessResponseMessage.bind(this, message.requestID),
              error: createErrorResponseMessage.bind(this, message.requestID)
            });
            this.postResponse(response);
          } catch (error) {
            this.postResponse(createErrorResponseMessage(message.requestID, error, 500));
          }
        }
      } else {
        if (!this._pendingRequests.has(message.requestID)) {
          console.error(`Unknown request ID received in response: ${JSON.stringify(message)}`);
        } else {
          this._pendingRequests.get(message.requestID)(message);
          this._pendingRequests.delete(message.requestID);
        }
      }
    } catch (error) {
      if (error instanceof TypeError) {
        console.warn(error.message);
      } else {
        throw error;
      }
    }
  }
  postRequest(request, postMessage = (request2) => this.port.postMessage(request2), options = {}) {
    if (this.options.debug) {
      console.debug(request);
    }
    if (this._pendingRequests.size >= this.options.maximumRequestConcurrency) {
      throw new TooManyConcurrentRequestsError(request);
    }
    return new Promise((resolve, reject) => {
      const requestTimeout = setTimeout(() => {
        if (this._pendingRequests.has(request.requestID)) {
          this._pendingRequests.delete(request.requestID);
        }
        reject(new RequestTimeoutError(request));
      }, options.timeout || this.options.defaultTimeout);
      this._pendingRequests.set(request.requestID, (response) => {
        clearTimeout(requestTimeout);
        isSuccessResponseMessage(response) ? resolve(response) : reject(new ResponseError(response));
      });
      postMessage(request);
    });
  }
  postResponse(response, postMessage = (response2) => this.port.postMessage(response2)) {
    if (this.options.debug) {
      console.debug(response);
    }
    postMessage(response);
    return response;
  }
};

// node_modules/@prismicio/simulator/dist/channel/ChannelReceiver.js
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => {
  __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var channelReceiverDefaultOptions = {
  readyTimeout: 2e4,
  requestIDPrefix: "receiver-"
};
var ChannelReceiver = class extends ChannelNetwork {
  constructor(requestHandlers, options) {
    super(requestHandlers, { ...channelReceiverDefaultOptions, ...options });
    __publicField3(this, "_ready", false);
    window.addEventListener("message", (event) => {
      this._onPublicMessage(event);
    });
  }
  /**
   * Tells the emitter that receiver is ready
   */
  async ready() {
    if (window.parent === window) {
      throw new Error("Receiver is currently not embedded as an iframe");
    }
    this._ready = false;
    const request = this.createRequestMessage(InternalReceiverRequestType.Ready, void 0);
    const response = await this.postRequest(request, (request2) => {
      window.parent.postMessage(request2, "*");
    }, {
      timeout: this.options.readyTimeout
    });
    this._ready = true;
    return response;
  }
  /**
   * Handles public messages
   */
  _onPublicMessage(event) {
    try {
      const message = validateMessage(event.data);
      if (isRequestMessage(message)) {
        if (this.options.debug) {
          console.debug(event.data);
        }
        switch (message.type) {
          case InternalEmitterRequestType.Connect:
            this.port = event.ports[0];
            const { data } = message;
            this.options = {
              ...this.options,
              ...data,
              // Ensure core options remain the same
              debug: this.options.debug,
              requestIDPrefix: this.options.requestIDPrefix,
              readyTimeout: this.options.readyTimeout
            };
            const response = createSuccessResponseMessage(message.requestID, void 0);
            this.postResponse(response);
            break;
          default:
            this.postResponse(createErrorResponseMessage(message.requestID, void 0), (response2) => {
              event.source.postMessage(response2, event.origin);
            });
            break;
        }
      } else {
        if (!this._ready) {
          this.onMessage(event);
        }
      }
    } catch (error) {
      if (error instanceof TypeError)
        ;
      else {
        throw error;
      }
    }
  }
  postFormattedRequest(type, data, options = {}) {
    if (!this._ready) {
      throw new NotReadyError("Receiver is not ready, use `ChannelReceiver.ready()` first");
    }
    return this.postRequest(this.createRequestMessage(type, data), void 0, options);
  }
};

// node_modules/@prismicio/simulator/dist/SimulatorAPI.js
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => {
  __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a;
var _b;
var simulatorAPIDefaultOptions = {
  requestIDPrefix: "api-",
  activeSliceAPI: false,
  sliceZoneSizeAPI: false
};
var SimulatorAPI = class extends ChannelReceiver {
  constructor(requestHandlers, options) {
    var _a2, _b2;
    const debug = (options == null ? void 0 : options.debug) || /[?&]debug=true/i.test(decodeURIComponent(window.location.search));
    super({
      [ClientRequestType.Ping]: (_req, res) => {
        return res.success("pong");
      },
      ...requestHandlers
    }, {
      ...simulatorAPIDefaultOptions,
      ...options,
      debug
    });
    __publicField4(this, _a, async (data) => {
      return await this.postFormattedRequest(APIRequestType.SetActiveSlice, data);
    });
    __publicField4(this, _b, async (data) => {
      return await this.postFormattedRequest(APIRequestType.SetSliceZoneSize, data);
    });
    if (debug) {
      window.prismic || (window.prismic = {});
      (_a2 = window.prismic).sliceSimulator || (_a2.sliceSimulator = {});
      (_b2 = window.prismic.sliceSimulator).api || (_b2.api = []);
      window.prismic.sliceSimulator.api.push(this);
    }
  }
};
_a = APIRequestType.SetActiveSlice, _b = APIRequestType.SetSliceZoneSize;

// node_modules/@prismicio/simulator/dist/kit/SimulatorManager.js
var import_statuses3 = __toESM(require_statuses(), 1);

// node_modules/@prismicio/simulator/dist/lib/EventEmitter.js
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var EventEmitter = class {
  constructor() {
    __publicField5(this, "_listeners", {});
  }
  on(event, listener, key = null) {
    this._listeners[event] = [
      ...this._listeners[event] ?? [],
      [listener, key]
    ];
  }
  off(event, listenerOrKey) {
    this._listeners[event] = (this._listeners[event] ?? []).filter(([listener, key]) => typeof listenerOrKey === "function" ? listener !== listenerOrKey : key !== listenerOrKey);
  }
  emit(event, payload) {
    (this._listeners[event] ?? []).forEach((listener) => listener[0](payload));
  }
};

// node_modules/@prismicio/simulator/dist/kit/domHelpers.js
var simulatorClass = "slice-simulator";
var simulatorRootClass = "slice-simulator--root";
var getSimulatorDOM = () => {
  return document.querySelector(`.${simulatorClass}`);
};
var getSimulatorRootDOM = () => {
  return document.querySelector(`.${simulatorRootClass}`);
};
var getSliceZoneDOM = (expectedNumberOfChildren) => {
  let node = document.querySelector(`.${simulatorClass} [data-slice-zone]`);
  if (node) {
    if (node.children.length !== expectedNumberOfChildren) {
      console.warn(`Flagged SliceZone has an unexpected number of children, found ${node.children.length} but expected ${expectedNumberOfChildren}. This might lead to unexpected behaviors. Are you sure you tagged the right element?`);
    }
    return node;
  }
  node = document.querySelector(`.${simulatorClass} .${simulatorRootClass}`);
  if (!node) {
    return null;
  }
  const searchDepth = 5;
  for (let i = 0; i < searchDepth; i++) {
    if (node.children.length === expectedNumberOfChildren) {
      return node;
    } else if (node.children.length) {
      node = node.children[0];
    } else {
      break;
    }
  }
  return null;
};
var getActiveSliceDOM = ($sliceZone, mouse) => {
  const raycast = document.elementsFromPoint(mouse.x, mouse.y).reverse();
  const sliceZoneIndex = raycast.indexOf($sliceZone);
  if (sliceZoneIndex === -1) {
    return null;
  }
  const $slice = raycast[sliceZoneIndex + 1];
  if (!$slice) {
    return null;
  }
  return $slice;
};

// node_modules/@prismicio/simulator/dist/kit/getDefault.js
var getDefaultProps = () => ({
  zIndex: 100,
  background: "#ffffff"
});
var getDefaultSlices = () => {
  return [];
};
var getDefaultMessage = () => {
  return "";
};

// node_modules/@prismicio/simulator/dist/kit/State.js
var __defProp6 = Object.defineProperty;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField6 = (obj, key, value) => {
  __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var State = class extends EventEmitter {
  constructor(args) {
    super();
    __publicField6(this, "_slices");
    __publicField6(this, "_activeSlice");
    __publicField6(this, "_message");
    __publicField6(this, "_mouse");
    __publicField6(this, "_setActiveSlice", () => {
      if (this.slices.length === 0) {
        this.activeSlice = null;
        return;
      }
      const $sliceZone = getSliceZoneDOM(this.slices.length);
      if (!$sliceZone) {
        this.activeSlice = null;
        return;
      }
      const $activeSlice = getActiveSliceDOM($sliceZone, this._mouse);
      if (!$activeSlice) {
        this.activeSlice = null;
        return;
      }
      const activeSliceIndex = Array.prototype.indexOf.call($sliceZone.children, $activeSlice);
      this.activeSlice = {
        rect: $activeSlice.getBoundingClientRect(),
        sliceID: this.slices[activeSliceIndex].slice_type,
        variationID: this.slices[activeSliceIndex].variation,
        index: activeSliceIndex
      };
    });
    __publicField6(this, "setActiveSlice", throttle(this._setActiveSlice, 16));
    this._slices = (args == null ? void 0 : args.slices) || getDefaultSlices();
    this._activeSlice = null;
    this._message = "";
    this._mouse = { x: 0, y: 0 };
  }
  set slices(slices) {
    this._slices = slices;
    this.message = "";
    this.emit(StateEventType.Slices, slices);
  }
  get slices() {
    return this._slices;
  }
  set activeSlice(activeSlice) {
    this._activeSlice = activeSlice;
    this.emit(StateEventType.ActiveSlice, activeSlice);
  }
  get activeSlice() {
    return this._activeSlice;
  }
  set message(message) {
    this._message = message;
    this.emit(StateEventType.Message, message);
  }
  get message() {
    return this._message;
  }
  async init() {
    window.addEventListener("mousemove", (event) => {
      this._mouse = { x: event.clientX, y: event.clientY };
    });
  }
  setSliceZone(slices) {
    this.slices = slices;
  }
};

// node_modules/@prismicio/simulator/dist/kit/messages.js
var div = (content) => `<div style="word-spacing: initial; white-space: pre; line-height: initial; font-family: monospace; color: #ffffff; mix-blend-mode: difference; padding: 1rem; font-size: 1rem;">${content}</div>`;
var a = (href, label) => `<a href="${href}" style="text-decoration: underline;">${label || href}<a>`;
var header = "   _____ ___          _____ _                 __      __            \n  / ___// (_)_______ / ___/(_)___ ___  __  __/ /___ _/ /_____  _____\n  \\__ \\/ / / ___/ _ \\\\__ \\/ / __ `__ \\/ / / / / __ `/ __/ __ \\/ ___/\n ___/ / / / /__/  __/__/ / / / / / / / /_/ / / /_/ / /_/ /_/ / /    \n/____/_/_/\\___/\\___/____/_/_/ /_/ /_/\\__,_/_/\\__,_/\\__/\\____/_/     \n                  / /_  __  __   / __ \\_____(_)________ ___  (_)____\n                 / __ \\/ / / /  / /_/ / ___/ / ___/ __ `__ \\/ / ___/\n                / /_/ / /_/ /  / ____/ /  / (__  ) / / / / / / /__  \n               /_.___/\\__, /  /_/   /_/  /_/____/_/ /_/ /_/_/\\___/  \n                     /____/\n\n";
var footer = "\n\n\n\n\n\n                                                - The Prismic team";
var sliceSimulatorAccessedDirectly = div([
  header,
  `You're seeing this page because you're accessing Slice simulator
directly, e.g:

  - ${a("http://localhost:3000/slice-simulator")}



The Slice simulator can only be accessed through Slice Machine or the
Page Builder. To preview your Slices, head over to Slice Machine:

  - ${a("http://localhost:9999")}



If you believe this is an error, please reach out to us:

  - ${a("https://github.com/prismicio/slice-machine/issues/new/choose")}`,
  footer
].join(""));

// node_modules/@prismicio/simulator/dist/kit/SimulatorManager.js
var __defProp7 = Object.defineProperty;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField7 = (obj, key, value) => {
  __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var SimulatorManager = class {
  constructor(args) {
    __publicField7(this, "state");
    __publicField7(this, "_api");
    __publicField7(this, "_initialized");
    this.state = new State(args);
    this._api = null;
    this._initialized = false;
  }
  async init() {
    if (this._initialized) {
      return;
    } else {
      this._initialized = true;
    }
    await this.state.init();
    try {
      await this._initAPI();
    } catch (error) {
      if (error instanceof Error && error.message === "Receiver is currently not embedded as an iframe" && !this.state.slices.length) {
        this.state.message = sliceSimulatorAccessedDirectly;
      }
      console.error(error);
      return;
    }
    this._initListeners();
  }
  async _initAPI() {
    this._api = new SimulatorAPI({
      [ClientRequestType.SetSliceZone]: (req, res) => {
        this.state.setSliceZone(req.data);
        return res.success();
      },
      [ClientRequestType.ScrollToSlice]: (req, res) => {
        var _a2;
        if (req.data.sliceIndex < 0) {
          return res.error("`sliceIndex` must be > 0", 400);
        } else if (req.data.sliceIndex >= this.state.slices.length) {
          return res.error(`\`sliceIndex\` must be < ${this.state.slices.length} (\`<SliceZone />\` current length)`, 400);
        }
        const $sliceZone = getSliceZoneDOM(this.state.slices.length);
        if (!$sliceZone) {
          return res.error("Failed to find `<SliceZone />`", 500);
        }
        this.state.activeSlice = null;
        const $slice = $sliceZone.children[req.data.sliceIndex];
        if (!$slice) {
          return res.error(`Failed fo find slice at index $\`{req.data.sliceIndex}\` in \`<SliceZone />\``, 500);
        }
        $slice.scrollIntoView({
          behavior: req.data.behavior,
          block: req.data.block,
          inline: req.data.inline
        });
        ((_a2 = this._api) == null ? void 0 : _a2.options.activeSliceAPI) && setTimeout(this.state.setActiveSlice, 750);
        return res.success();
      }
    });
    await this._api.ready();
  }
  _initListeners() {
    var _a2, _b2;
    if ((_a2 = this._api) == null ? void 0 : _a2.options.activeSliceAPI) {
      window.addEventListener("mousemove", () => {
        this.state.setActiveSlice();
      });
      window.addEventListener("resize", () => {
        this.state.setActiveSlice();
      });
      window.addEventListener("mousewheel", () => {
        setTimeout(this.state.setActiveSlice, 200);
      });
      this.state.on(StateEventType.Slices, () => {
        this.state.setActiveSlice();
      });
      this.state.on(StateEventType.ActiveSlice, async (activeSlice) => {
        if (this._api) {
          try {
            await this._api.setActiveSlice(activeSlice);
          } catch (error) {
            if (error instanceof ResponseError && error.response.status === 400) {
              console.error(error.response);
            } else {
              throw error;
            }
          }
        }
      });
    }
    if ((_b2 = this._api) == null ? void 0 : _b2.options.sliceZoneSizeAPI) {
      const resizeObserver = new ResizeObserver(throttle(async (entries) => {
        const [entry] = entries;
        if (this._api && entry) {
          try {
            await this._api.setSliceZoneSize({ rect: entry.contentRect });
          } catch (error) {
            if (error instanceof ResponseError && error.response.status === 400) {
              console.error(error.response);
            } else {
              throw error;
            }
          }
        }
      }, 16));
      const observeSimulatorRoot = () => {
        const simulatorRootDOM = getSimulatorRootDOM();
        resizeObserver.disconnect();
        if (simulatorRootDOM) {
          resizeObserver.observe(simulatorRootDOM);
        }
      };
      const mutationObserver = new MutationObserver(observeSimulatorRoot);
      mutationObserver.observe(getSimulatorDOM(), {
        subtree: false,
        childList: true
      });
    }
  }
};

// node_modules/@prismicio/simulator/dist/kit/eventHandlers.js
var disableEventHandler = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
var onClickHandler = (event) => {
  if (event.path && event.path.slice(0, 5).some((el) => el instanceof HTMLAnchorElement)) {
    event.preventDefault();
    event.stopPropagation();
  }
};

// node_modules/@slicemachine/adapter-nuxt/dist/simulator/SliceSimulator.js
var simulatorManager = new SimulatorManager();
var SliceSimulatorImpl = defineComponent({
  name: "SliceSimulator",
  props: {
    zIndex: {
      type: Number,
      default: getDefaultProps().zIndex,
      required: false
    },
    background: {
      type: String,
      default: getDefaultProps().background,
      required: false
    }
  },
  setup(props, { slots }) {
    const slices = ref(getDefaultSlices());
    const message = ref(getDefaultMessage());
    onMounted(() => {
      simulatorManager.state.on(StateEventType.Slices, (_slices) => {
        slices.value = _slices;
      }, "simulator-slices");
      simulatorManager.state.on(StateEventType.Message, (_message) => {
        message.value = _message;
      }, "simulator-message");
      simulatorManager.init();
    });
    onUnmounted(() => {
      simulatorManager.state.off(StateEventType.Slices, "simulator-slices");
      simulatorManager.state.off(StateEventType.Message, "simulator-message");
    });
    return () => {
      const children = [];
      if (message.value) {
        children.push(h("article", {
          innerHTML: message.value
        }));
      } else if (slices.value.length && slots.default) {
        children.push(h("div", {
          id: "root",
          class: simulatorRootClass,
          onClickCapture: onClickHandler,
          onSubmitCapture: disableEventHandler
        }, [
          slots.default({
            slices: slices.value
          })
        ]));
      }
      return h("div", {
        class: simulatorClass,
        style: {
          zIndex: props.zIndex,
          position: "fixed",
          top: 0,
          left: 0,
          width: "100%",
          height: "100vh",
          overflow: "auto",
          background: props.background
        }
      }, children);
    };
  }
});
var SliceSimulator = SliceSimulatorImpl;
export {
  SliceSimulator
};
/*! Bundled license information:

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=@slicemachine_adapter-nuxt_simulator.js.map
