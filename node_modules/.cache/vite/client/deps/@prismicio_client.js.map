{
  "version": 3,
  "sources": ["../../../../@prismicio/src/types/value/richText.ts", "../../../../@prismicio/src/helpers/mapSliceZone.ts", "../../../../@prismicio/src/filter.ts", "../../../../@prismicio/src/lib/castArray.ts", "../../../../@prismicio/src/lib/appendFilters.ts", "../../../../@prismicio/src/lib/castThunk.ts", "../../../../@prismicio/client/dist/package.json.js", "../../../../@prismicio/src/lib/devMsg.ts", "../../../../@prismicio/src/lib/everyTagFilter.ts", "../../../../@prismicio/src/errors/PrismicError.ts", "../../../../@prismicio/src/lib/findRef.ts", "../../../../@prismicio/src/lib/findMasterRef.ts", "../../../../@prismicio/src/lib/findRefByID.ts", "../../../../@prismicio/src/lib/findRefByLabel.ts", "../../../../@prismicio/src/cookie.ts", "../../../../@prismicio/src/lib/getPreviewCookie.ts", "../../../../@prismicio/src/lib/minifyGraphQLQuery.ts", "../../../../@prismicio/src/lib/someTagsFilter.ts", "../../../../@prismicio/src/lib/typeFilter.ts", "../../../../@prismicio/src/errors/ForbiddenError.ts", "../../../../@prismicio/src/errors/NotFoundError.ts", "../../../../@prismicio/src/errors/ParsingError.ts", "../../../../@prismicio/src/errors/PreviewTokenExpired.ts", "../../../../@prismicio/src/errors/RefExpiredError.ts", "../../../../@prismicio/src/errors/RefNotFoundError.ts", "../../../../@prismicio/src/errors/RepositoryNotFoundError.ts", "../../../../@prismicio/src/types/value/link.ts", "../../../../@prismicio/src/helpers/documentToLinkField.ts", "../../../../@prismicio/src/helpers/asLink.ts", "../../../../@prismicio/src/buildQueryURL.ts", "../../../../@prismicio/src/isRepositoryName.ts", "../../../../@prismicio/src/getRepositoryEndpoint.ts", "../../../../@prismicio/src/getRepositoryName.ts", "../../../../@prismicio/src/isRepositoryEndpoint.ts", "../../../../@prismicio/src/createClient.ts", "../../../../@prismicio/src/getGraphQLEndpoint.ts", "../../../../@prismicio/src/getToolbarSrc.ts", "../../../../@prismicio/src/helpers/asDate.ts", "../../../../@prismicio/src/lib/isInternalURL.ts", "../../../../@prismicio/src/helpers/isFilled.ts", "../../../../@prismicio/src/helpers/asLinkAttrs.ts", "../../../../@prismicio/src/richtext/asText.ts", "../../../../@prismicio/src/helpers/asText.ts", "../../../../@prismicio/src/lib/escapeHTML.ts", "../../../../@prismicio/src/lib/serializerHelpers.ts", "../../../../@prismicio/src/richtext/asTree.ts", "../../../../@prismicio/src/richtext/serialize.ts", "../../../../@prismicio/src/richtext/types.ts", "../../../../@prismicio/src/richtext/wrapMapSerializer.ts", "../../../../@prismicio/src/richtext/composeSerializers.ts", "../../../../@prismicio/src/helpers/asHTML.ts", "../../../../imgix-url-builder/src/buildURL.ts", "../../../../imgix-url-builder/src/buildPixelDensitySrcSet.ts", "../../../../imgix-url-builder/src/buildWidthSrcSet.ts", "../../../../imgix-url-builder/src/Client.ts", "../../../../@prismicio/src/helpers/asImageSrc.ts", "../../../../@prismicio/src/helpers/asImageWidthSrcSet.ts", "../../../../@prismicio/src/helpers/asImagePixelDensitySrcSet.ts", "../../../../@prismicio/src/types/value/embed.ts", "../../../../@prismicio/src/types/model/types.ts", "../../../../@prismicio/src/types/model/link.ts", "../../../../@prismicio/src/types/model/sliceZone.ts", "../../../../@prismicio/src/types/model/slice.ts", "../../../../@prismicio/src/types/webhook/types.ts", "../../../../@prismicio/src/index.ts"],
  "sourcesContent": ["import type { FieldState } from \"./types\";\n\nimport type { FilledContentRelationshipField } from \"./contentRelationship\";\nimport type { EmbedField } from \"./embed\";\nimport type { FilledLinkToWebField } from \"./link\";\nimport type { FilledLinkToMediaField } from \"./linkToMedia\";\n\n/**\n * Types for RichTextNodes\n *\n * @see More details: {@link https://prismic.io/docs/rich-text-title}\n */\nexport const RichTextNodeType = {\n\theading1: \"heading1\",\n\theading2: \"heading2\",\n\theading3: \"heading3\",\n\theading4: \"heading4\",\n\theading5: \"heading5\",\n\theading6: \"heading6\",\n\tparagraph: \"paragraph\",\n\tpreformatted: \"preformatted\",\n\tstrong: \"strong\",\n\tem: \"em\",\n\tlistItem: \"list-item\",\n\toListItem: \"o-list-item\",\n\tlist: \"group-list-item\",\n\toList: \"group-o-list-item\",\n\timage: \"image\",\n\tembed: \"embed\",\n\thyperlink: \"hyperlink\",\n\tlabel: \"label\",\n\tspan: \"span\",\n} as const;\n\n// Text nodes\n\n/**\n * Base to be extended by other rich text nodes.\n */\nexport interface RTTextNodeBase {\n\ttext: string;\n\tspans: RTInlineNode[];\n}\n\n/**\n * Rich text `heading1` node\n */\nexport interface RTHeading1Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading1;\n}\n\n/**\n * Rich text `heading2` node\n */\nexport interface RTHeading2Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading2;\n}\n\n/**\n * Rich text `heading3` node\n */\nexport interface RTHeading3Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading3;\n}\n\n/**\n * Rich text `heading4` node\n */\nexport interface RTHeading4Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading4;\n}\n\n/**\n * Rich text `heading5` node\n */\nexport interface RTHeading5Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading5;\n}\n\n/**\n * Rich text `heading6` node\n */\nexport interface RTHeading6Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading6;\n}\n\n/**\n * Rich text `paragraph` node\n */\nexport interface RTParagraphNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.paragraph;\n}\n\n/**\n * Rich text `preformatted` node\n */\nexport interface RTPreformattedNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.preformatted;\n}\n\n/**\n * Rich text `list-item` node\n */\nexport interface RTListItemNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.listItem;\n}\n\n/**\n * Rich text `o-list-item` node for ordered lists\n */\nexport interface RTOListItemNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.oListItem;\n}\n\n// Span nodes\n\n/**\n * @internal Span Node base to be extended for other Span nodes\n */\nexport interface RTSpanNodeBase {\n\tstart: number;\n\tend: number;\n}\n/**\n * Rich text `strong` node\n */\nexport interface RTStrongNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.strong;\n}\n\n/**\n * Rich text `embed` node\n */\nexport interface RTEmNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.em;\n}\n\n/**\n * Rich text `label` node\n */\nexport interface RTLabelNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.label;\n\tdata: {\n\t\tlabel: string;\n\t};\n}\n\n// Media nodes\n\n/**\n * Rich text `image` nodes. They could link to other documents, external web\n * links and media fields\n */\nexport type RTImageNode = {\n\ttype: typeof RichTextNodeType.image;\n\tid: string;\n\turl: string;\n\talt: string | null;\n\tcopyright: string | null;\n\tdimensions: {\n\t\twidth: number;\n\t\theight: number;\n\t};\n\tedit: {\n\t\tx: number;\n\t\ty: number;\n\t\tzoom: number;\n\t\tbackground: string;\n\t};\n\tlinkTo?:\n\t\t| FilledContentRelationshipField\n\t\t| FilledLinkToWebField\n\t\t| FilledLinkToMediaField;\n};\n\n/**\n * Rich text `embed` node\n */\nexport type RTEmbedNode = {\n\ttype: typeof RichTextNodeType.embed;\n\toembed: EmbedField;\n};\n\n// Link nodes\n\n/**\n * Rich text `a` node\n *\n * @see More details: {@link https://prismic.io/docs/rich-text-title#elements-and-styles}\n */\nexport interface RTLinkNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.hyperlink;\n\tdata:\n\t\t| FilledContentRelationshipField\n\t\t| FilledLinkToWebField\n\t\t| FilledLinkToMediaField;\n}\n\n// Serialization related nodes\n\n/**\n * Rich text `list` node\n */\nexport interface RTListNode {\n\ttype: typeof RichTextNodeType.list;\n\titems: RTListItemNode[];\n}\n\n/**\n * Rich text o-lost node\n */\nexport interface RTOListNode {\n\ttype: typeof RichTextNodeType.oList;\n\titems: RTOListItemNode[];\n}\n\n// This one is confusing but it's actually the inner content of a block\n/**\n * Rich text `span` node\n */\nexport interface RTSpanNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.span;\n}\n\n// Helpers\n\n/**\n * Nodes from a rich text field\n */\nexport type RTNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode\n\t| RTImageNode\n\t| RTEmbedNode;\n\n/**\n * Rich text nodes with text\n */\nexport type RTTextNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode;\n\n/**\n * Rich text block nodes\n */\nexport type RTBlockNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode\n\t| RTListNode\n\t| RTOListNode\n\t| RTImageNode\n\t| RTEmbedNode;\n\n/**\n * Inline rich text nodes\n */\nexport type RTInlineNode = RTStrongNode | RTEmNode | RTLabelNode | RTLinkNode;\n\n/**\n * All rich text nodes\n */\nexport type RTAnyNode = RTBlockNode | RTInlineNode | RTSpanNode;\n\n/**\n * A rich text field.\n *\n * @see Rich text field documentation: {@link https://prismic.io/docs/rich-text-title}\n */\nexport type RichTextField<State extends FieldState = FieldState> =\n\tState extends \"empty\" ? [] : [RTNode, ...RTNode[]];\n", "import { Slice } from \"../types/value/slice\";\n\n/**\n * Convert a value to a lazyily loaded module. This is useful when using\n * functions like `() => import(\"...\")`.\n */\ntype LazyModule<T> = () => Promise<T | { default: T }>;\n\n/**\n * Mark a type as potentially lazy-loaded via a module.\n */\ntype MaybeLazyModule<T> = T | LazyModule<T>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyFunction = (...args: any[]) => any;\n\n/**\n * Returns the type of a `SliceLike` type.\n *\n * @typeParam Slice - The Slice from which the type will be extracted.\n */\ntype ExtractSliceType<TSlice extends SliceLike> = TSlice extends SliceLikeRestV2\n\t? TSlice[\"slice_type\"]\n\t: TSlice extends SliceLikeGraphQL\n\t? TSlice[\"type\"]\n\t: never;\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * Rest API V2 for the `mapSliceZone()` helper.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceLikeRestV2<TSliceType extends string = string> = Pick<\n\tSlice<TSliceType>,\n\t\"id\" | \"slice_type\"\n>;\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * GraphQL API for the `mapSliceZone()` helper.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceLikeGraphQL<TSliceType extends string = string> = {\n\ttype: Slice<TSliceType>[\"slice_type\"];\n};\n\n/**\n * The minimum required properties to represent a Prismic Slice for the\n * `mapSliceZone()` helper.\n *\n * If using Prismic's Rest API V2, use the `Slice` export from\n * `@prismicio/client` for a full interface.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceLike<TSliceType extends string = string> =\n\t| SliceLikeRestV2<TSliceType>\n\t| SliceLikeGraphQL<TSliceType>;\n\n/**\n * A looser version of the `SliceZone` type from `@prismicio/client` using\n * `SliceLike`.\n *\n * If using Prismic's Rest API V2, use the `SliceZone` export from\n * `@prismicio/client` for the full type.\n *\n * @typeParam TSlice - The type(s) of a Slice in the Slice Zone.\n */\ntype SliceZoneLike<TSlice extends SliceLike = SliceLike> = readonly TSlice[];\n\n/**\n * A set of properties that identify a Slice as having been mapped. Consumers of\n * the mapped Slice Zone can use these properties to detect and specially handle\n * mapped Slices.\n */\ntype MappedSliceLike = {\n\t/**\n\t * If `true`, this Slice has been modified from its original value using a\n\t * mapper.\n\t *\n\t * @internal\n\t */\n\t__mapped: true;\n};\n\n/**\n * Arguments for a function mapping content from a Prismic Slice using the\n * `mapSliceZone()` helper.\n *\n * @typeParam TSlice - The Slice passed as a prop.\n * @typeParam TContext - Arbitrary data passed to `mapSliceZone()` and made\n *   available to all Slice mappers.\n */\ntype SliceMapperArgs<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> = {\n\t/**\n\t * Slice data.\n\t */\n\tslice: TSlice;\n\n\t/**\n\t * The index of the Slice in the Slice Zone.\n\t */\n\tindex: number;\n\n\t/**\n\t * All Slices from the Slice Zone to which the Slice belongs.\n\t */\n\t// TODO: We have to keep this list of Slices general due to circular\n\t// reference limtiations. If we had another generic to determine the full\n\t// union of Slice types, it would include TSlice. This causes TypeScript to\n\t// throw a compilation error.\n\tslices: SliceZoneLike<\n\t\tTSlice extends SliceLikeGraphQL ? SliceLikeGraphQL : SliceLikeRestV2\n\t>;\n\n\t/**\n\t * Arbitrary data passed to `mapSliceZone()` and made available to all Slice\n\t * mappers.\n\t */\n\tcontext: TContext;\n};\n\n/**\n * A record of mappers.\n */\ntype SliceMappers<TSlice extends SliceLike = SliceLike, TContext = unknown> = {\n\t[P in ExtractSliceType<TSlice>]?: MaybeLazyModule<\n\t\tSliceMapper<\n\t\t\tExtract<TSlice, SliceLike<P>>,\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tany,\n\t\t\tTContext\n\t\t>\n\t>;\n};\n\n/**\n * A function that maps a Slice and its metadata to a modified version. The\n * return value will replace the Slice in the Slice Zone.\n */\nexport type SliceMapper<\n\tTSlice extends SliceLike = SliceLike,\n\tTMappedSlice extends Record<string, unknown> | undefined | void =\n\t\t| Record<string, unknown>\n\t\t| undefined\n\t\t| void,\n\tTContext = unknown,\n> = (\n\targs: SliceMapperArgs<TSlice, TContext>,\n) => TMappedSlice | Promise<TMappedSlice>;\n\n/**\n * Unwraps a lazily loaded mapper module.\n */\ntype ResolveLazySliceMapperModule<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSliceMapper extends SliceMapper<any, any> | LazyModule<SliceMapper>,\n> = TSliceMapper extends LazyModule<SliceMapper>\n\t? Awaited<ReturnType<TSliceMapper>> extends {\n\t\t\tdefault: unknown;\n\t  }\n\t\t? Awaited<ReturnType<TSliceMapper>>[\"default\"]\n\t\t: Awaited<ReturnType<TSliceMapper>>\n\t: TSliceMapper;\n\n/**\n * Transforms a Slice into its mapped version.\n */\ntype MapSliceLike<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSliceLike extends SliceLike<any>,\n\tTSliceMappers extends SliceMappers<\n\t\tTSliceLike,\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tany\n\t>,\n> = TSliceLike extends Slice\n\t? TSliceLike[\"slice_type\"] extends keyof TSliceMappers\n\t\t? TSliceMappers[TSliceLike[\"slice_type\"]] extends AnyFunction\n\t\t\t? SliceLikeRestV2<TSliceLike[\"slice_type\"]> &\n\t\t\t\t\tMappedSliceLike &\n\t\t\t\t\tAwaited<\n\t\t\t\t\t\tReturnType<\n\t\t\t\t\t\t\tResolveLazySliceMapperModule<\n\t\t\t\t\t\t\t\tTSliceMappers[TSliceLike[\"slice_type\"]]\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t\t>\n\t\t\t: TSliceLike\n\t\t: TSliceLike\n\t: TSliceLike extends SliceLikeGraphQL\n\t? TSliceLike[\"type\"] extends keyof TSliceMappers\n\t\t? TSliceMappers[TSliceLike[\"type\"]] extends AnyFunction\n\t\t\t? SliceLikeGraphQL<TSliceLike[\"type\"]> &\n\t\t\t\t\tMappedSliceLike &\n\t\t\t\t\tAwaited<\n\t\t\t\t\t\tReturnType<\n\t\t\t\t\t\t\tResolveLazySliceMapperModule<TSliceMappers[TSliceLike[\"type\"]]>\n\t\t\t\t\t\t>\n\t\t\t\t\t>\n\t\t\t: TSliceLike\n\t\t: TSliceLike\n\t: never;\n\n/**\n * Transforms a Slice Zone using a set of mapping functions, one for each type\n * of Slice. Mapping functions can be async.\n *\n * Whenever possible, use this function on the server to minimize client-side\n * processing.\n *\n * @example\n *\n * ```typescript\n * const mappedSliceZone = await mapSliceZone(page.data.slices, {\n * \tcode_block: ({ slice }) => ({\n * \t\tcodeHTML: await highlight(slice.primary.code),\n * \t}),\n * });\n * ```\n */\nexport function mapSliceZone<\n\tTSliceLike extends SliceLike,\n\tTSliceMappers extends SliceMappers<TSliceLike, TContext>,\n\tTContext = unknown,\n>(\n\tsliceZone: SliceZoneLike<TSliceLike>,\n\tmappers: TSliceMappers,\n\tcontext?: TContext,\n): Promise<MapSliceLike<TSliceLike, TSliceMappers>[]> {\n\treturn Promise.all(\n\t\tsliceZone.map(async (slice, index, slices) => {\n\t\t\tconst isRestSliceType = \"slice_type\" in slice;\n\t\t\tconst sliceType = isRestSliceType ? slice.slice_type : slice.type;\n\n\t\t\tconst mapper = mappers[sliceType as keyof typeof mappers];\n\n\t\t\tif (!mapper) {\n\t\t\t\treturn slice;\n\t\t\t}\n\n\t\t\tconst mapperArgs = { slice, slices, index, context };\n\n\t\t\t// `result` may be a mapper function OR a module\n\t\t\t// containing a mapper function.\n\t\t\tlet result = await mapper(\n\t\t\t\t// @ts-expect-error - I don't know how to fix this type\n\t\t\t\tmapperArgs,\n\t\t\t);\n\n\t\t\t// `result` is a module containing a mapper function,\n\t\t\t// we need to dig out the mapper function. `result`\n\t\t\t// will be reassigned with the mapper function's value.\n\t\t\tif (\n\t\t\t\t// `mapper.length < 1` ensures the given\n\t\t\t\t// function is something of the form:\n\t\t\t\t// `() => import(...)`\n\t\t\t\tmapper.length < 1 &&\n\t\t\t\t(typeof result === \"function\" ||\n\t\t\t\t\t(typeof result === \"object\" && \"default\" in result))\n\t\t\t) {\n\t\t\t\tresult = \"default\" in result ? result.default : result;\n\t\t\t\tresult = await result(mapperArgs);\n\t\t\t}\n\n\t\t\tif (isRestSliceType) {\n\t\t\t\treturn {\n\t\t\t\t\t__mapped: true,\n\t\t\t\t\tid: slice.id,\n\t\t\t\t\tslice_type: sliceType,\n\t\t\t\t\t...result,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\t__mapped: true,\n\t\t\t\t\ttype: sliceType,\n\t\t\t\t\t...result,\n\t\t\t\t};\n\t\t\t}\n\t\t}),\n\t);\n}\n", "/**\n * Formats the value of a filter element to a stringified version accepted by\n * the Prismic REST API.\n *\n * @param value - Value to format.\n *\n * @returns `value` formatted for the Prismic REST API.\n */\nconst formatValue = (\n\tvalue:\n\t\t| string\n\t\t| number\n\t\t| Date\n\t\t| unknown\n\t\t| (string | number | Date | unknown)[],\n): string => {\n\tif (Array.isArray(value)) {\n\t\treturn `[${value.map(formatValue).join(\", \")}]`;\n\t}\n\n\tif (typeof value === \"string\") {\n\t\treturn `\"${value}\"`;\n\t}\n\n\tif (value instanceof Date) {\n\t\treturn `${value.getTime()}`;\n\t}\n\n\treturn `${value}`;\n};\n\n/**\n * Creates a filter builder function for filters with a path and arguments.\n *\n * @typeParam Args - Arguments for the filter.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst pathWithArgsFilter = <Args extends unknown[]>(name: string) => {\n\t/**\n\t * @param path - Path to the value to be compared.\n\t */\n\tconst fn = (path: string, ...args: Args): string => {\n\t\tconst formattedArgs = args.map(formatValue).join(\", \");\n\t\tconst joiner = path && args.length ? \", \" : \"\";\n\n\t\treturn `[${name}(${path}${joiner}${formattedArgs})]`;\n\t};\n\n\treturn fn;\n};\n\n/**\n * Creates a filter builder function for filters with only a path.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst pathFilter = (name: string) => {\n\tconst filterFn = pathWithArgsFilter(name);\n\n\t/**\n\t * @param path - Path for the filter.\n\t */\n\tconst fn = (path: string): string => {\n\t\treturn filterFn(path);\n\t};\n\n\treturn fn;\n};\n\n/**\n * Creates a filter builder function for filters with only arguments and no\n * path.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst argsFilter = <Args extends unknown[]>(name: string) => {\n\tconst filterFn = pathWithArgsFilter<Args>(name);\n\n\t/**\n\t * @param args - Arguments for the filter.\n\t */\n\tconst fn = (...args: Args): string => {\n\t\treturn filterFn(\"\", ...args);\n\t};\n\n\treturn fn;\n};\n\nexport const filter = {\n\t/**\n\t * The `at` filter checks that the path matches the described value exactly.\n\t * It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#at}\n\t */\n\tat: pathWithArgsFilter<[value: string | number | boolean | Date | string[]]>(\n\t\t\"at\",\n\t),\n\n\t/**\n\t * The `not` filter checks that the path doesn't match the provided value\n\t * exactly. It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#not}\n\t */\n\tnot: pathWithArgsFilter<[value: string | number | boolean | Date | string[]]>(\n\t\t\"not\",\n\t),\n\n\t/**\n\t * The `any` filter takes an array of values. It works exactly the same way as\n\t * the `at` operator, but checks whether the fragment matches any of the\n\t * values in the array.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#any}\n\t */\n\tany: pathWithArgsFilter<[values: (string | number | boolean | Date)[]]>(\n\t\t\"any\",\n\t),\n\n\t/**\n\t * The `in` filter is used specifically to retrieve an array of documents by\n\t * their IDs or UIDs. This filter is much more efficient at this than the any\n\t * filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#in}\n\t */\n\tin: pathWithArgsFilter<[values: string[]]>(\"in\"),\n\n\t/**\n\t * The `fulltext` filter provides two capabilities:\n\t *\n\t * 1. Checking if a certain string is anywhere inside a document (this is what\n\t *    you should use to make your project's search engine feature)\n\t * 2. Checking if the string is contained inside a specific custom type’s Rich\n\t *    Text or Key Text fragment.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fulltext}\n\t */\n\tfulltext: pathWithArgsFilter<[searchTerms: string]>(\"fulltext\"),\n\n\t/**\n\t * The `has` filter checks whether a fragment has a value. It will return all\n\t * the documents of the specified type that contain a value for the specified\n\t * field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#has}\n\t */\n\thas: pathFilter(\"has\"),\n\n\t/**\n\t * The `missing` filter checks if a fragment doesn't have a value. It will\n\t * return all the documents of the specified type that do not contain a value\n\t * for the specified field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#missing}\n\t */\n\tmissing: pathFilter(\"missing\"),\n\n\t/**\n\t * The `similar` filter takes the ID of a document, and returns a list of\n\t * documents with similar content. This allows you to build an automated\n\t * content discovery feature (for example, a \"Related posts\" section).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#similar}\n\t */\n\tsimilar: argsFilter<[id: string, value: number]>(\"similar\"),\n\n\t/**\n\t * The `geopoint.near` filter checks that the value in the path is within the\n\t * radius of the given coordinates.\n\t *\n\t * This filter will only work for a geopoint field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#geopointnear}\n\t */\n\tgeopointNear:\n\t\tpathWithArgsFilter<[latitude: number, longitude: number, radius: number]>(\n\t\t\t\"geopoint.near\",\n\t\t),\n\n\t/**\n\t * The `number.lt` filter checks that the value in the number field is less\n\t * than the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numberlessthan}\n\t */\n\tnumberLessThan: pathWithArgsFilter<[value: number]>(\"number.lt\"),\n\n\t/**\n\t * The `number.gt` filter checks that the value in the number field is greater\n\t * than the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numbergreaterthan}\n\t */\n\tnumberGreaterThan: pathWithArgsFilter<[value: number]>(\"number.gt\"),\n\n\t/**\n\t * The `number.inRange` filter checks that the value in the path is within the\n\t * two values passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numberinrange}\n\t */\n\tnumberInRange:\n\t\tpathWithArgsFilter<[lowerLimit: number, upperLimit: number]>(\n\t\t\t\"number.inRange\",\n\t\t),\n\n\t/**\n\t * The `date.after` filter checks that the value in the path is after the date\n\t * value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateAfter: pathWithArgsFilter<[date: string | number | Date]>(\"date.after\"),\n\n\t/**\n\t * The `date.before` filter checks that the value in the path is before the\n\t * date value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateBefore: pathWithArgsFilter<[date: string | number | Date]>(\"date.before\"),\n\n\t/**\n\t * The `date.between` filter checks that the value in the path is within the\n\t * date values passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateBetween:\n\t\tpathWithArgsFilter<\n\t\t\t[startDate: string | number | Date, endDate: string | number | Date]\n\t\t>(\"date.between\"),\n\n\t/**\n\t * The `date.day-of-month` filter checks that the value in the path is equal\n\t * to the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonth: pathWithArgsFilter<[day: number]>(\"date.day-of-month\"),\n\n\t/**\n\t * The `date.day-of-month-after` filter checks that the value in the path is\n\t * after the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonthAfter: pathWithArgsFilter<[day: number]>(\n\t\t\"date.day-of-month-after\",\n\t),\n\n\t/**\n\t * The `date.day-of-month-before` filter checks that the value in the path is\n\t * before the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonthBefore: pathWithArgsFilter<[day: number]>(\n\t\t\"date.day-of-month-before\",\n\t),\n\n\t/**\n\t * The `date.day-of-week` filter checks that the value in the path is equal to\n\t * the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeek: pathWithArgsFilter<[day: string | number]>(\"date.day-of-week\"),\n\n\t/**\n\t * The `date.day-of-week-after` filter checks that the value in the path is\n\t * after the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeekAfter: pathWithArgsFilter<[day: string | number]>(\n\t\t\"date.day-of-week-after\",\n\t),\n\n\t/**\n\t * The date.day-of-week-before filter checks that the value in the path is\n\t * before the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeekBefore: pathWithArgsFilter<[day: string | number]>(\n\t\t\"date.day-of-week-before\",\n\t),\n\n\t/**\n\t * The `date.month` filter checks that the value in the path occurs in the\n\t * month value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonth: pathWithArgsFilter<[month: string | number]>(\"date.month\"),\n\n\t/**\n\t * The `date.month-after` filter checks that the value in the path occurs in\n\t * any month after the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonthAfter:\n\t\tpathWithArgsFilter<[month: string | number]>(\"date.month-after\"),\n\n\t/**\n\t * The `date.month-before` filter checks that the value in the path occurs in\n\t * any month before the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonthBefore:\n\t\tpathWithArgsFilter<[month: string | number]>(\"date.month-before\"),\n\n\t/**\n\t * The `date.year` filter checks that the value in the path occurs in the year\n\t * value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateYear: pathWithArgsFilter<[year: number]>(\"date.year\"),\n\n\t/**\n\t * The `date.hour` filter checks that the value in the path occurs within the\n\t * hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHour: pathWithArgsFilter<[hour: number]>(\"date.hour\"),\n\n\t/**\n\t * The `date.hour-after` filter checks that the value in the path occurs after\n\t * the hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHourAfter: pathWithArgsFilter<[hour: number]>(\"date.hour-after\"),\n\n\t/**\n\t * The `date.hour-before` filter checks that the value in the path occurs\n\t * before the hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHourBefore: pathWithArgsFilter<[hour: number]>(\"date.hour-before\"),\n};\n", "/**\n * Ensures that a value is an array. If it is already an array, it is returned\n * as is. If it is not an array, it is converted to an array with itself as its\n * only element.\n *\n * @typeParam A - Element of the array.\n *\n * @param a - Value to ensure is an array.\n *\n * @returns `a` as an array.\n */\nexport const castArray = <A>(a: A | A[]): A[] => {\n\treturn Array.isArray(a) ? a : [a];\n};\n", "import { castArray } from \"./castArray\";\n\ninterface WithFilters {\n\tfilters?: string | string[];\n}\n\n/**\n * Adds one or more filters to an object with a `filters` property. Appended\n * filters are added to the end of the existing list.\n *\n * @typeParam T - Object to which filters will be append.\n *\n * @param objWithFilters - Object to append filters on the `filters` property.\n * @param filters - One or more filters to append.\n *\n * @returns The object with the appended filters.\n */\nexport const appendFilters = <T extends WithFilters>(\n\tobjWithFilters: T = {} as T,\n\tfilters: string | string[],\n): T & { filters: string[] } => {\n\treturn {\n\t\t...objWithFilters,\n\t\tfilters: [...(objWithFilters.filters || []), ...castArray(filters)],\n\t};\n};\n", "/**\n * Ensures that a value is a thunk. If it is already a thunk, it is returned as\n * is. If it is not a thunk, it is converted to a thunk.\n *\n * @typeParam A - Value returned by the thunk.\n *\n * @param a - Value to ensure is a thunk.\n *\n * @returns `a` as a a thunk.\n */\nexport const castThunk = <A>(a: A | (() => A)): (() => A) => {\n\treturn typeof a === \"function\" ? (a as () => A) : () => a;\n};\n", "const version = \"7.6.0\";\nexport {\n  version\n};\n//# sourceMappingURL=package.json.js.map\n", "import { version } from \"../../package.json\";\n\n/**\n * Returns a `prismic.dev/msg` URL for a given message slug.\n *\n * @example\n *\n * ```ts\n * devMsg(\"missing-param\");\n * // => \"https://prismic.dev/msg/client/v1.2.3/missing-param.md\"\n * ```\n *\n * @param slug - Slug for the message. This corresponds to a Markdown file in\n *   the Git repository's `/messages` directory.\n *\n * @returns The `prismic.dev/msg` URL for the given slug.\n */\nexport const devMsg = (slug: string): string => {\n\treturn `https://prismic.dev/msg/client/v${version}/${slug}`;\n};\n", "import { filter } from \"../filter\";\n\nimport { castArray } from \"./castArray\";\n\n/**\n * Creates a filter to filter content by document tags. All tags are required on\n * the document.\n *\n * @param tags - Document tags to filter queried content.\n *\n * @returns A filter that can be used in a Prismic REST API V2 request.\n */\nexport const everyTagFilter = (tags: string | string[]): string => {\n\treturn filter.at(\"document.tags\", castArray(tags));\n};\n", "export class PrismicError<Response> extends Error {\n\turl?: string;\n\tresponse: Response;\n\n\tconstructor(\n\t\tmessage = \"An invalid API response was returned\",\n\t\turl: string | undefined,\n\t\tresponse: Response,\n\t) {\n\t\tsuper(message);\n\n\t\tthis.url = url;\n\t\tthis.response = response;\n\t}\n}\n", "import { Ref } from \"../types/api/ref\";\n\nimport { PrismicError } from \"../errors/PrismicError\";\n\n/**\n * Returns the first ref from a list that passes a filter (a function that\n * returns true).\n *\n * @param refs - A list of refs to search.\n * @param filter - A function that determines if a ref from the list matches the\n *   criteria.\n *\n * @returns The first matching ref.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findRef = (refs: Ref[], filter: (ref: Ref) => boolean): Ref => {\n\tconst ref = refs.find((ref) => filter(ref));\n\n\tif (!ref) {\n\t\tthrow new PrismicError(\"Ref could not be found.\", undefined, undefined);\n\t}\n\n\treturn ref;\n};\n", "import { Ref } from \"../types/api/ref\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the master ref from a list of given refs.\n *\n * @param refs - A list of refs to search.\n *\n * @returns The master ref from the list.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findMasterRef = (refs: Ref[]): Ref => {\n\treturn findRef(refs, (ref) => ref.isMasterRef);\n};\n", "import { Ref } from \"../types/api/ref\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the ref from a list of given refs with a matching ID.\n *\n * @param refs - A list of refs to search.\n * @param id - The ID of the ref to find.\n *\n * @returns The ref with a matching ID from the list.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByID = (refs: Ref[], id: string): Ref => {\n\treturn findRef(refs, (ref) => ref.id === id);\n};\n", "import { Ref } from \"../types/api/ref\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the ref from a list of given refs with a matching label.\n *\n * @param refs - A list of refs to search.\n * @param id - The label of the ref to find.\n *\n * @returns The ref with a matching label from the list.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByLabel = (refs: Ref[], label: string): Ref => {\n\treturn findRef(refs, (ref) => ref.label === label);\n};\n", "/**\n * The well-known name of the cookie used to store a Prismic preview session's\n * ref.\n */\nexport const preview = \"io.prismic.preview\";\n", "import { preview as previewCookieName } from \"../cookie\";\n\nconst readValue = (value: string): string => {\n\treturn value.replace(/%3B/g, \";\");\n};\n\n/**\n * Returns the value of a cookie from a given cookie store.\n *\n * @param cookieJar - The stringified cookie store from which to read the\n *   cookie.\n *\n * @returns The value of the cookie, if it exists.\n */\nexport const getPreviewCookie = (cookieJar: string): string | undefined => {\n\tconst cookies = cookieJar.split(\"; \");\n\n\tlet value: string | undefined;\n\n\tfor (const cookie of cookies) {\n\t\tconst parts = cookie.split(\"=\");\n\t\tconst name = readValue(parts[0]).replace(/%3D/g, \"=\");\n\n\t\tif (name === previewCookieName) {\n\t\t\tvalue = readValue(parts.slice(1).join(\"=\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn value;\n};\n", "/**\n * Minifies a GraphQL query by removing whitespace where possible.\n *\n * @param query - GraphQL query to minify.\n *\n * @returns A minified version of `query`.\n */\nexport const minifyGraphQLQuery = (query: string): string => {\n\treturn query.replace(\n\t\t/(\\n| )*( |{|})(\\n| )*/gm,\n\t\t(_chars, _spaces, brackets) => brackets,\n\t);\n};\n", "import { filter } from \"../filter\";\n\nimport { castArray } from \"./castArray\";\n\n/**\n * Creates a filter to filter content by document tags. At least one matching\n * tag is required on the document.\n *\n * @param tags - Document tags to filter queried content.\n *\n * @returns A filter that can be used in a Prismic REST API V2 request.\n */\nexport const someTagsFilter = (tags: string | string[]): string => {\n\treturn filter.any(\"document.tags\", castArray(tags));\n};\n", "import { filter } from \"../filter\";\n\n/**\n * Creates a filter to filter content by document type.\n *\n * @param documentType - The document type to filter queried content.\n *\n * @returns A filter that can be used in a Prismic REST API V2 request.\n */\nexport const typeFilter = (documentType: string): string => {\n\treturn filter.at(\"document.type\", documentType);\n};\n", "import { PrismicError } from \"./PrismicError\";\n\ntype ForbiddenErrorRepositoryAPIResponse = {\n\ttype: string;\n\tmessage: string;\n};\n\ntype ForbiddenErrorQueryAPIResponse = {\n\terror: string;\n};\n\nexport class ForbiddenError<\n\tTResponse =\n\t\t| ForbiddenErrorRepositoryAPIResponse\n\t\t| ForbiddenErrorQueryAPIResponse,\n> extends PrismicError<TResponse> {}\n", "import { PrismicError } from \"./PrismicError\";\n\nexport class NotFoundError<\n\tTResponse = undefined,\n> extends PrismicError<TResponse> {}\n", "import { PrismicError } from \"./PrismicError\";\n\ntype ParsingErrorAPIResponse = {\n\ttype: \"parsing-error\";\n\tmessage: string;\n\tline: number;\n\tcolumn: number;\n\tid: number;\n\tlocation: string;\n};\n\nexport class ParsingError<\n\tTResponse = ParsingErrorAPIResponse,\n> extends PrismicError<TResponse> {}\n", "import { ForbiddenError } from \"./ForbiddenError\";\n\ntype PreviewTokenExpiredErrorAPIResponse = {\n\ttype: \"api_security_error\";\n\tmessage: string;\n};\n\n// This error extends `ForbiddenError` for backwards compatibility.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class PreviewTokenExpiredError<\n\tTResponse = PreviewTokenExpiredErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n", "import { ForbiddenError } from \"./ForbiddenError\";\n\ntype RefExpiredErrorAPIResponse = {\n\ttype: \"api_validation_error\";\n\tmessage: string;\n};\n\n// This error extends `ForbiddenError` for backwards compatibility. Before the\n// API started returning 410 for expired refs, it returnd 403, which threw a\n// `ForbiddenError`.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class RefExpiredError<\n\tTResponse = RefExpiredErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n", "import { ForbiddenError } from \"./ForbiddenError\";\n\ntype RefNotFoundErrorAPIResponse = {\n\ttype: \"api_notfound_error\";\n\tmessage: string;\n};\n\n// This error extends `ForbiddenError` for backwards compatibility. Before the\n// API started returning 404 for not found refs, it returnd 403, which threw a\n// `ForbiddenError`.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class RefNotFoundError<\n\tTResponse = RefNotFoundErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n", "import { NotFoundError } from \"./NotFoundError\";\n\nexport class RepositoryNotFoundError<\n\tTResponse = undefined,\n> extends NotFoundError<TResponse> {}\n", "import type { AnyRegularField, FieldState } from \"./types\";\n\nimport type { ContentRelationshipField } from \"./contentRelationship\";\nimport type { GroupField } from \"./group\";\nimport type { LinkToMediaField } from \"./linkToMedia\";\nimport type { SliceZone } from \"./sliceZone\";\n\n/**\n * Link types\n */\nexport const LinkType = {\n\tAny: \"Any\",\n\tDocument: \"Document\",\n\tMedia: \"Media\",\n\tWeb: \"Web\",\n} as const;\n\n/**\n * For link fields that haven't been filled\n *\n * @typeParam Type - The type of link.\n */\nexport type EmptyLinkField<\n\tType extends (typeof LinkType)[keyof typeof LinkType] = typeof LinkType.Any,\n> = {\n\tlink_type: Type | string;\n};\n\n/**\n * Link that points to external website\n */\nexport interface FilledLinkToWebField {\n\tlink_type: typeof LinkType.Web;\n\turl: string;\n\ttarget?: string;\n}\n\n/**\n * A link field.\n *\n * @typeParam TypeEnum - Type API ID of the document.\n * @typeParam LangEnum - Language API ID of the document.\n * @typeParam DataInterface - Data fields for the document (filled in via\n *   GraphQuery of `fetchLinks`).\n * @typeParam State - State of the field which determines its shape.\n */\nexport type LinkField<\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n\tState extends FieldState = FieldState,\n> = State extends \"empty\"\n\t? EmptyLinkField<typeof LinkType.Any>\n\t:\n\t\t\t| ContentRelationshipField<TypeEnum, LangEnum, DataInterface, State>\n\t\t\t| FilledLinkToWebField\n\t\t\t| LinkToMediaField<State>;\n", "import type { FilledContentRelationshipField } from \"../types/value/contentRelationship\";\nimport type { PrismicDocument } from \"../types/value/document\";\nimport { LinkType } from \"../types/value/link\";\n\ntype SetOptional<T, Keys extends keyof T> = Omit<T, Keys> &\n\tPartial<Pick<T, Keys>>;\n\n/**\n * Converts a document into a link field, this is useful when crawling the API\n * for document links\n *\n * @typeParam TDocument - Specific interface of the provided document\n *\n * @param prismicDocument - A document coming from Prismic\n *\n * @returns The equivalent link field to use with `asLink()`\n *\n * @internal\n */\nexport const documentToLinkField = <\n\tTDocument extends SetOptional<PrismicDocument, \"slugs\">,\n>(\n\tprismicDocument: TDocument,\n): FilledContentRelationshipField<\n\tTDocument[\"type\"],\n\tTDocument[\"lang\"],\n\tTDocument[\"data\"]\n> => {\n\treturn {\n\t\tlink_type: LinkType.Document,\n\t\tid: prismicDocument.id,\n\t\tuid: prismicDocument.uid || undefined,\n\t\ttype: prismicDocument.type,\n\t\ttags: prismicDocument.tags,\n\t\tlang: prismicDocument.lang,\n\t\turl: prismicDocument.url == null ? undefined : prismicDocument.url,\n\t\tslug: prismicDocument.slugs?.[0], // Slug field is not available with GraphQL\n\t\t// The REST API does not include a `data` property if the data\n\t\t// object is empty.\n\t\t//\n\t\t// A presence check for `prismicDocument.data` is done to\n\t\t// support partial documents. While `documentToLinkField` is\n\t\t// not typed to accept partial documents, passing a partial\n\t\t// document can happen in untyped projects.\n\t\t...(prismicDocument.data && Object.keys(prismicDocument.data).length > 0\n\t\t\t? { data: prismicDocument.data }\n\t\t\t: {}),\n\t};\n};\n", "import type { FilledContentRelationshipField } from \"../types/value/contentRelationship\";\nimport type { PrismicDocument } from \"../types/value/document\";\nimport { FilledLinkToWebField, LinkField, LinkType } from \"../types/value/link\";\nimport type { FilledLinkToMediaField } from \"../types/value/linkToMedia\";\n\nimport { documentToLinkField } from \"./documentToLinkField\";\n\n/**\n * Resolves a link to a Prismic document to a URL\n *\n * @typeParam ReturnType - Return type of your link resolver function, useful if\n *   you prefer to return a complex object\n *\n * @param linkToDocumentField - A document link field to resolve\n *\n * @returns Resolved URL\n *\n * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n */\nexport type LinkResolverFunction<ReturnType = string | null | undefined> = (\n\tlinkToDocumentField: FilledContentRelationshipField,\n) => ReturnType;\n\n/**\n * Configuration that determines the output of `asLink()`.\n */\ntype AsLinkConfig<LinkResolverFunctionReturnType = string | null | undefined> =\n\t{\n\t\t/**\n\t\t * An optional link resolver function. Without it, you are expected to use\n\t\t * the `routes` options from the API.\n\t\t */\n\t\tlinkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType> | null;\n\t};\n\n// TODO: Remove when we remove support for deprecated tuple-style configuration.\n/**\n * @deprecated Use object-style configuration instead.\n */\ntype AsLinkDeprecatedTupleConfig<\n\tLinkResolverFunctionReturnType = string | null | undefined,\n> = [\n\tlinkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType> | null,\n];\n\n/**\n * The return type of `asLink()`.\n */\nexport type AsLinkReturnType<\n\tLinkResolverFunctionReturnType = string | null | undefined,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = Field extends\n\t| FilledLinkToWebField\n\t| FilledLinkToMediaField\n\t| FilledContentRelationshipField\n\t| PrismicDocument\n\t? LinkResolverFunctionReturnType | string | null\n\t: null;\n\n// TODO: Remove overload when we remove support for deprecated tuple-style configuration.\nexport const asLink: {\n\t/**\n\t * Resolves any type of link field or Prismic document to a URL.\n\t *\n\t * @typeParam LinkResolverFunctionReturnType - link resolver function return\n\t *   type\n\t * @typeParam Field - Link field or Prismic document to resolve to a URL\n\t *\n\t * @param linkFieldOrDocument - Any kind of link field or a document to\n\t *   resolve\n\t * @param config - Configuration that determines the output of `asLink()`\n\t *\n\t * @returns Resolved URL or, if the provided link field or document is empty,\n\t *   `null`\n\t *\n\t * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n\t * @see Prismic API `routes` options documentation: {@link https://prismic.io/docs/route-resolver}\n\t */\n\t<\n\t\tLinkResolverFunctionReturnType = string | null | undefined,\n\t\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t\t| LinkField\n\t\t\t| PrismicDocument\n\t\t\t| null\n\t\t\t| undefined,\n\t>(\n\t\tlinkFieldOrDocument: Field,\n\t\tconfig?: AsLinkConfig<LinkResolverFunctionReturnType>,\n\t): AsLinkReturnType<LinkResolverFunctionReturnType, Field>;\n\n\t/**\n\t * Resolves any type of link field or Prismic document to a URL.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @typeParam LinkResolverFunctionReturnType - link resolver function return\n\t *   type\n\t * @typeParam Field - Link field or Prismic document to resolve to a URL\n\t *\n\t * @param linkFieldOrDocument - Any kind of link field or a document to\n\t *   resolve\n\t * @param linkResolver - An optional link resolver function. Without it, you\n\t *   are expected to use the `routes` options from the API\n\t *\n\t * @returns Resolved URL or, if the provided link field or document is empty,\n\t *   `null`\n\t *\n\t * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n\t * @see Prismic API `routes` options documentation: {@link https://prismic.io/docs/route-resolver}\n\t */\n\t<\n\t\tLinkResolverFunctionReturnType = string | null | undefined,\n\t\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t\t| LinkField\n\t\t\t| PrismicDocument\n\t\t\t| null\n\t\t\t| undefined,\n\t>(\n\t\tlinkFieldOrDocument: Field,\n\t\t...config: AsLinkDeprecatedTupleConfig<LinkResolverFunctionReturnType>\n\t): AsLinkReturnType<LinkResolverFunctionReturnType, Field>;\n} = <\n\tLinkResolverFunctionReturnType = string | null | undefined,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n>(\n\tlinkFieldOrDocument: Field,\n\t// TODO: Rename to `config` when we remove support for deprecated tuple-style configuration.\n\t...configObjectOrTuple:\n\t\t| [config?: AsLinkConfig<LinkResolverFunctionReturnType>]\n\t\t| AsLinkDeprecatedTupleConfig<LinkResolverFunctionReturnType>\n): AsLinkReturnType<LinkResolverFunctionReturnType, Field> => {\n\tif (!linkFieldOrDocument) {\n\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>;\n\t}\n\n\t// Converts document to link field if needed\n\tconst linkField =\n\t\t// prettier-ignore\n\t\t(\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t// @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501\n\t\t\t// TODO: Remove the `prettier-ignore` comment when this bug is fixed.\n\t\t\t\"link_type\" in linkFieldOrDocument\n\t\t\t\t? linkFieldOrDocument\n\t\t\t\t: documentToLinkField(linkFieldOrDocument)\n\t\t) as LinkField;\n\n\t// TODO: Remove when we remove support for deprecated tuple-style configuration.\n\tconst [configObjectOrLinkResolver] = configObjectOrTuple;\n\tlet config: AsLinkConfig<LinkResolverFunctionReturnType>;\n\tif (\n\t\ttypeof configObjectOrLinkResolver === \"function\" ||\n\t\tconfigObjectOrLinkResolver == null\n\t) {\n\t\tconfig = {\n\t\t\tlinkResolver: configObjectOrLinkResolver,\n\t\t};\n\t} else {\n\t\tconfig = { ...configObjectOrLinkResolver };\n\t}\n\n\tswitch (linkField.link_type) {\n\t\tcase LinkType.Media:\n\t\tcase LinkType.Web:\n\t\t\treturn (\"url\" in linkField ? linkField.url : null) as AsLinkReturnType<\n\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\tField\n\t\t\t>;\n\n\t\tcase LinkType.Document: {\n\t\t\tif (\"id\" in linkField && config.linkResolver) {\n\t\t\t\t// When using link resolver...\n\t\t\t\tconst resolvedURL = config.linkResolver(linkField);\n\n\t\t\t\tif (resolvedURL != null) {\n\t\t\t\t\treturn resolvedURL as AsLinkReturnType<\n\t\t\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\t\t\tField\n\t\t\t\t\t>;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\"url\" in linkField && linkField.url) {\n\t\t\t\t// When using route resolver...\n\t\t\t\treturn linkField.url as AsLinkReturnType<\n\t\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\t\tField\n\t\t\t\t>;\n\t\t\t}\n\n\t\t\t// When empty or link resolver and route resolver are not used...\n\t\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>;\n\t\t}\n\n\t\tcase LinkType.Any:\n\t\tdefault:\n\t\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>;\n\t}\n};\n", "import { castArray } from \"./lib/castArray\";\nimport { devMsg } from \"./lib/devMsg\";\n\n/**\n * Create a union of the given object's values, and optionally specify which\n * keys to get the values from.\n *\n * Taken from the `type-fest` package.\n *\n * See:\n * https://github.com/sindresorhus/type-fest/blob/61c35052f09caa23de5eef96d95196375d8ed498/source/value-of.d.ts\n */\ntype ValueOf<\n\tObjectType,\n\tValueType extends keyof ObjectType = keyof ObjectType,\n> = ObjectType[ValueType];\n\n/**\n * An `orderings` parameter that orders the results by the specified field.\n *\n * {@link https://prismic.io/docs/rest-api-technical-reference#orderings}\n */\nexport interface Ordering {\n\tfield: string;\n\tdirection?: \"asc\" | \"desc\";\n}\n\n/**\n * A `routes` parameter that determines how a document's URL field is resolved.\n *\n * {@link https://prismic.io/docs/route-resolver}\n *\n * @example With a document's UID field.\n *\n * ```ts\n * {\n * \t\"type\": \"page\",\n * \t\"path\": \"/:uid\"\n * }\n * ```\n *\n * @example With a Content Relationship `parent` field.\n *\n * ```ts\n * {\n * \t\"type\": \"page\",\n * \t\"path\": \"/:parent?/:uid\",\n * \t\"resolvers\": {\n * \t\t\"parent\": \"parent\"\n * \t}\n * }\n * ```\n */\nexport interface Route {\n\t/**\n\t * The custom type of the document.\n\t */\n\ttype: string;\n\n\t/**\n\t * A specific UID to which this route definition is scoped. The route is only\n\t * defined for the document whose UID matches the given UID.\n\t */\n\tuid?: string;\n\n\t/**\n\t * A specific language to which this route definition is scoped. The route is\n\t * only defined for documents whose language matches the given language.\n\t */\n\tlang?: string;\n\n\t/**\n\t * The resolved path of the document with optional placeholders.\n\t */\n\tpath: string;\n\n\t/**\n\t * An object that lists the API IDs of the Content Relationships in the route.\n\t */\n\tresolvers?: Record<string, string>;\n}\n\n/**\n * Parameters for the Prismic REST API V2.\n *\n * {@link https://prismic.io/docs/api}\n */\nexport interface QueryParams {\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://prismic.io/docs/access-token}\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * The `pageSize` parameter defines the maximum number of documents that the\n\t * API will return for your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#pagesize}\n\t */\n\tpageSize?: number;\n\n\t/**\n\t * The `page` parameter defines the pagination for the result of your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#page}\n\t */\n\tpage?: number;\n\n\t/**\n\t * The `after` parameter can be used along with the orderings option. It will\n\t * remove all the documents except for those after the specified document in\n\t * the list.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#after}\n\t */\n\tafter?: string;\n\n\t/**\n\t * The `fetch` parameter is used to make queries faster by only retrieving the\n\t * specified field(s).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fetch}\n\t */\n\tfetch?: string | string[];\n\n\t/**\n\t * The `fetchLinks` parameter allows you to retrieve a specific content field\n\t * from a linked document and add it to the document response object.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fetchlinks}\n\t */\n\tfetchLinks?: string | string[];\n\n\t/**\n\t * The `graphQuery` parameter allows you to specify which fields to retrieve\n\t * and what content to retrieve from Linked Documents / Content\n\t * Relationships.\n\t *\n\t * {@link https://prismic.io/docs/graphquery-rest-api}\n\t */\n\tgraphQuery?: string;\n\n\t/**\n\t * The `lang` option defines the language code for the results of your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#lang}\n\t */\n\tlang?: string;\n\n\t/**\n\t * The `orderings` parameter orders the results by the specified field(s). You\n\t * can specify as many fields as you want.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#orderings}\n\t *\n\t * @remarks\n\t * Strings and arrays of strings are deprecated as of\n\t * `@prismicio/client@7.0.0`. Please migrate to the more explicit array of\n\t * objects.\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * buildQueryURL(endpoint, {\n\t * \torderings: [\n\t * \t\t{ field: \"my.product.price\", direction: \"desc\" },\n\t * \t\t{ field: \"my.product.title\" },\n\t * \t],\n\t * });\n\t * ```\n\t */\n\t// TODO: Update TSDoc with deprecated API removal in v8\n\torderings?: string | Ordering | (string | Ordering)[];\n\n\t/**\n\t * The `routes` option allows you to define how a document's `url` field is\n\t * resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: Route | string | (Route | string)[];\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: string;\n}\n\n/**\n * Arguments for `buildQueryURL` to construct a Query URL.\n */\ntype BuildQueryURLParams = {\n\t/**\n\t * Ref used to query documents.\n\t *\n\t * {@link https://prismic.io/docs/api#refs-and-the-entry-api}\n\t */\n\tref: string;\n\n\t/**\n\t * Ref used to populate integration fields with the latest content.\n\t *\n\t * {@link https://prismic.io/docs/integration-fields}\n\t */\n\tintegrationFieldsRef?: string;\n\n\t/**\n\t * One or more filters to filter documents for the query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#q}\n\t */\n\tfilters?: string | string[];\n\n\t/**\n\t * @deprecated Renamed to `filters`. Ensure the value is an array of filters,\n\t *   not a single, non-array filter.\n\t */\n\tpredicates?: string | string[];\n};\n\n/**\n * Parameters in this map have been renamed from the official Prismic REST API\n * V2 specification for better developer ergonomics.\n *\n * These parameters are renamed to their mapped value.\n */\nconst RENAMED_PARAMS = {\n\taccessToken: \"access_token\",\n} as const;\n\n/**\n * A valid parameter name for the Prismic REST API V2.\n */\ntype ValidParamName =\n\t| Exclude<\n\t\t\tkeyof QueryParams,\n\t\t\tkeyof typeof RENAMED_PARAMS | keyof BuildQueryURLParams\n\t  >\n\t| ValueOf<typeof RENAMED_PARAMS>;\n\n/**\n * Converts an Ordering to a string that is compatible with Prismic's REST API.\n * If the value provided is already a string, no conversion is performed.\n *\n * @param ordering - Ordering to convert.\n *\n * @returns String representation of the Ordering.\n */\nconst castOrderingToString = (ordering: Ordering | string): string => {\n\t// TODO: Remove the following when `orderings` strings are no longer supported.\n\tif (typeof ordering === \"string\") {\n\t\tif (process.env.NODE_ENV === \"development\") {\n\t\t\tconst [field, direction] = ordering.split(\" \");\n\n\t\t\tconst objectForm =\n\t\t\t\tdirection === \"desc\"\n\t\t\t\t\t? `{ field: \"${field}\", direction: \"desc\" }`\n\t\t\t\t\t: `{ field: \"${field}\" }`;\n\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] A string value was provided to the \\`orderings\\` query parameter. Strings are deprecated. Please convert it to the object form: ${objectForm}. For more details, see ${devMsg(\n\t\t\t\t\t\"orderings-must-be-an-array-of-objects\",\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\n\t\treturn ordering;\n\t}\n\n\treturn ordering.direction === \"desc\"\n\t\t? `${ordering.field} desc`\n\t\t: ordering.field;\n};\n\nexport type BuildQueryURLArgs = QueryParams & BuildQueryURLParams;\n\n/**\n * Build a Prismic REST API V2 URL to request documents from a repository. The\n * paginated response for this URL includes documents matching the parameters.\n *\n * A ref is required to make a request. Request the `endpoint` URL to retrieve a\n * list of available refs.\n *\n * Type the JSON response with `Query`.\n *\n * {@link https://prismic.io/docs/api#refs-and-the-entry-api}\n * {@link https://prismic.io/docs/rest-api-technical-reference}\n *\n * @param endpoint - URL to the repository's REST API V2.\n * @param args - Arguments to filter and scope the query.\n *\n * @returns URL that can be used to request documents from the repository.\n */\nexport const buildQueryURL = (\n\tendpoint: string,\n\targs: BuildQueryURLArgs,\n): string => {\n\tconst { filters, predicates, ...params } = args;\n\n\tconst url = new URL(`documents/search`, `${endpoint}/`);\n\n\tif (filters) {\n\t\t// TODO: Remove warning when we remove support for string `filters` values.\n\t\tif (process.env.NODE_ENV === \"development\" && !Array.isArray(filters)) {\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] A non-array value was provided to the \\`filters\\` query parameter (\\`${filters}\\`). Non-array values are deprecated. Please convert it to an array. For more details, see ${devMsg(\n\t\t\t\t\t\"filters-must-be-an-array\",\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\n\t\t// TODO: Remove `castArray` when we remove support for string `filters` values.\n\t\tfor (const filter of castArray(filters)) {\n\t\t\turl.searchParams.append(\"q\", `[${filter}]`);\n\t\t}\n\t}\n\n\t// TODO: Remove when we remove support for deprecated `predicates` argument.\n\tif (predicates) {\n\t\tfor (const predicate of castArray(predicates)) {\n\t\t\turl.searchParams.append(\"q\", `[${predicate}]`);\n\t\t}\n\t}\n\n\t// Iterate over each parameter and add it to the URL. In some cases, the\n\t// parameter value needs to be transformed to fit the REST API.\n\tfor (const k in params) {\n\t\tconst name = (RENAMED_PARAMS[k as keyof typeof RENAMED_PARAMS] ||\n\t\t\tk) as ValidParamName;\n\n\t\tlet value = params[k as keyof typeof params];\n\n\t\tif (name === \"orderings\") {\n\t\t\tconst scopedValue = params[name];\n\n\t\t\tif (scopedValue != null) {\n\t\t\t\t// TODO: Remove the following warning when `orderings` strings are no longer supported.\n\t\t\t\tif (\n\t\t\t\t\tprocess.env.NODE_ENV === \"development\" &&\n\t\t\t\t\ttypeof scopedValue === \"string\"\n\t\t\t\t) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[@prismicio/client] A string value was provided to the \\`orderings\\` query parameter. Strings are deprecated. Please convert it to an array of objects. For more details, see ${devMsg(\n\t\t\t\t\t\t\t\"orderings-must-be-an-array-of-objects\",\n\t\t\t\t\t\t)}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst v = castArray(scopedValue)\n\t\t\t\t\t.map((ordering) => castOrderingToString(ordering))\n\t\t\t\t\t.join(\",\");\n\n\t\t\t\tvalue = `[${v}]`;\n\t\t\t}\n\t\t} else if (name === \"routes\") {\n\t\t\tif (typeof params[name] === \"object\") {\n\t\t\t\tvalue = JSON.stringify(castArray(params[name]));\n\t\t\t}\n\t\t}\n\n\t\tif (value != null) {\n\t\t\turl.searchParams.set(\n\t\t\t\tname,\n\t\t\t\tcastArray<string | number | Route | Ordering>(value).join(\",\"),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn url.toString();\n};\n", "/**\n * Determines if an input is a valid Prismic repository name.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic repository name, `false`\n *   otherwise.\n */\nexport const isRepositoryName = (input: string): boolean => {\n\treturn /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(input);\n};\n", "import { PrismicError } from \"./errors/PrismicError\";\n\nimport { isRepositoryName } from \"./isRepositoryName\";\n\n/**\n * Get a repository's Prismic Rest API V2 endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n *\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic Rest API V2 endpoint\n *\n * @throws {@link Error} Thrown if an invalid repository name is provided.\n */\nexport const getRepositoryEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/api/v2` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/api/v2` as const;\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t}\n};\n", "import { PrismicError } from \"./errors/PrismicError\";\n\n/**\n * Get a Prismic repository's name from its standard Prismic Rest API V2 or\n * GraphQL endpoint.\n *\n * @typeParam RepositoryEndpoint - Prismic Rest API V2 endpoint for the\n *   repository.\n *\n * @param repositoryEndpoint - Prismic Rest API V2 endpoint for the repository.\n *\n * @returns The Prismic repository's name.\n *\n * @throws {@link Error} Thrown if an invalid Prismic Rest API V2 endpoint is\n *   provided.\n */\nexport const getRepositoryName = (repositoryEndpoint: string): string => {\n\ttry {\n\t\treturn new URL(repositoryEndpoint).hostname.split(\".\")[0];\n\t} catch {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic Rest API V2 endpoint was provided: ${repositoryEndpoint}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t}\n};\n", "/**\n * Determines if a string if a Prismic Rest API V2 endpoint. Note that any valid\n * URL is a valid endpoint to support network proxies.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic Rest API V2 endpoint, `false`\n *   otherwise.\n */\nexport const isRepositoryEndpoint = (input: string): boolean => {\n\ttry {\n\t\tnew URL(input);\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n};\n", "import { appendFilters } from \"./lib/appendFilters\";\nimport { castThunk } from \"./lib/castThunk\";\nimport { devMsg } from \"./lib/devMsg\";\nimport { everyTagFilter } from \"./lib/everyTagFilter\";\nimport { findMasterRef } from \"./lib/findMasterRef\";\nimport { findRefByID } from \"./lib/findRefByID\";\nimport { findRefByLabel } from \"./lib/findRefByLabel\";\nimport { getPreviewCookie } from \"./lib/getPreviewCookie\";\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery\";\nimport { someTagsFilter } from \"./lib/someTagsFilter\";\nimport { typeFilter } from \"./lib/typeFilter\";\n\nimport type { Query } from \"./types/api/query\";\nimport type { Ref } from \"./types/api/ref\";\nimport type { Form, Repository } from \"./types/api/repository\";\nimport type { PrismicDocument } from \"./types/value/document\";\n\nimport { ForbiddenError } from \"./errors/ForbiddenError\";\nimport { NotFoundError } from \"./errors/NotFoundError\";\nimport { ParsingError } from \"./errors/ParsingError\";\nimport { PreviewTokenExpiredError } from \"./errors/PreviewTokenExpired\";\nimport { PrismicError } from \"./errors/PrismicError\";\nimport { RefExpiredError } from \"./errors/RefExpiredError\";\nimport { RefNotFoundError } from \"./errors/RefNotFoundError\";\nimport { RepositoryNotFoundError } from \"./errors/RepositoryNotFoundError\";\n\nimport { LinkResolverFunction, asLink } from \"./helpers/asLink\";\n\nimport { BuildQueryURLArgs, buildQueryURL } from \"./buildQueryURL\";\nimport { filter } from \"./filter\";\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\";\nimport { getRepositoryName } from \"./getRepositoryName\";\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\";\n\n/**\n * The largest page size allowed by the Prismic REST API V2. This value is used\n * to minimize the number of requests required to query content.\n */\nconst MAX_PAGE_SIZE = 100;\n\n/**\n * The number of milliseconds in which repository metadata is considered valid.\n * A ref can be invalidated quickly depending on how frequently content is\n * updated in the Prismic repository. As such, repository's metadata can only be\n * considered valid for a short amount of time.\n */\nexport const REPOSITORY_CACHE_TTL = 5000;\n\n/**\n * The number of milliseconds in which a multi-page `getAll` (e.g. `getAll`,\n * `getAllByType`, `getAllByTag`) will wait between individual page requests.\n *\n * This is done to ensure API performance is sustainable and reduces the chance\n * of a failed API request due to overloading.\n */\nexport const GET_ALL_QUERY_DELAY = 500;\n\n/**\n * The default number of milliseconds to wait before retrying a rate-limited\n * `fetch()` request (429 response code). The default value is only used if the\n * response does not include a `retry-after` header.\n *\n * The API allows up to 200 requests per second.\n */\nconst DEFUALT_RETRY_AFTER_MS = 1000;\n\n/**\n * Extracts one or more Prismic document types that match a given Prismic\n * document type. If no matches are found, no extraction is performed and the\n * union of all provided Prismic document types are returned.\n *\n * @typeParam TDocuments - Prismic document types from which to extract.\n * @typeParam TDocumentType - Type(s) to match `TDocuments` against.\n */\ntype ExtractDocumentType<\n\tTDocuments extends PrismicDocument,\n\tTDocumentType extends TDocuments[\"type\"],\n> = Extract<TDocuments, { type: TDocumentType }> extends never\n\t? TDocuments\n\t: Extract<TDocuments, { type: TDocumentType }>;\n\n/**\n * A universal API to make network requests. A subset of the `fetch()` API.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch}\n */\nexport type FetchLike = (\n\tinput: string,\n\tinit?: RequestInitLike,\n) => Promise<ResponseLike>;\n\n/**\n * An object that allows you to abort a `fetch()` request if needed via an\n * `AbortController` object\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}\n */\n// `any` is used often here to ensure this type is universally valid among\n// different AbortSignal implementations. The types of each property are not\n// important to validate since it is blindly passed to a given `fetch()`\n// function.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AbortSignalLike = any;\n\n/**\n * A subset of RequestInit properties to configure a `fetch()` request.\n */\n// Only options relevant to the client are included. Extending from the full\n// RequestInit would cause issues, such as accepting Header objects.\n//\n// An interface is used to allow other libraries to augment the type with\n// environment-specific types.\nexport interface RequestInitLike extends Pick<RequestInit, \"cache\"> {\n\t/**\n\t * An object literal to set the `fetch()` request's headers.\n\t */\n\theaders?: Record<string, string>;\n\n\t/**\n\t * An AbortSignal to set the `fetch()` request's signal.\n\t *\n\t * See:\n\t * [https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)\n\t */\n\t// NOTE: `AbortSignalLike` is `any`! It is left as `AbortSignalLike`\n\t// for backwards compatibility (the type is exported) and to signal to\n\t// other readers that this should be an AbortSignal-like object.\n\tsignal?: AbortSignalLike;\n}\n\n/**\n * The minimum required properties from Response.\n */\nexport interface ResponseLike {\n\tstatus: number;\n\theaders: HeadersLike;\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tjson(): Promise<any>;\n}\n\n/**\n * The minimum required properties from Headers.\n */\nexport interface HeadersLike {\n\tget(name: string): string | null;\n}\n\n/**\n * The minimum required properties to treat as an HTTP Request for automatic\n * Prismic preview support.\n */\nexport type HttpRequestLike =\n\t| /**\n\t * Web API Request\n\t *\n\t * @see http://developer.mozilla.org/en-US/docs/Web/API/Request\n\t */\n\t{\n\t\t\theaders?: {\n\t\t\t\tget(name: string): string | null;\n\t\t\t};\n\t\t\turl?: string;\n\t  }\n\n\t/**\n\t * Express-style Request\n\t */\n\t| {\n\t\t\theaders?: {\n\t\t\t\tcookie?: string;\n\t\t\t};\n\t\t\tquery?: Record<string, unknown>;\n\t  };\n\n/**\n * Modes for client ref management.\n */\nenum RefStateMode {\n\t/**\n\t * Use the repository's master ref.\n\t */\n\tMaster = \"Master\",\n\n\t/**\n\t * Use a given Release identified by its ID.\n\t */\n\tReleaseID = \"ReleaseID\",\n\n\t/**\n\t * Use a given Release identified by its label.\n\t */\n\tReleaseLabel = \"ReleaseLabel\",\n\n\t/**\n\t * Use a given ref.\n\t */\n\tManual = \"Manual\",\n}\n\n/**\n * An object containing stateful information about a client's ref strategy.\n */\ntype RefState = {\n\t/**\n\t * Determines if automatic preview support is enabled.\n\t */\n\tautoPreviewsEnabled: boolean;\n\n\t/**\n\t * An optional HTTP server request object used during previews if automatic\n\t * previews are enabled.\n\t */\n\thttpRequest?: HttpRequestLike;\n} & (\n\t| {\n\t\t\tmode: RefStateMode.Master;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseID;\n\t\t\treleaseID: string;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseLabel;\n\t\t\treleaseLabel: string;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.Manual;\n\t\t\tref: RefStringOrThunk;\n\t  }\n);\n\n/**\n * A ref or a function that returns a ref. If a static ref is known, one can be\n * given. If the ref must be fetched on-demand, a function can be provided. This\n * function can optionally be asynchronous.\n */\ntype RefStringOrThunk =\n\t| string\n\t| (() => string | undefined | Promise<string | undefined>);\n\n/**\n * Configuration for clients that determine how content is queried.\n */\nexport type ClientConfig = {\n\t/**\n\t * The secure token for accessing the Prismic repository. This is only\n\t * required if the repository is set to private.\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * A string representing a version of the Prismic repository's content. This\n\t * may point to the latest version (called the \"master ref\"), or a preview\n\t * with draft content.\n\t */\n\tref?: RefStringOrThunk;\n\n\t/**\n\t * A list of route resolver objects that define how a document's `url`\n\t * property is resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>;\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>;\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\" | \"brokenRoute\"\n\t>;\n\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetch?: FetchLike;\n\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike;\n};\n\n/**\n * Parameters for any client method that use `fetch()`.\n */\ntype FetchParams = {\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike;\n\n\t/**\n\t * An `AbortSignal` provided by an `AbortController`. This allows the network\n\t * request to be cancelled if necessary.\n\t *\n\t * @deprecated Move the `signal` parameter into `fetchOptions.signal`:\n\t *\n\t * @see \\<https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\\>\n\t */\n\tsignal?: AbortSignalLike;\n};\n\n/**\n * Parameters specific to client methods that fetch all documents. These methods\n * start with `getAll` (for example, `getAllByType`).\n */\ntype GetAllParams = {\n\t/**\n\t * Limit the number of documents queried. If a number is not provided, there\n\t * will be no limit and all matching documents will be returned.\n\t */\n\tlimit?: number;\n};\n\n/**\n * Arguments to determine how the URL for a preview session is resolved.\n */\ntype ResolvePreviewArgs<LinkResolverReturnType> = {\n\t/**\n\t * A function that maps a Prismic document to a URL within your app.\n\t */\n\tlinkResolver?: LinkResolverFunction<LinkResolverReturnType>;\n\n\t/**\n\t * A fallback URL if the link resolver does not return a value.\n\t */\n\tdefaultURL: string;\n\n\t/**\n\t * The preview token (also known as a ref) that will be used to query preview\n\t * content from the Prismic repository.\n\t */\n\tpreviewToken?: string;\n\n\t/**\n\t * The previewed document that will be used to determine the destination URL.\n\t */\n\tdocumentID?: string;\n};\n\n/**\n * The result of a `fetch()` job.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype FetchJobResult<TJSON = any> = {\n\tstatus: number;\n\theaders: HeadersLike;\n\tjson: TJSON;\n};\n\n/**\n * Type definitions for the `createClient()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateClient {\n\t<TDocuments extends PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof Client>\n\t): Client<TDocuments>;\n}\n\n/**\n * Creates a Prismic client that can be used to query a repository.\n *\n * @example\n *\n * ```ts\n * // With a repository name.\n * createClient(\"qwerty\");\n *\n * // Or with a full Prismic Rest API V2 endpoint.\n * createClient(\"https://qwerty.cdn.prismic.io/api/v2\");\n * ```\n *\n * @typeParam TDocuments - A map of Prismic document type IDs mapped to their\n *   TypeScript type.\n *\n * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n *   API V2 endpoint for the repository.\n * @param options - Configuration that determines how content will be queried\n *   from the Prismic repository.\n *\n * @returns A client that can query content from the repository.\n */\nexport const createClient: CreateClient = <TDocuments extends PrismicDocument>(\n\trepositoryNameOrEndpoint: string,\n\toptions?: ClientConfig,\n) => new Client<TDocuments>(repositoryNameOrEndpoint, options);\n\n/**\n * A client that allows querying content from a Prismic repository.\n *\n * If used in an environment where a global `fetch` function is unavailable,\n * such as Node.js, the `fetch` option must be provided as part of the `options`\n * parameter.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class Client<TDocuments extends PrismicDocument = PrismicDocument> {\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t */\n\tendpoint: string;\n\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * A list of route resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>;\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>;\n\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetchFn: FetchLike;\n\n\tfetchOptions?: RequestInitLike;\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>;\n\n\t/**\n\t * The client's ref mode state. This determines which ref is used during\n\t * queries.\n\t */\n\tprivate refState: RefState = {\n\t\tmode: RefStateMode.Master,\n\t\tautoPreviewsEnabled: true,\n\t};\n\n\t/**\n\t * Cached repository value.\n\t */\n\tprivate cachedRepository: Repository | undefined;\n\n\t/**\n\t * Timestamp at which the cached repository data is considered stale.\n\t */\n\tprivate cachedRepositoryExpiration = 0;\n\n\t/**\n\t * Active `fetch()` jobs keyed by URL and AbortSignal (if it exists).\n\t */\n\tprivate fetchJobs: Record<\n\t\tstring,\n\t\tMap<AbortSignalLike | undefined, Promise<FetchJobResult>>\n\t> = {};\n\n\t/**\n\t * Creates a Prismic client that can be used to query a repository.\n\t *\n\t * If used in an environment where a global `fetch` function is unavailable,\n\t * such as Node.js, the `fetch` option must be provided as part of the\n\t * `options` parameter.\n\t *\n\t * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n\t *   API V2 endpoint for the repository.\n\t * @param options - Configuration that determines how content will be queried\n\t *   from the Prismic repository.\n\t *\n\t * @returns A client that can query content from the repository.\n\t */\n\tconstructor(repositoryNameOrEndpoint: string, options: ClientConfig = {}) {\n\t\tif (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n\t\t\tif (process.env.NODE_ENV === \"development\") {\n\t\t\t\t// Matches non-API v2 `.prismic.io` endpoints, see: https://regex101.com/r/xRsavu/1\n\t\t\t\tif (/\\.prismic\\.io\\/(?!api\\/v2\\/?)/i.test(repositoryNameOrEndpoint)) {\n\t\t\t\t\tthrow new PrismicError(\n\t\t\t\t\t\t\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\",\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst hostname = new URL(\n\t\t\t\t\trepositoryNameOrEndpoint,\n\t\t\t\t).hostname.toLowerCase();\n\n\t\t\t\t// Matches non-.cdn `.prismic.io` endpoints\n\t\t\t\tif (\n\t\t\t\t\thostname.endsWith(\".prismic.io\") &&\n\t\t\t\t\t!hostname.endsWith(\".cdn.prismic.io\")\n\t\t\t\t) {\n\t\t\t\t\tconst repositoryName = getRepositoryName(repositoryNameOrEndpoint);\n\t\t\t\t\tconst dotCDNEndpoint = getRepositoryEndpoint(repositoryName);\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[@prismicio/client] A non-.cdn endpoint was provided to create a client with (\\`${repositoryNameOrEndpoint}\\`). Non-.cdn endpoints can have unexpected side-effects and cause performance issues when querying Prismic. Please convert it to the \\`.cdn\\` alternative (\\`${dotCDNEndpoint}\\`) or use the repository name directly instead (\\`${repositoryName}\\`). For more details, see ${devMsg(\n\t\t\t\t\t\t\t\"endpoint-must-use-cdn\",\n\t\t\t\t\t\t)}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.endpoint = repositoryNameOrEndpoint;\n\t\t} else {\n\t\t\tthis.endpoint = getRepositoryEndpoint(repositoryNameOrEndpoint);\n\t\t}\n\n\t\tthis.accessToken = options.accessToken;\n\t\tthis.routes = options.routes;\n\t\tthis.brokenRoute = options.brokenRoute;\n\t\tthis.fetchOptions = options.fetchOptions;\n\t\tthis.defaultParams = options.defaultParams;\n\n\t\tif (options.ref) {\n\t\t\tthis.queryContentFromRef(options.ref);\n\t\t}\n\n\t\tif (typeof options.fetch === \"function\") {\n\t\t\tthis.fetchFn = options.fetch;\n\t\t} else if (typeof globalThis.fetch === \"function\") {\n\t\t\tthis.fetchFn = globalThis.fetch as FetchLike;\n\t\t} else {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\t// If the global fetch function is used, we must bind it to the global scope.\n\t\tif (this.fetchFn === globalThis.fetch) {\n\t\t\tthis.fetchFn = this.fetchFn.bind(globalThis);\n\t\t}\n\n\t\tthis.graphQLFetch = this.graphQLFetch.bind(this);\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in browser environments. This is enabled by default in the\n\t * browser.\n\t *\n\t * For server environments, use `enableAutoPreviewsFromReq`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.enableAutoPreviews();\n\t * ```\n\t *\n\t * @see enableAutoPreviewsFromReq\n\t */\n\tenableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = true;\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in server environments. This is disabled by default on the\n\t * server.\n\t *\n\t * For browser environments, use `enableAutoPreviews`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // In an express app\n\t * app.get(\"/\", function (req, res) {\n\t * \tclient.enableAutoPreviewsFromReq(req);\n\t * });\n\t * ```\n\t *\n\t * @param req - An HTTP server request object containing the request's\n\t *   cookies.\n\t */\n\tenableAutoPreviewsFromReq<R extends HttpRequestLike>(req: R): void {\n\t\tthis.refState.httpRequest = req;\n\t\tthis.refState.autoPreviewsEnabled = true;\n\t}\n\n\t/**\n\t * Disables the client from automatically querying content from a preview\n\t * session if one is active.\n\t *\n\t * Automatic preview content querying is enabled by default unless this method\n\t * is called.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.disableAutoPreviews();\n\t * ```\n\t */\n\tdisableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = false;\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.get();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\tconst url = await this.buildQueryURL(params);\n\n\t\treturn await this.fetch<Query<TDocument>>(url, params);\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository and returns only the first\n\t * result, if any.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getFirst();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results. @returns\n\t *   The first result of the query, if any.\n\t */\n\tasync getFirst<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\tconst actualParams = { ...params };\n\t\tif (!(params && params.page) && !params?.pageSize) {\n\t\t\tactualParams.pageSize = this.defaultParams?.pageSize ?? 1;\n\t\t}\n\t\tconst url = await this.buildQueryURL(actualParams);\n\t\tconst result = await this.fetch<Query<TDocument>>(url, params);\n\n\t\tconst firstResult = result.results[0];\n\n\t\tif (firstResult) {\n\t\t\treturn firstResult;\n\t\t}\n\n\t\tthrow new NotFoundError(\"No documents were returned\", url, undefined);\n\t}\n\n\t/**\n\t * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n\t * require more resources than other methods. Prefer using other methods that\n\t * filter by filters such as `getAllByType`.\n\t *\n\t * Queries content from the Prismic repository and returns all matching\n\t * content. If no filters are provided, all documents will be fetched.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.dangerouslyGetAll();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A list of documents matching the query.\n\t */\n\tasync dangerouslyGetAll<TDocument extends TDocuments>(\n\t\tparams: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams = {},\n\t): Promise<TDocument[]> {\n\t\tconst { limit = Infinity, ...actualParams } = params;\n\t\tconst resolvedParams = {\n\t\t\t...actualParams,\n\t\t\tpageSize: Math.min(\n\t\t\t\tlimit,\n\t\t\t\tactualParams.pageSize || this.defaultParams?.pageSize || MAX_PAGE_SIZE,\n\t\t\t),\n\t\t};\n\n\t\tconst documents: TDocument[] = [];\n\t\tlet latestResult: Query<TDocument> | undefined;\n\n\t\twhile (\n\t\t\t(!latestResult || latestResult.next_page) &&\n\t\t\tdocuments.length < limit\n\t\t) {\n\t\t\tconst page = latestResult ? latestResult.page + 1 : undefined;\n\n\t\t\tlatestResult = await this.get<TDocument>({ ...resolvedParams, page });\n\t\t\tdocuments.push(...latestResult.results);\n\n\t\t\tif (latestResult.next_page) {\n\t\t\t\tawait new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));\n\t\t\t}\n\t\t}\n\n\t\treturn documents.slice(0, limit);\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific ID.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @typeParam TDocument- Type of the Prismic document returned.\n\t *\n\t * @param id - ID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with an ID matching the `id` parameter, if a matching\n\t *   document exists.\n\t */\n\tasync getByID<TDocument extends TDocuments>(\n\t\tid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendFilters(params, filter.at(\"document.id\", id)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific IDs.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with IDs matching the\n\t *   `ids` parameter.\n\t */\n\tasync getByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific IDs.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with IDs matching the `ids` parameter.\n\t */\n\tasync getAllByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific UID and\n\t * custom type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUID(\"blog_post\", \"my-first-post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uid - UID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with a UID matching the `uid` parameter, if a\n\t *   matching document exists.\n\t */\n\tasync getByUID<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.at(`my.${documentType}.uid`, uid),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries document from the Prismic repository with specific UIDs and Custom\n\t * Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUIDs(\"blog_post\", [\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with UIDs matching the\n\t *   `uids` parameter.\n\t */\n\tasync getByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific UIDs and\n\t * custom type.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByUIDs([\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with UIDs matching the `uids` parameter.\n\t */\n\tasync getAllByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries a singleton document from the Prismic repository for a specific\n\t * custom type.\n\t *\n\t * @remarks\n\t * A singleton document is one that is configured in Prismic to only allow one\n\t * instance. For example, a repository may be configured to contain just one\n\t * Settings document. This is in contrast to a repeatable custom type which\n\t * allows multiple instances of itself.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getSingle(\"settings\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the singleton custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The singleton document for the custom type, if a matching document\n\t *   exists.\n\t */\n\tasync getSingle<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, typeFilter(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository for a specific custom type.\n\t *\n\t * Use `getAllByType` instead if you need to query all documents for a\n\t * specific custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents of the custom type.\n\t */\n\tasync getByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, typeFilter(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository for a specific Custom\n\t * Type.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents of the custom type.\n\t */\n\tasync getAllByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(appendFilters(params, typeFilter(documentType)));\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with a specific tag.\n\t *\n\t * Use `getAllByTag` instead if you need to query all documents with a\n\t * specific tag.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByTag(\"food\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tag.\n\t */\n\tasync getByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tag)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with a specific tag.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByTag(\"food\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tag.\n\t */\n\tasync getAllByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tag)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tags.\n\t */\n\tasync getByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, everyTagFilter(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tags.\n\t */\n\tasync getAllByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, everyTagFilter(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be\n\t * included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with at least one of the\n\t *   tags.\n\t */\n\tasync getBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be\n\t * included.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllBySomeTags([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with at least one of the tags.\n\t */\n\tasync getAllBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Returns metadata about the Prismic repository, such as its refs, releases,\n\t * and custom types.\n\t *\n\t * @returns Repository metadata.\n\t */\n\tasync getRepository(params?: FetchParams): Promise<Repository> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// return await this.fetch<Repository>(this.endpoint);\n\n\t\tconst url = new URL(this.endpoint);\n\n\t\tif (this.accessToken) {\n\t\t\turl.searchParams.set(\"access_token\", this.accessToken);\n\t\t}\n\n\t\treturn await this.fetch<Repository>(url.toString(), params);\n\t}\n\n\t/**\n\t * Returns a list of all refs for the Prismic repository.\n\t *\n\t * Refs are used to identify which version of the repository's content should\n\t * be queried. All repositories will have at least one ref pointing to the\n\t * latest published content called the \"master ref\".\n\t *\n\t * @returns A list of all refs for the Prismic repository.\n\t */\n\tasync getRefs(params?: FetchParams): Promise<Ref[]> {\n\t\tconst repository = await this.getRepository(params);\n\n\t\treturn repository.refs;\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the ref.\n\t *\n\t * @returns The ref with a matching ID, if it exists.\n\t */\n\tasync getRefByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findRefByID(refs, id);\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getRefByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findRefByLabel(refs, label);\n\t}\n\n\t/**\n\t * Returns the master ref for the Prismic repository. The master ref points to\n\t * the repository's latest published content.\n\t *\n\t * @returns The repository's master ref.\n\t */\n\tasync getMasterRef(params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findMasterRef(refs);\n\t}\n\n\t/**\n\t * Returns a list of all Releases for the Prismic repository. Releases are\n\t * used to group content changes before publishing.\n\t *\n\t * @returns A list of all Releases for the Prismic repository.\n\t */\n\tasync getReleases(params?: FetchParams): Promise<Ref[]> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn refs.filter((ref) => !ref.isMasterRef);\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the Release.\n\t *\n\t * @returns The Release with a matching ID, if it exists.\n\t */\n\tasync getReleaseByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params);\n\n\t\treturn findRefByID(releases, id);\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getReleaseByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params);\n\n\t\treturn findRefByLabel(releases, label);\n\t}\n\n\t/**\n\t * Returns a list of all tags used in the Prismic repository.\n\t *\n\t * @returns A list of all tags used in the repository.\n\t */\n\tasync getTags(params?: FetchParams): Promise<string[]> {\n\t\ttry {\n\t\t\tconst tagsForm = await this.getCachedRepositoryForm(\"tags\", params);\n\n\t\t\tconst url = new URL(tagsForm.action);\n\n\t\t\tif (this.accessToken) {\n\t\t\t\turl.searchParams.set(\"access_token\", this.accessToken);\n\t\t\t}\n\n\t\t\treturn await this.fetch<string[]>(url.toString(), params);\n\t\t} catch {\n\t\t\tconst repository = await this.getRepository(params);\n\n\t\t\treturn repository.tags;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a URL used to query content from the Prismic repository.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A URL string that can be requested to query content.\n\t */\n\tasync buildQueryURL({\n\t\tsignal,\n\t\tfetchOptions,\n\t\t...params\n\t}: Partial<BuildQueryURLArgs> & FetchParams = {}): Promise<string> {\n\t\tconst ref =\n\t\t\tparams.ref || (await this.getResolvedRefString({ signal, fetchOptions }));\n\t\tconst integrationFieldsRef =\n\t\t\tparams.integrationFieldsRef ||\n\t\t\t(await this.getCachedRepository({ signal, fetchOptions }))\n\t\t\t\t.integrationFieldsRef ||\n\t\t\tundefined;\n\n\t\treturn buildQueryURL(this.endpoint, {\n\t\t\t...this.defaultParams,\n\t\t\t...params,\n\t\t\tref,\n\t\t\tintegrationFieldsRef,\n\t\t\troutes: params.routes || this.routes,\n\t\t\tbrokenRoute: params.brokenRoute || this.brokenRoute,\n\t\t\taccessToken: params.accessToken || this.accessToken,\n\t\t});\n\t}\n\n\t/**\n\t * Determines the URL for a previewed document during an active preview\n\t * session. The result of this method should be used to redirect the user to\n\t * the document's URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * \tconst url = client.resolvePreviewURL({\n\t * \tlinkResolver: (document) => `/${document.uid}`\n\t * \tdefaultURL: '/'\n\t * \t})\n\t * ```\n\t *\n\t * @param args - Arguments to configure the URL resolving.\n\t *\n\t * @returns The URL for the previewed document during an active preview\n\t *   session. The user should be redirected to this URL.\n\t */\n\tasync resolvePreviewURL<LinkResolverReturnType>(\n\t\targs: ResolvePreviewArgs<LinkResolverReturnType> & FetchParams,\n\t): Promise<string> {\n\t\tlet documentID: string | undefined | null = args.documentID;\n\t\tlet previewToken: string | undefined | null = args.previewToken;\n\n\t\tif (typeof globalThis.location !== \"undefined\") {\n\t\t\tconst searchParams = new URLSearchParams(globalThis.location.search);\n\n\t\t\tdocumentID = documentID || searchParams.get(\"documentId\");\n\t\t\tpreviewToken = previewToken || searchParams.get(\"token\");\n\t\t} else if (this.refState.httpRequest) {\n\t\t\tif (\"query\" in this.refState.httpRequest) {\n\t\t\t\tdocumentID =\n\t\t\t\t\tdocumentID || (this.refState.httpRequest.query?.documentId as string);\n\t\t\t\tpreviewToken =\n\t\t\t\t\tpreviewToken || (this.refState.httpRequest.query?.token as string);\n\t\t\t} else if (\n\t\t\t\t\"url\" in this.refState.httpRequest &&\n\t\t\t\tthis.refState.httpRequest.url\n\t\t\t) {\n\t\t\t\t// Including \"missing-host://\" by default\n\t\t\t\t// handles a case where Next.js Route Handlers\n\t\t\t\t// only provide the pathname and search\n\t\t\t\t// parameters in the `url` property\n\t\t\t\t// (e.g. `/api/preview?foo=bar`).\n\t\t\t\tconst searchParams = new URL(\n\t\t\t\t\tthis.refState.httpRequest.url,\n\t\t\t\t\t\"missing-host://\",\n\t\t\t\t).searchParams;\n\n\t\t\t\tdocumentID = documentID || searchParams.get(\"documentId\");\n\t\t\t\tpreviewToken = previewToken || searchParams.get(\"token\");\n\t\t\t}\n\t\t}\n\n\t\tif (documentID != null && previewToken != null) {\n\t\t\tconst document = await this.getByID(documentID, {\n\t\t\t\tref: previewToken,\n\t\t\t\tlang: \"*\",\n\t\t\t\tsignal: args.signal,\n\t\t\t\tfetchOptions: args.fetchOptions,\n\t\t\t});\n\n\t\t\tconst url = asLink(document, { linkResolver: args.linkResolver });\n\n\t\t\tif (typeof url === \"string\") {\n\t\t\t\treturn url;\n\t\t\t}\n\t\t}\n\n\t\treturn args.defaultURL;\n\t}\n\n\t/**\n\t * Configures the client to query the latest published content for all future\n\t * queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryLatestContent();\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t */\n\tqueryLatestContent(): void {\n\t\tthis.refState.mode = RefStateMode.Master;\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its ID for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param releaseID - The ID of the Release.\n\t */\n\tqueryContentFromReleaseByID(releaseID: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseID,\n\t\t\treleaseID,\n\t\t};\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its label for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByLabel(\"My Release\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param releaseLabel - The label of the Release.\n\t */\n\tqueryContentFromReleaseByLabel(releaseLabel: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseLabel,\n\t\t\treleaseLabel,\n\t\t};\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific ref. The ref can be\n\t * provided as a string or a function.\n\t *\n\t * If a function is provided, the ref is fetched lazily before each query. The\n\t * function may also be asynchronous.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromRef(\"my-ref\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param ref - The ref or a function that returns the ref from which to query\n\t *   content.\n\t */\n\tqueryContentFromRef(ref: RefStringOrThunk): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.Manual,\n\t\t\tref,\n\t\t};\n\t}\n\n\t/**\n\t * A `fetch()` function to be used with GraphQL clients configured for\n\t * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n\t * and Authorization headers. Queries will automatically be minified by\n\t * removing whitespace where possible.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const graphQLClient = new ApolloClient({\n\t * \tlink: new HttpLink({\n\t * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n\t * \t\t// Provide `client.graphQLFetch` as the fetch implementation.\n\t * \t\tfetch: client.graphQLFetch,\n\t * \t\t// Using GET is required.\n\t * \t\tuseGETForQueries: true,\n\t * \t}),\n\t * \tcache: new InMemoryCache(),\n\t * });\n\t * ```\n\t *\n\t * @param input - The `fetch()` `input` parameter. Only strings are supported.\n\t * @param init - The `fetch()` `init` parameter. Only plain objects are\n\t *   supported.\n\t *\n\t * @returns The `fetch()` Response for the request.\n\t *\n\t * @experimental\n\t */\n\tasync graphQLFetch(\n\t\tinput: RequestInfo,\n\t\tinit?: Omit<RequestInit, \"signal\"> & { signal?: AbortSignalLike },\n\t): Promise<Response> {\n\t\tconst cachedRepository = await this.getCachedRepository();\n\t\tconst ref = await this.getResolvedRefString();\n\n\t\tconst unsanitizedHeaders: Record<string, string> = {\n\t\t\t\"Prismic-ref\": ref,\n\t\t\tAuthorization: this.accessToken ? `Token ${this.accessToken}` : \"\",\n\t\t\t// Asserting `init.headers` is a Record since popular GraphQL\n\t\t\t// libraries pass this as a Record. Header objects as input\n\t\t\t// are unsupported.\n\t\t\t...(init ? (init.headers as Record<string, string>) : {}),\n\t\t};\n\n\t\tif (cachedRepository.integrationFieldsRef) {\n\t\t\tunsanitizedHeaders[\"Prismic-integration-field-ref\"] =\n\t\t\t\tcachedRepository.integrationFieldsRef;\n\t\t}\n\n\t\t// Normalize header keys to lowercase. This prevents header\n\t\t// conflicts between the Prismic client and the GraphQL\n\t\t// client.\n\t\tconst headers: Record<string, string> = {};\n\t\tfor (const key in unsanitizedHeaders) {\n\t\t\tif (unsanitizedHeaders[key]) {\n\t\t\t\theaders[key.toLowerCase()] =\n\t\t\t\t\tunsanitizedHeaders[key as keyof typeof unsanitizedHeaders];\n\t\t\t}\n\t\t}\n\n\t\tconst url = new URL(\n\t\t\t// Asserting `input` is a string since popular GraphQL\n\t\t\t// libraries pass this as a string. Request objects as\n\t\t\t// input are unsupported.\n\t\t\tinput as string,\n\t\t);\n\n\t\t// This prevents the request from being cached unnecessarily.\n\t\t// Without adding this `ref` param, re-running a query\n\t\t// could return a locally cached response, even if the\n\t\t// `ref` changed. This happens because the URL is\n\t\t// identical when the `ref` is not included. Caches may ignore\n\t\t// headers.\n\t\t//\n\t\t// The Prismic GraphQL API ignores the `ref` param.\n\t\turl.searchParams.set(\"ref\", ref);\n\n\t\tconst query = url.searchParams.get(\"query\");\n\t\tif (query) {\n\t\t\turl.searchParams.set(\n\t\t\t\t\"query\",\n\t\t\t\t// Compress the GraphQL query (if it exists) by\n\t\t\t\t// removing whitespace. This is done to\n\t\t\t\t// optimize the query size and avoid\n\t\t\t\t// hitting the upper limit of GET requests\n\t\t\t\t// (2048 characters).\n\t\t\t\tminifyGraphQLQuery(query),\n\t\t\t);\n\t\t}\n\n\t\treturn (await this.fetchFn(url.toString(), {\n\t\t\t...init,\n\t\t\theaders,\n\t\t})) as Response;\n\t}\n\n\t/**\n\t * Returns a cached version of `getRepository` with a TTL.\n\t *\n\t * @returns Cached repository metadata.\n\t */\n\tprivate async getCachedRepository(params?: FetchParams): Promise<Repository> {\n\t\tif (\n\t\t\t!this.cachedRepository ||\n\t\t\tDate.now() >= this.cachedRepositoryExpiration\n\t\t) {\n\t\t\tthis.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;\n\t\t\tthis.cachedRepository = await this.getRepository(params);\n\t\t}\n\n\t\treturn this.cachedRepository;\n\t}\n\n\t/**\n\t * Returns a cached Prismic repository form. Forms are used to determine API\n\t * endpoints for types of repository data.\n\t *\n\t * @param name - Name of the form.\n\t *\n\t * @returns The repository form.\n\t *\n\t * @throws If a matching form cannot be found.\n\t */\n\tprivate async getCachedRepositoryForm(\n\t\tname: string,\n\t\tparams?: FetchParams,\n\t): Promise<Form> {\n\t\tconst cachedRepository = await this.getCachedRepository(params);\n\t\tconst form = cachedRepository.forms[name];\n\n\t\tif (!form) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Form with name \"${name}\" could not be found`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\treturn form;\n\t}\n\n\t/**\n\t * Returns the ref needed to query based on the client's current state. This\n\t * method may make a network request to fetch a ref or resolve the user's ref\n\t * thunk.\n\t *\n\t * If auto previews are enabled, the preview ref takes priority if available.\n\t *\n\t * The following strategies are used depending on the client's state:\n\t *\n\t * - If the user called `queryLatestContent`: Use the repository's master ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is\n\t *   fetched.\n\t * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n\t *   to the master ref if the ref is not a string.\n\t *\n\t * @returns The ref to use during a query.\n\t */\n\tprivate async getResolvedRefString(params?: FetchParams): Promise<string> {\n\t\tif (this.refState.autoPreviewsEnabled) {\n\t\t\tlet previewRef: string | undefined;\n\n\t\t\tlet cookieJar: string | null | undefined;\n\n\t\t\tif (this.refState.httpRequest?.headers) {\n\t\t\t\tif (\n\t\t\t\t\t\"get\" in this.refState.httpRequest.headers &&\n\t\t\t\t\ttypeof this.refState.httpRequest.headers.get === \"function\"\n\t\t\t\t) {\n\t\t\t\t\t// Web API Headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.get(\"cookie\");\n\t\t\t\t} else if (\"cookie\" in this.refState.httpRequest.headers) {\n\t\t\t\t\t// Express-style headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.cookie;\n\t\t\t\t}\n\t\t\t} else if (globalThis.document?.cookie) {\n\t\t\t\tcookieJar = globalThis.document.cookie;\n\t\t\t}\n\n\t\t\tif (cookieJar) {\n\t\t\t\tpreviewRef = getPreviewCookie(cookieJar);\n\t\t\t}\n\n\t\t\tif (previewRef) {\n\t\t\t\treturn previewRef;\n\t\t\t}\n\t\t}\n\n\t\tconst cachedRepository = await this.getCachedRepository(params);\n\n\t\tconst refModeType = this.refState.mode;\n\t\tif (refModeType === RefStateMode.ReleaseID) {\n\t\t\treturn findRefByID(cachedRepository.refs, this.refState.releaseID).ref;\n\t\t} else if (refModeType === RefStateMode.ReleaseLabel) {\n\t\t\treturn findRefByLabel(cachedRepository.refs, this.refState.releaseLabel)\n\t\t\t\t.ref;\n\t\t} else if (refModeType === RefStateMode.Manual) {\n\t\t\tconst res = await castThunk(this.refState.ref)();\n\n\t\t\tif (typeof res === \"string\") {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\treturn findMasterRef(cachedRepository.refs).ref;\n\t}\n\n\t/**\n\t * Performs a network request using the configured `fetch` function. It\n\t * assumes all successful responses will have a JSON content type. It also\n\t * normalizes unsuccessful network requests.\n\t *\n\t * @typeParam T - The JSON response.\n\t *\n\t * @param url - URL to the resource to fetch.\n\t * @param params - Prismic REST API parameters for the network request.\n\t *\n\t * @returns The JSON response from the network request.\n\t */\n\tprivate async fetch<T = unknown>(\n\t\turl: string,\n\t\tparams: FetchParams = {},\n\t): Promise<T> {\n\t\tconst requestInit: RequestInitLike = {\n\t\t\t...this.fetchOptions,\n\t\t\t...params.fetchOptions,\n\t\t\theaders: {\n\t\t\t\t...this.fetchOptions?.headers,\n\t\t\t\t...params.fetchOptions?.headers,\n\t\t\t},\n\t\t\tsignal:\n\t\t\t\tparams.fetchOptions?.signal ||\n\t\t\t\tparams.signal ||\n\t\t\t\tthis.fetchOptions?.signal,\n\t\t};\n\n\t\tlet job: Promise<FetchJobResult>;\n\n\t\t// `fetchJobs` is keyed twice: first by the URL and again by is\n\t\t// signal, if one exists.\n\t\t//\n\t\t// Using two keys allows us to reuse fetch requests for\n\t\t// equivalent URLs, but eject when we detect unique signals.\n\t\tif (this.fetchJobs[url] && this.fetchJobs[url].has(requestInit.signal)) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\tjob = this.fetchJobs[url].get(requestInit.signal)!;\n\t\t} else {\n\t\t\tthis.fetchJobs[url] = this.fetchJobs[url] || new Map();\n\n\t\t\tjob = this.fetchFn(url, requestInit)\n\t\t\t\t.then(async (res) => {\n\t\t\t\t\t// We can assume Prismic REST API responses\n\t\t\t\t\t// will have a `application/json`\n\t\t\t\t\t// Content Type. If not, this will\n\t\t\t\t\t// throw, signaling an invalid\n\t\t\t\t\t// response.\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\tlet json: any = undefined;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = await res.json();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: res.status,\n\t\t\t\t\t\theaders: res.headers,\n\t\t\t\t\t\tjson,\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t\t.finally(() => {\n\t\t\t\t\tthis.fetchJobs[url].delete(requestInit.signal);\n\n\t\t\t\t\tif (this.fetchJobs[url].size === 0) {\n\t\t\t\t\t\tdelete this.fetchJobs[url];\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tthis.fetchJobs[url].set(requestInit.signal, job);\n\t\t}\n\n\t\tconst res = await job;\n\n\t\tif (res.status !== 404 && res.json == null) {\n\t\t\tthrow new PrismicError(undefined, url, res.json);\n\t\t}\n\n\t\tswitch (res.status) {\n\t\t\t// Successful\n\t\t\tcase 200: {\n\t\t\t\treturn res.json;\n\t\t\t}\n\n\t\t\t// Bad Request\n\t\t\t// - Invalid filter syntax\n\t\t\t// - Ref not provided (ignored)\n\t\t\tcase 400: {\n\t\t\t\tthrow new ParsingError(res.json.message, url, res.json);\n\t\t\t}\n\n\t\t\t// Unauthorized\n\t\t\t// - Missing access token for repository endpoint\n\t\t\t// - Incorrect access token for repository endpoint\n\t\t\tcase 401:\n\t\t\t// Forbidden\n\t\t\t// - Missing access token for query endpoint\n\t\t\t// - Incorrect access token for query endpoint\n\t\t\tcase 403: {\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\tres.json.error || res.json.message,\n\t\t\t\t\turl,\n\t\t\t\t\tres.json,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Not Found\n\t\t\t// - Incorrect repository name (this response has an empty body)\n\t\t\t// - Ref does not exist\n\t\t\t// - Preview token is expired\n\t\t\tcase 404: {\n\t\t\t\tif (res.json === undefined) {\n\t\t\t\t\tthrow new RepositoryNotFoundError(\n\t\t\t\t\t\t`Prismic repository not found. Check that \"${this.endpoint}\" is pointing to the correct repository.`,\n\t\t\t\t\t\turl,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (res.json.type === \"api_notfound_error\") {\n\t\t\t\t\tthrow new RefNotFoundError(res.json.message, url, res.json);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tres.json.type === \"api_security_error\" &&\n\t\t\t\t\t/preview token.*expired/i.test(res.json.message)\n\t\t\t\t) {\n\t\t\t\t\tthrow new PreviewTokenExpiredError(res.json.message, url, res.json);\n\t\t\t\t}\n\n\t\t\t\tthrow new NotFoundError(res.json.message, url, res.json);\n\t\t\t}\n\n\t\t\t// Gone\n\t\t\t// - Ref is expired\n\t\t\tcase 410: {\n\t\t\t\tthrow new RefExpiredError(res.json.message, url, res.json);\n\t\t\t}\n\n\t\t\t// Too Many Requests\n\t\t\t// - Exceeded the maximum number of requests per second\n\t\t\tcase 429: {\n\t\t\t\tconst parsedRetryAfter = Number(res.headers.get(\"retry-after\"));\n\t\t\t\tconst delay = Number.isNaN(parsedRetryAfter)\n\t\t\t\t\t? DEFUALT_RETRY_AFTER_MS\n\t\t\t\t\t: parsedRetryAfter;\n\n\t\t\t\treturn await new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresolve(await this.fetch(url, params));\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthrow new PrismicError(undefined, url, res.json);\n\t}\n}\n", "import { PrismicError } from \"./errors/PrismicError\";\n\nimport { isRepositoryName } from \"./isRepositoryName\";\n\n/**\n * Get a repository's Prismic GraphQL endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n *\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic REST API V2 endpoint\n */\nexport const getGraphQLEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/graphql` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/graphql` as const;\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t}\n};\n", "import { PrismicError } from \"./errors/PrismicError\";\n\nimport { isRepositoryName } from \"./isRepositoryName\";\n\n/**\n * Returns the URL for a Prismic repository's Prismic Toolbar script. Use the\n * URL to inject the script into your app.\n *\n * @example\n *\n * ```typescriptreact\n * // In Next.js apps, use `next/script` in your `app/layout.tsx` file.\n *\n * import Script from \"next/script\";\n * import * as prismic from \"@prismicio/client\";\n *\n * export default function RootLayout({\n * \tchildren,\n * }: {\n * \tchildren: React.ReactNode,\n * }) {\n * \tconst toolbarSrc = prismic.getToolbarSrc(\"my-repo\");\n *\n * \treturn (\n * \t\t<html lang=\"en\">\n * \t\t\t<body>{children}</body>\n * \t\t\t<Script src={toolbarSrc} />\n * \t\t</html>\n * \t);\n * }\n * ```\n *\n * @param repositoryName - The name of the Prismic repository. For example,\n *   `\"my-repo\"` if the repository URL is `my-repo.prismic.io`.\n *\n * @returns The URL for the given Prismic repository's Prismic Toolbar script.\n */\nexport const getToolbarSrc = <TRepositoryName extends string>(\n\trepositoryName: TRepositoryName,\n): `https://static.cdn.prismic.io/prismic.js?new=true&repo=${TRepositoryName}` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://static.cdn.prismic.io/prismic.js?new=true&repo=${repositoryName}` as const;\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t}\n};\n", "import type { DateField } from \"../types/value/date\";\nimport type { TimestampField } from \"../types/value/timestamp\";\n\n/**\n * The return type of `asDate()`.\n */\ntype AsDateReturnType<\n\tField extends DateField | TimestampField | null | undefined,\n> = Field extends DateField<\"filled\"> | TimestampField<\"filled\"> ? Date : null;\n\n/**\n * Transforms a date or timestamp field into a JavaScript Date object\n *\n * @param dateOrTimestampField - A date or timestamp field from Prismic\n *\n * @returns A Date object, null if provided date is falsy\n *\n * @see Templating date field from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#date-and-timestamp}\n */\nexport const asDate = <\n\tField extends DateField | TimestampField | null | undefined,\n>(\n\tdateOrTimestampField: Field,\n): AsDateReturnType<Field> => {\n\tif (!dateOrTimestampField) {\n\t\treturn null as AsDateReturnType<Field>;\n\t}\n\n\t// If field is a timestamp field...\n\tif (dateOrTimestampField.length === 24) {\n\t\t/**\n\t\t * Converts basic ISO 8601 to ECMAScript simplified ISO 8601 format for\n\t\t * browser compatibility issues\n\t\t *\n\t\t * From: YYYY-MM-DDTHH:mm:ssZ To: YYYY-MM-DDTHH:mm:ss.sssZ\n\t\t *\n\t\t * @see MDN documentation: {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date#timestamp_string}\n\t\t * @see ECMAScript 2020 language specification: {@link https://262.ecma-international.org/11.0/#sec-date-time-string-format}\n\t\t * @see Related forum issue: {@link https://community.prismic.io/t/prismics-date-api/2520}\n\t\t * @see Regex101 expression: {@link https://regex101.com/r/jxyETT/1}\n\t\t */\n\t\treturn new Date(\n\t\t\tdateOrTimestampField.replace(/(\\+|-)(\\d{2})(\\d{2})$/, \".000$1$2:$3\"),\n\t\t) as AsDateReturnType<Field>;\n\t} else {\n\t\t// ...else field is a date field\n\t\treturn new Date(dateOrTimestampField) as AsDateReturnType<Field>;\n\t}\n};\n", "/**\n * Determines if a URL is internal or external.\n *\n * @param url - The URL to check if internal or external.\n *\n * @returns `true` if `url` is internal, `false` otherwise.\n */\n// TODO: This does not detect all relative URLs as internal such as `about` or `./about`. This function assumes relative URLs start with a \"/\" or \"#\"`.\nexport const isInternalURL = (url: string): boolean => {\n\tconst isInternal = /^(\\/(?!\\/)|#)/.test(url);\n\tconst isSpecialLink = !isInternal && !/^https?:\\/\\//.test(url);\n\n\treturn isInternal && !isSpecialLink;\n};\n", "import type { ColorField } from \"../types/value/color\";\nimport type { ContentRelationshipField } from \"../types/value/contentRelationship\";\nimport type { DateField } from \"../types/value/date\";\nimport type { AnyOEmbed, EmbedField } from \"../types/value/embed\";\nimport type { GeoPointField } from \"../types/value/geoPoint\";\nimport type { GroupField, NestedGroupField } from \"../types/value/group\";\nimport type { ImageField, ImageFieldImage } from \"../types/value/image\";\nimport type { IntegrationField } from \"../types/value/integration\";\nimport type { KeyTextField } from \"../types/value/keyText\";\nimport type { LinkField } from \"../types/value/link\";\nimport type { LinkToMediaField } from \"../types/value/linkToMedia\";\nimport type { NumberField } from \"../types/value/number\";\nimport type { RichTextField } from \"../types/value/richText\";\nimport type { SelectField } from \"../types/value/select\";\nimport type { SharedSlice } from \"../types/value/sharedSlice\";\nimport type { Slice } from \"../types/value/slice\";\nimport type { SliceZone } from \"../types/value/sliceZone\";\nimport type { TimestampField } from \"../types/value/timestamp\";\nimport type { TitleField } from \"../types/value/title\";\nimport type { AnyRegularField } from \"../types/value/types\";\n\n/**\n * Determines if a value is not nullish (i.e. not `null` or `undefined`). This\n * is used to check if nullable field values are filled.\n *\n * @param input - The value to check.\n *\n * @returns `true` if `input` is not nullish, `false` otherwise.\n */\nconst isNonNullish = <T>(input: T): input is NonNullable<T> => {\n\treturn input != null;\n};\n\n/**\n * Determines if an array is not empty. This is used to check if array-based\n * fields are filled.\n *\n * @param input - The array to check.\n *\n * @returns `true` if `input` has at least one element, `false` otherwise.\n */\nconst isNonEmptyArray = <T>(input: T[]): input is [T, ...T[]] => {\n\treturn !!input.length;\n};\n\n/**\n * Determines if a rich text field is filled.\n *\n * @param field - rich text field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const richText = (\n\tfield: RichTextField | null | undefined,\n): field is RichTextField<\"filled\"> => {\n\tif (!isNonNullish(field)) {\n\t\treturn false;\n\t} else if (field.length === 1 && \"text\" in field[0]) {\n\t\treturn !!field[0].text;\n\t} else {\n\t\treturn !!field.length;\n\t}\n};\n\n/**\n * Determines if a title field is filled.\n *\n * @param field - Title field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const title = richText as (\n\tfield: TitleField | null | undefined,\n) => field is TitleField<\"filled\">;\n\n/**\n * Determines if an Image thumbnail is filled.\n *\n * @param thumbnail - Image thumbnail to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const imageThumbnail = (\n\tthumbnail: ImageFieldImage | null | undefined,\n): thumbnail is ImageFieldImage<\"filled\"> => {\n\treturn isNonNullish(thumbnail) && !!thumbnail.url;\n};\n\n/**\n * Determines if an image field is filled.\n *\n * @param field - Image field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const image = imageThumbnail as <\n\tThumbnailNames extends string | null = never,\n>(\n\tfield: ImageField<ThumbnailNames> | null | undefined,\n) => field is ImageField<ThumbnailNames, \"filled\">;\n\n/**\n * Determines if a link field is filled.\n *\n * @param field - Link field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const link = <\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n>(\n\tfield: LinkField<TypeEnum, LangEnum, DataInterface> | null | undefined,\n): field is LinkField<TypeEnum, LangEnum, DataInterface, \"filled\"> => {\n\treturn isNonNullish(field) && (\"id\" in field || \"url\" in field);\n};\n\n/**\n * Determines if a link to media field is filled.\n *\n * @param field - Link to media field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const linkToMedia = link as (\n\tfield: LinkToMediaField | null | undefined,\n) => field is LinkToMediaField<\"filled\">;\n\n/**\n * Determines if a content relationship field is filled.\n *\n * @param field - Content Relationship field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const contentRelationship = link as <\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n>(\n\tfield:\n\t\t| ContentRelationshipField<TypeEnum, LangEnum, DataInterface>\n\t\t| null\n\t\t| undefined,\n) => field is ContentRelationshipField<\n\tTypeEnum,\n\tLangEnum,\n\tDataInterface,\n\t\"filled\"\n>;\n\n/**\n * Determines if a date field is filled.\n *\n * @param field - Date field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const date = isNonNullish as (\n\tfield: DateField | null | undefined,\n) => field is DateField<\"filled\">;\n\n/**\n * Determines if a timestamp field is filled.\n *\n * @param field - Timestamp field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const timestamp = isNonNullish as (\n\tfield: TimestampField | null | undefined,\n) => field is TimestampField<\"filled\">;\n\n/**\n * Determines if a color field is filled.\n *\n * @param field - Color field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const color = isNonNullish as (\n\tfield: ColorField | null | undefined,\n) => field is ColorField<\"filled\">;\n\n/**\n * Determines if a number field is filled.\n *\n * @param field - Number field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const number = isNonNullish as (\n\tfield: NumberField | null | undefined,\n) => field is NumberField<\"filled\">;\n\n/**\n * Determines if a key text field is filled.\n *\n * @param field - Key Text field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const keyText = (\n\tfield: KeyTextField | null | undefined,\n): field is KeyTextField<\"filled\"> => {\n\treturn isNonNullish(keyText) && !!field;\n};\n\n/**\n * Determines if a select field is filled.\n *\n * @param field - Select field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const select = isNonNullish as <Enum extends string>(\n\tfield: SelectField<Enum> | null | undefined,\n) => field is SelectField<Enum, \"filled\">;\n\n/**\n * Determines if an embed field is filled.\n *\n * @param field - Embed field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const embed = <Field extends EmbedField<AnyOEmbed>>(\n\tfield: Field | null | undefined,\n): field is Extract<Field, EmbedField<AnyOEmbed, \"filled\">> => {\n\treturn isNonNullish(field) && !!field.embed_url;\n};\n\n/**\n * Determines if a geopoint field is filled.\n *\n * @param field - GeoPoint field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const geoPoint = (\n\tfield: GeoPointField | null | undefined,\n): field is GeoPointField<\"filled\"> => {\n\treturn isNonNullish(field) && \"longitude\" in field;\n};\n\n/**\n * Determines if an integration field is filled.\n *\n * @param field - Integration field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const integrationField = isNonNullish as <\n\tData extends Record<string, unknown>,\n>(\n\tfield: IntegrationField<Data> | null | undefined,\n) => field is IntegrationField<Data, \"filled\">;\n/**\n * @deprecated Renamed to `integrationField`.\n */\n// TODO: Remove when we remove support for deprecated `integrationFields` export.\nexport const integrationFields = integrationField;\n\n/**\n * Determines if a Group has at least one item.\n *\n * @param group - Group to check.\n *\n * @returns `true` if `group` contains at least one item, `false` otherwise.\n */\nexport const group = <\n\tFields extends Record<string, AnyRegularField | NestedGroupField>,\n>(\n\tgroup: GroupField<Fields> | null | undefined,\n): group is GroupField<Fields, \"filled\"> => {\n\treturn isNonNullish(group) && isNonEmptyArray(group);\n};\n\n/**\n * Determines if a Slice Zone has at least one Slice.\n *\n * @param slices - Slice Zone to check.\n *\n * @returns `true` if `slices` contains at least one Slice, `false` otherwise.\n */\nexport const sliceZone = <Slices extends Slice | SharedSlice>(\n\tslices: SliceZone<Slices> | null | undefined,\n): slices is SliceZone<Slices, \"filled\"> => {\n\treturn isNonNullish(slices) && isNonEmptyArray(slices);\n};\n", "import { isInternalURL } from \"../lib/isInternalURL\";\n\nimport type { FilledContentRelationshipField } from \"../types/value/contentRelationship\";\nimport type { PrismicDocument } from \"../types/value/document\";\nimport { FilledLinkToWebField, LinkField } from \"../types/value/link\";\nimport type { FilledLinkToMediaField } from \"../types/value/linkToMedia\";\n\nimport { AsLinkReturnType, LinkResolverFunction, asLink } from \"./asLink\";\nimport { link as isFilledLink } from \"./isFilled\";\n\ntype AsLinkAttrsConfigRelArgs<\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = {\n\thref:\n\t\t| NonNullable<AsLinkReturnType<LinkResolverFunctionReturnType, Field>>\n\t\t| undefined;\n\tisExternal: boolean;\n\ttarget?: string;\n};\n\nexport type AsLinkAttrsConfig<\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = {\n\tlinkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType>;\n\trel?: (\n\t\targs: AsLinkAttrsConfigRelArgs<LinkResolverFunctionReturnType, Field>,\n\t) => string | undefined | void;\n};\n\n/**\n * The return type of `asLinkAttrs()`.\n */\ntype AsLinkAttrsReturnType<\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = Field extends\n\t| FilledLinkToWebField\n\t| FilledLinkToMediaField\n\t| FilledContentRelationshipField\n\t| PrismicDocument\n\t? {\n\t\t\thref:\n\t\t\t\t| NonNullable<AsLinkReturnType<LinkResolverFunctionReturnType, Field>>\n\t\t\t\t| undefined;\n\t\t\ttarget?: string;\n\t\t\trel?: string;\n\t  }\n\t: {\n\t\t\thref?: undefined;\n\t\t\ttarget?: undefined;\n\t\t\trel?: undefined;\n\t  };\n\n/**\n * Resolves any type of link field or Prismic document to a set of link\n * attributes. The attributes are designed to be passed to link HTML elements,\n * like `<a>`.\n *\n * If a resolved URL is external (i.e. starts with a protocol like `https://`),\n * `rel` is returned as `\"noreferrer\"`.\n *\n * @typeParam LinkResolverFunctionReturnType - link resolver function return\n *   type\n * @typeParam Field - Link field or Prismic document to resolve to link\n *   attributes\n *\n * @param linkFieldOrDocument - Any kind of link field or a document to resolve\n * @param config - Configuration that determines the output of `asLinkAttrs()`\n *\n * @returns Resolved set of link attributes or, if the provided link field or\n *   document is empty, and empty object\n *\n * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n * @see Prismic API `routes` options documentation: {@link https://prismic.io/docs/route-resolver}\n */\nexport const asLinkAttrs = <\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n>(\n\tlinkFieldOrDocument: Field,\n\tconfig: AsLinkAttrsConfig<LinkResolverFunctionReturnType> = {},\n): AsLinkAttrsReturnType<LinkResolverFunctionReturnType> => {\n\tif (\n\t\tlinkFieldOrDocument &&\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501\n\t\t(\"link_type\" in linkFieldOrDocument\n\t\t\t? isFilledLink(linkFieldOrDocument)\n\t\t\t: linkFieldOrDocument)\n\t) {\n\t\tconst target =\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t// @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501\n\t\t\t\"target\" in linkFieldOrDocument ? linkFieldOrDocument.target : undefined;\n\n\t\tconst rawHref = asLink(linkFieldOrDocument, config.linkResolver);\n\t\tconst href =\n\t\t\trawHref == null ? undefined : (rawHref as NonNullable<typeof rawHref>);\n\n\t\tconst isExternal = typeof href === \"string\" ? !isInternalURL(href) : false;\n\n\t\tconst rel = config.rel\n\t\t\t? config.rel({ href, isExternal, target })\n\t\t\t: isExternal\n\t\t\t? \"noreferrer\"\n\t\t\t: undefined;\n\n\t\treturn {\n\t\t\thref,\n\t\t\ttarget,\n\t\t\trel: rel == null ? undefined : rel,\n\t\t};\n\t}\n\n\treturn {};\n};\n", "import { RTTextNode, RichTextField } from \"../types/value/richText\";\n\n/**\n * Serializes a rich text or title field to a plain text string\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param separator - Separator used to join each element, defaults to a space\n *\n * @returns Plain text equivalent of the provided rich text or title field\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const asText = (\n\trichTextField: RichTextField,\n\tseparator = \" \",\n): string => {\n\tlet result = \"\";\n\n\tfor (let i = 0; i < richTextField.length; i++) {\n\t\tif (\"text\" in richTextField[i]) {\n\t\t\tresult +=\n\t\t\t\t(result ? separator : \"\") + (richTextField[i] as RTTextNode).text;\n\t\t}\n\t}\n\n\treturn result;\n};\n", "import { RichTextField } from \"../types/value/richText\";\n\nimport { asText as baseAsText } from \"../richtext/asText\";\n\n/**\n * Configuration that determines the output of `asText()`.\n */\ntype AsTextConfig = {\n\t/**\n\t * Separator used to join each element.\n\t *\n\t * @defaultValue ` ` (a space)\n\t */\n\tseparator?: string;\n};\n\n// TODO: Remove when we remove support for deprecated tuple-style configuration.\n/**\n * @deprecated Use object-style configuration instead.\n */\ntype AsTextDeprecatedTupleConfig = [separator?: string];\n\n/**\n * The return type of `asText()`.\n */\ntype AsTextReturnType<Field extends RichTextField | null | undefined> =\n\tField extends RichTextField ? string : null;\n\nexport const asText: {\n\t/**\n\t * Serializes a rich text or title field to a plain text string.\n\t *\n\t * @param richTextField - A rich text or title field from Prismic\n\t * @param config - Configuration that determines the output of `asText()`\n\t *\n\t * @returns Plain text equivalent of the provided rich text or title field\n\t *\n\t * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\tconfig?: AsTextConfig,\n\t): AsTextReturnType<Field>;\n\n\t/**\n\t * Serializes a rich text or title field to a plain text string.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @param richTextField - A rich text or title field from Prismic\n\t * @param separator - Separator used to join each element, defaults to a space\n\t *\n\t * @returns Plain text equivalent of the provided rich text or title field\n\t *\n\t * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\t...config: AsTextDeprecatedTupleConfig\n\t): AsTextReturnType<Field>;\n} = <Field extends RichTextField | null | undefined>(\n\trichTextField: Field,\n\t// TODO: Rename to `config` when we remove support for deprecated tuple-style configuration.\n\t...configObjectOrTuple: [config?: AsTextConfig] | AsTextDeprecatedTupleConfig\n): AsTextReturnType<Field> => {\n\tif (richTextField) {\n\t\t// TODO: Remove when we remove support for deprecated tuple-style configuration.\n\t\tconst [configObjectOrSeparator] = configObjectOrTuple;\n\t\tlet config: AsTextConfig;\n\t\tif (typeof configObjectOrSeparator === \"string\") {\n\t\t\tconfig = {\n\t\t\t\tseparator: configObjectOrSeparator,\n\t\t\t};\n\t\t} else {\n\t\t\tconfig = { ...configObjectOrSeparator };\n\t\t}\n\n\t\treturn baseAsText(\n\t\t\trichTextField,\n\t\t\tconfig.separator,\n\t\t) as AsTextReturnType<Field>;\n\t} else {\n\t\treturn null as AsTextReturnType<Field>;\n\t}\n};\n", "/*\n ** Core logic from https://github.com/component/escape-html\n ** Many thanks to @component\n */\n\nconst matchHtmlRegExp = /[\"'&<>]/;\n\nexport const escapeHTML = (string?: string | null): string => {\n\tconst str = \"\" + string;\n\tconst match = matchHtmlRegExp.exec(str);\n\n\tif (!match) {\n\t\treturn str;\n\t}\n\n\tlet escape;\n\tlet html = \"\";\n\tlet index = 0;\n\tlet lastIndex = 0;\n\n\tfor (index = match.index; index < str.length; index++) {\n\t\tswitch (str.charCodeAt(index)) {\n\t\t\tcase 34: // \"\n\t\t\t\tescape = \"&quot;\";\n\t\t\t\tbreak;\n\t\t\tcase 38: // &\n\t\t\t\tescape = \"&amp;\";\n\t\t\t\tbreak;\n\t\t\tcase 39: // '\n\t\t\t\tescape = \"&#39;\";\n\t\t\t\tbreak;\n\t\t\tcase 60: // <\n\t\t\t\tescape = \"&lt;\";\n\t\t\t\tbreak;\n\t\t\tcase 62: // >\n\t\t\t\tescape = \"&gt;\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (lastIndex !== index) {\n\t\t\thtml += str.substring(lastIndex, index);\n\t\t}\n\n\t\tlastIndex = index + 1;\n\t\thtml += escape;\n\t}\n\n\treturn lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n};\n", "import type { RichTextMapSerializer } from \"../richtext/types\";\nimport { LinkType } from \"../types/value/link\";\nimport { RTAnyNode } from \"../types/value/richText\";\n\nimport {\n\tHTMLRichTextMapSerializer,\n\tHTMLStrictRichTextMapSerializer,\n} from \"../helpers/asHTML\";\nimport { LinkResolverFunction, asLink } from \"../helpers/asLink\";\n\nimport { escapeHTML } from \"./escapeHTML\";\n\ntype Attributes = Record<string, string | boolean | null | undefined>;\nconst formatAttributes = (node: RTAnyNode, attributes: Attributes): string => {\n\tconst _attributes = { ...attributes };\n\n\t// Add label to attributes\n\tif (\"data\" in node && \"label\" in node.data && node.data.label) {\n\t\t_attributes.class = _attributes.class\n\t\t\t? `${_attributes.class} ${node.data.label}`\n\t\t\t: node.data.label;\n\t}\n\n\tconst result = [];\n\n\tfor (const key in _attributes) {\n\t\tconst value = _attributes[key];\n\n\t\tif (value) {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tresult.push(key);\n\t\t\t} else {\n\t\t\t\tresult.push(`${key}=\"${escapeHTML(value)}\"`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add a space at the beginning if there's any result\n\tif (result.length) {\n\t\tresult.unshift(\"\");\n\t}\n\n\treturn result.join(\" \");\n};\n\nconst getGeneralAttributes = (\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[keyof HTMLRichTextMapSerializer],\n): Attributes => {\n\treturn serializerOrShorthand && typeof serializerOrShorthand !== \"function\"\n\t\t? serializerOrShorthand\n\t\t: {};\n};\n\nexport const serializeStandardTag = <\n\tBlockType extends keyof RichTextMapSerializer<string>,\n>(\n\ttag: string,\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[BlockType],\n): NonNullable<HTMLStrictRichTextMapSerializer[BlockType]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand);\n\n\treturn (({ node, children }) => {\n\t\treturn `<${tag}${formatAttributes(\n\t\t\tnode,\n\t\t\tgeneralAttributes,\n\t\t)}>${children}</${tag}>`;\n\t}) as NonNullable<HTMLStrictRichTextMapSerializer[BlockType]>;\n};\n\nexport const serializePreFormatted = (\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"preformatted\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"preformatted\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand);\n\n\treturn ({ node }) => {\n\t\treturn `<pre${formatAttributes(node, generalAttributes)}>${escapeHTML(\n\t\t\tnode.text,\n\t\t)}</pre>`;\n\t};\n};\n\nexport const serializeImage = (\n\tlinkResolver:\n\t\t| LinkResolverFunction<string | null | undefined>\n\t\t| undefined\n\t\t| null,\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"image\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"image\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand);\n\n\treturn ({ node }) => {\n\t\tconst attributes = {\n\t\t\t...generalAttributes,\n\t\t\tsrc: node.url,\n\t\t\talt: node.alt,\n\t\t\tcopyright: node.copyright,\n\t\t};\n\n\t\tlet imageTag = `<img${formatAttributes(node, attributes)} />`;\n\n\t\t// If the image has a link, we wrap it with an anchor tag\n\t\tif (node.linkTo) {\n\t\t\timageTag = serializeHyperlink(linkResolver)({\n\t\t\t\ttype: \"hyperlink\",\n\t\t\t\tnode: {\n\t\t\t\t\ttype: \"hyperlink\",\n\t\t\t\t\tdata: node.linkTo,\n\t\t\t\t\tstart: 0,\n\t\t\t\t\tend: 0,\n\t\t\t\t},\n\t\t\t\ttext: \"\",\n\t\t\t\tchildren: imageTag,\n\t\t\t\tkey: \"\",\n\t\t\t})!;\n\t\t}\n\n\t\treturn `<p class=\"block-img\">${imageTag}</p>`;\n\t};\n};\n\nexport const serializeEmbed = (\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"embed\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"embed\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand);\n\n\treturn ({ node }) => {\n\t\tconst attributes = {\n\t\t\t...generalAttributes,\n\t\t\t[\"data-oembed\"]: node.oembed.embed_url,\n\t\t\t[\"data-oembed-type\"]: node.oembed.type,\n\t\t\t[\"data-oembed-provider\"]: node.oembed.provider_name,\n\t\t};\n\n\t\treturn `<div${formatAttributes(node, attributes)}>${\n\t\t\tnode.oembed.html\n\t\t}</div>`;\n\t};\n};\n\nexport const serializeHyperlink = (\n\tlinkResolver:\n\t\t| LinkResolverFunction<string | null | undefined>\n\t\t| undefined\n\t\t| null,\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"hyperlink\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"hyperlink\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand);\n\n\treturn ({ node, children }): string => {\n\t\tconst attributes = {\n\t\t\t...generalAttributes,\n\t\t};\n\n\t\tif (node.data.link_type === LinkType.Web) {\n\t\t\tattributes.href = node.data.url;\n\t\t\tattributes.target = node.data.target;\n\t\t\tattributes.rel = \"noopener noreferrer\";\n\t\t} else if (node.data.link_type === LinkType.Document) {\n\t\t\tattributes.href = asLink(node.data, { linkResolver });\n\t\t} else if (node.data.link_type === LinkType.Media) {\n\t\t\tattributes.href = node.data.url;\n\t\t}\n\n\t\treturn `<a${formatAttributes(node, attributes)}>${children}</a>`;\n\t};\n};\n\nexport const serializeSpan = (): NonNullable<\n\tHTMLStrictRichTextMapSerializer[\"span\"]\n> => {\n\treturn ({ text }): string => {\n\t\treturn text ? escapeHTML(text).replace(/\\n/g, \"<br />\") : \"\";\n\t};\n};\n", "import {\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n\tRichTextNodeType,\n} from \"../types/value/richText\";\nimport { Tree, TreeNode } from \"./types\";\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString();\n};\nuuid.i = 0;\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n *\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes);\n\n\tconst children: TreeNode[] = [];\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]));\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t};\n};\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t};\n};\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t});\n};\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0);\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i];\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t];\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode);\n\t\t\t\tmutNodes.splice(i, 1);\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes;\n};\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t);\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = [];\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]));\n\t\t}\n\n\t\treturn createTreeNode(node, children);\n\t}\n\n\treturn createTreeNode(node);\n};\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)];\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0);\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n\n\tconst children: TreeNode[] = [];\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i];\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0;\n\t\tconst spanStart = span.start - parentSpanStart;\n\t\tconst spanEnd = span.end - parentSpanStart;\n\t\tconst text = node.text.slice(spanStart, spanEnd);\n\n\t\tconst childSpans: RTInlineNode[] = [];\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j];\n\n\t\t\tif (siblingSpan !== span) {\n\t\t\t\tif (siblingSpan.start >= span.start && siblingSpan.end <= span.end) {\n\t\t\t\t\tchildSpans.push(siblingSpan);\n\t\t\t\t\tmutSpans.splice(j, 1);\n\t\t\t\t\tj--;\n\t\t\t\t} else if (\n\t\t\t\t\tsiblingSpan.start < span.end &&\n\t\t\t\t\tsiblingSpan.end > span.start\n\t\t\t\t) {\n\t\t\t\t\tchildSpans.push({\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tend: span.end,\n\t\t\t\t\t});\n\t\t\t\t\tmutSpans[j] = {\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tstart: span.end,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)));\n\t\t}\n\n\t\tconst spanWithText = { ...span, text };\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspanWithText,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn children;\n};\n", "import type { RichTextField } from \"../types/value/richText\";\nimport { RichTextFunctionSerializer, TreeNode } from \"./types\";\n\nimport { asTree } from \"./asTree\";\n\n/**\n * Serializes a rich text or title field with a given serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n *\n * @typeParam SerializerReturnType - Return type of the serializer\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param serializer - A function serializer to apply\n *\n * @returns An array of serialized nodes\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const serialize = <SerializerReturnType>(\n\trichTextField: RichTextField,\n\tserializer: RichTextFunctionSerializer<SerializerReturnType>,\n): SerializerReturnType[] => {\n\treturn serializeTreeNodes<SerializerReturnType>(\n\t\tasTree(richTextField).children,\n\t\tserializer,\n\t);\n};\n\nconst serializeTreeNodes = <T>(\n\tnodes: TreeNode[],\n\tserializer: RichTextFunctionSerializer<T>,\n): T[] => {\n\tconst serializedTreeNodes: T[] = [];\n\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst treeNode = nodes[i];\n\t\tconst serializedTreeNode = serializer(\n\t\t\ttreeNode.type,\n\t\t\ttreeNode.node,\n\t\t\ttreeNode.text,\n\t\t\tserializeTreeNodes(treeNode.children, serializer),\n\t\t\ttreeNode.key,\n\t\t);\n\n\t\tif (serializedTreeNode != null) {\n\t\t\tserializedTreeNodes.push(serializedTreeNode);\n\t\t}\n\t}\n\n\treturn serializedTreeNodes;\n};\n", "import {\n\tRTAnyNode,\n\tRTEmNode,\n\tRTEmbedNode,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTImageNode,\n\tRTLabelNode,\n\tRTLinkNode,\n\tRTListItemNode,\n\tRTListNode,\n\tRTOListItemNode,\n\tRTOListNode,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTSpanNode,\n\tRTStrongNode,\n\tRichTextNodeType,\n} from \"../types/value/richText\";\n\n// Serializers\n\n/**\n * Serializes a node from a rich text or title field with a function\n *\n * @typeParam ReturnType - Return type of the function serializer\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextFunctionSerializer<ReturnType> = (\n\ttype: (typeof RichTextNodeType)[keyof typeof RichTextNodeType],\n\tnode: RTAnyNode,\n\ttext: string | undefined,\n\tchildren: ReturnType[],\n\tkey: string,\n) => ReturnType | null | undefined;\n\n/**\n * Map serializer's tag function serializer, can be helpful for typing those\n * handlers\n *\n * @typeParam ReturnType - Return type of the tag serializer\n */\nexport type RichTextMapSerializerFunction<\n\tReturnType,\n\tNode extends RTAnyNode = RTAnyNode,\n\tTextType = string | undefined,\n> = (payload: {\n\ttype: Node[\"type\"];\n\tnode: Node;\n\ttext: TextType;\n\tchildren: ReturnType[];\n\tkey: string;\n}) => ReturnType | null | undefined;\n\n/**\n * Serializes a node from a rich text or title field with a map\n *\n * @remarks\n * This type of serializer needs to be processed through\n * {@link wrapMapSerializer} before being used with {@link serialize}\n *\n * @typeParam ReturnType - Return type of the map serializer\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextMapSerializer<ReturnType> = {\n\theading1?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading1Node,\n\t\tundefined\n\t>;\n\theading2?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading2Node,\n\t\tundefined\n\t>;\n\theading3?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading3Node,\n\t\tundefined\n\t>;\n\theading4?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading4Node,\n\t\tundefined\n\t>;\n\theading5?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading5Node,\n\t\tundefined\n\t>;\n\theading6?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading6Node,\n\t\tundefined\n\t>;\n\tparagraph?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTParagraphNode,\n\t\tundefined\n\t>;\n\tpreformatted?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTPreformattedNode,\n\t\tundefined\n\t>;\n\tstrong?: RichTextMapSerializerFunction<ReturnType, RTStrongNode, string>;\n\tem?: RichTextMapSerializerFunction<ReturnType, RTEmNode, string>;\n\tlistItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTListItemNode,\n\t\tundefined\n\t>;\n\toListItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTOListItemNode,\n\t\tundefined\n\t>;\n\tlist?: RichTextMapSerializerFunction<ReturnType, RTListNode, undefined>;\n\toList?: RichTextMapSerializerFunction<ReturnType, RTOListNode, undefined>;\n\timage?: RichTextMapSerializerFunction<ReturnType, RTImageNode, undefined>;\n\tembed?: RichTextMapSerializerFunction<ReturnType, RTEmbedNode, undefined>;\n\thyperlink?: RichTextMapSerializerFunction<ReturnType, RTLinkNode, string>;\n\tlabel?: RichTextMapSerializerFunction<ReturnType, RTLabelNode, string>;\n\tspan?: RichTextMapSerializerFunction<ReturnType, RTSpanNode, string>;\n};\n\n// Tree\nexport interface Tree {\n\tkey: string;\n\tchildren: TreeNode[];\n}\n\nexport interface TreeNode {\n\tkey: string;\n\ttype: (typeof RichTextNodeType)[keyof typeof RichTextNodeType];\n\ttext?: string;\n\tnode: RTAnyNode;\n\tchildren: TreeNode[];\n}\n\n// Helpers\nexport const RichTextReversedNodeType = {\n\t[RichTextNodeType.listItem]: \"listItem\",\n\t[RichTextNodeType.oListItem]: \"oListItem\",\n\t[RichTextNodeType.list]: \"list\",\n\t[RichTextNodeType.oList]: \"oList\",\n} as const;\n", "import {\n\tRichTextFunctionSerializer,\n\tRichTextMapSerializer,\n\tRichTextReversedNodeType,\n} from \"./types\";\n\n/**\n * Wraps a map serializer into a regular function serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n *\n * @typeParam SerializerReturnType - Return type of the map serializer\n *\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nexport const wrapMapSerializer = <SerializerReturnType>(\n\tmapSerializer: RichTextMapSerializer<SerializerReturnType>,\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (type, node, text, children, key) => {\n\t\tconst tagSerializer: RichTextMapSerializer<SerializerReturnType>[keyof RichTextMapSerializer<SerializerReturnType>] =\n\t\t\tmapSerializer[\n\t\t\t\t(RichTextReversedNodeType[\n\t\t\t\t\ttype as keyof typeof RichTextReversedNodeType\n\t\t\t\t] || type) as keyof RichTextMapSerializer<SerializerReturnType>\n\t\t\t];\n\n\t\tif (tagSerializer) {\n\t\t\treturn tagSerializer({\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttype,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tnode,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttext,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tchildren,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tkey,\n\t\t\t});\n\t\t}\n\t};\n};\n", "import { RichTextFunctionSerializer } from \"./types\";\n\n/**\n * Takes an array of serializers and returns a serializer applying provided\n * serializers sequentially until a result is returned\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n *\n * @typeParam SerializerReturnType - Return type of serializers\n *\n * @param serializers - Serializers to compose\n *\n * @returns Composed serializer\n */\nexport const composeSerializers = <SerializerReturnType>(\n\t...serializers: (\n\t\t| RichTextFunctionSerializer<SerializerReturnType>\n\t\t| undefined\n\t)[]\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (...args) => {\n\t\tfor (let i = 0; i < serializers.length; i++) {\n\t\t\tconst serializer = serializers[i];\n\n\t\t\tif (serializer) {\n\t\t\t\tconst res = serializer(...args);\n\n\t\t\t\tif (res != null) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n", "import {\n\tserializeEmbed,\n\tserializeHyperlink,\n\tserializeImage,\n\tserializePreFormatted,\n\tserializeSpan,\n\tserializeStandardTag,\n} from \"../lib/serializerHelpers\";\n\nimport type { RichTextField } from \"../types/value/richText\";\n\nimport {\n\tRichTextFunctionSerializer,\n\tRichTextMapSerializer,\n\tRichTextMapSerializerFunction,\n\tcomposeSerializers,\n\tserialize,\n\twrapMapSerializer,\n} from \"../richtext\";\n\nimport { LinkResolverFunction } from \"./asLink\";\n\n/**\n * Serializes a node from a rich text or title field with a function to HTML.\n *\n * Unlike a typical `@prismicio/client/richtext` function serializer, this\n * serializer converts the `children` argument to a single string rather than an\n * array of strings.\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n */\nexport type HTMLRichTextFunctionSerializer = (\n\ttype: Parameters<RichTextFunctionSerializer<string>>[0],\n\tnode: Parameters<RichTextFunctionSerializer<string>>[1],\n\ttext: Parameters<RichTextFunctionSerializer<string>>[2],\n\tchildren: Parameters<RichTextFunctionSerializer<string>>[3][number],\n\tkey: Parameters<RichTextFunctionSerializer<string>>[4],\n) => string | null | undefined;\n\n/**\n * Serializes a node from a rich text or title field with a map to HTML\n *\n * Unlike a typical `@prismicio/client/richtext` map serializer, this serializer\n * converts the `children` property to a single string rather than an array of\n * strings and accepts shorthand declarations.\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n */\nexport type HTMLRichTextMapSerializer = {\n\t[P in keyof RichTextMapSerializer<string>]: P extends RichTextMapSerializer<string>[\"span\"]\n\t\t? HTMLStrictRichTextMapSerializer[P]\n\t\t: HTMLStrictRichTextMapSerializer[P] | HTMLRichTextMapSerializerShorthand;\n};\n\n/**\n * Serializes a node from a rich text or title field with a map to HTML\n *\n * Unlike a typical `@prismicio/client/richtext` map serializer, this serializer\n * converts the `children` property to a single string rather than an array of\n * strings but doesn't accept shorthand declarations.\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n */\nexport type HTMLStrictRichTextMapSerializer = {\n\t[P in keyof RichTextMapSerializer<string>]: (payload: {\n\t\ttype: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"type\"];\n\t\tnode: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"node\"];\n\t\ttext: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"text\"];\n\t\tchildren: Parameters<\n\t\t\tHTMLRichTextMapSerializerFunction<P>\n\t\t>[0][\"children\"][number];\n\t\tkey: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"key\"];\n\t}) => string | null | undefined;\n};\n\n/**\n * A {@link RichTextMapSerializerFunction} type specifically for\n * {@link HTMLRichTextMapSerializer}.\n *\n * @typeParam BlockName - The serializer's rich text block type.\n */\ntype HTMLRichTextMapSerializerFunction<\n\tBlockType extends keyof RichTextMapSerializer<string>,\n> = RichTextMapSerializerFunction<\n\tstring,\n\tExtractNodeGeneric<RichTextMapSerializer<string>[BlockType]>,\n\tExtractTextTypeGeneric<RichTextMapSerializer<string>[BlockType]>\n>;\n\n/**\n * Returns the `Node` generic from {@link RichTextMapSerializerFunction}.\n *\n * @typeParam T - The `RichTextMapSerializerFunction` containing the needed\n *   `Node` generic.\n */\ntype ExtractNodeGeneric<T> = T extends RichTextMapSerializerFunction<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tany,\n\tinfer U,\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tany\n>\n\t? U\n\t: never;\n\n/**\n * Returns the `TextType` generic from {@link RichTextMapSerializerFunction}.\n *\n * @typeParam T - The `RichTextMapSerializerFunction` containing the needed\n *   `TextType` generic.\n */\ntype ExtractTextTypeGeneric<T> = T extends RichTextMapSerializerFunction<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tany,\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tany,\n\tinfer U\n>\n\t? U\n\t: never;\n\n/**\n * A shorthand definition for {@link HTMLRichTextMapSerializer} element types.\n */\nexport type HTMLRichTextMapSerializerShorthand = {\n\t/**\n\t * Classes to apply to the element type.\n\t */\n\tclass?: string;\n\n\t/**\n\t * Other attributes to apply to the element type.\n\t */\n\t[Attribute: string]: string | boolean | null | undefined;\n};\n\n/**\n * Serializes a node from a rich text or title field with a map or a function to\n * HTML\n *\n * @see {@link HTMLRichTextMapSerializer} and {@link HTMLRichTextFunctionSerializer}\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n */\nexport type HTMLRichTextSerializer =\n\t| HTMLRichTextMapSerializer\n\t| HTMLRichTextFunctionSerializer;\n\n/**\n * Creates a HTML rich text serializer with a given link resolver and provide\n * sensible and safe defaults for every node type\n *\n * @internal\n */\nconst createHTMLRichTextSerializer = (\n\tlinkResolver: LinkResolverFunction | undefined | null,\n\tserializer?: HTMLRichTextMapSerializer | null,\n): RichTextFunctionSerializer<string> => {\n\tconst useSerializerOrDefault = <\n\t\tBlockType extends keyof RichTextMapSerializer<string>,\n\t>(\n\t\tnodeSerializerOrShorthand: HTMLRichTextMapSerializer[BlockType],\n\t\tdefaultWithShorthand: NonNullable<\n\t\t\tHTMLStrictRichTextMapSerializer[BlockType]\n\t\t>,\n\t): NonNullable<HTMLStrictRichTextMapSerializer[BlockType]> => {\n\t\tif (typeof nodeSerializerOrShorthand === \"function\") {\n\t\t\treturn ((payload) => {\n\t\t\t\treturn (\n\t\t\t\t\t(\n\t\t\t\t\t\tnodeSerializerOrShorthand as HTMLStrictRichTextMapSerializer[BlockType]\n\t\t\t\t\t)(payload) || defaultWithShorthand(payload)\n\t\t\t\t);\n\t\t\t}) as NonNullable<HTMLStrictRichTextMapSerializer[BlockType]>;\n\t\t}\n\n\t\treturn defaultWithShorthand;\n\t};\n\n\tconst mapSerializer: Required<HTMLStrictRichTextMapSerializer> = {\n\t\theading1: useSerializerOrDefault<\"heading1\">(\n\t\t\tserializer?.heading1,\n\t\t\tserializeStandardTag<\"heading1\">(\"h1\", serializer?.heading1),\n\t\t),\n\t\theading2: useSerializerOrDefault<\"heading2\">(\n\t\t\tserializer?.heading2,\n\t\t\tserializeStandardTag<\"heading2\">(\"h2\", serializer?.heading2),\n\t\t),\n\t\theading3: useSerializerOrDefault<\"heading3\">(\n\t\t\tserializer?.heading3,\n\t\t\tserializeStandardTag<\"heading3\">(\"h3\", serializer?.heading3),\n\t\t),\n\t\theading4: useSerializerOrDefault<\"heading4\">(\n\t\t\tserializer?.heading4,\n\t\t\tserializeStandardTag<\"heading4\">(\"h4\", serializer?.heading4),\n\t\t),\n\t\theading5: useSerializerOrDefault<\"heading5\">(\n\t\t\tserializer?.heading5,\n\t\t\tserializeStandardTag<\"heading5\">(\"h5\", serializer?.heading5),\n\t\t),\n\t\theading6: useSerializerOrDefault<\"heading6\">(\n\t\t\tserializer?.heading6,\n\t\t\tserializeStandardTag<\"heading6\">(\"h6\", serializer?.heading6),\n\t\t),\n\t\tparagraph: useSerializerOrDefault<\"paragraph\">(\n\t\t\tserializer?.paragraph,\n\t\t\tserializeStandardTag<\"paragraph\">(\"p\", serializer?.paragraph),\n\t\t),\n\t\tpreformatted: useSerializerOrDefault<\"preformatted\">(\n\t\t\tserializer?.preformatted,\n\t\t\tserializePreFormatted(serializer?.preformatted),\n\t\t),\n\t\tstrong: useSerializerOrDefault<\"strong\">(\n\t\t\tserializer?.strong,\n\t\t\tserializeStandardTag<\"strong\">(\"strong\", serializer?.strong),\n\t\t),\n\t\tem: useSerializerOrDefault<\"em\">(\n\t\t\tserializer?.em,\n\t\t\tserializeStandardTag<\"em\">(\"em\", serializer?.em),\n\t\t),\n\t\tlistItem: useSerializerOrDefault<\"listItem\">(\n\t\t\tserializer?.listItem,\n\t\t\tserializeStandardTag<\"listItem\">(\"li\", serializer?.listItem),\n\t\t),\n\t\toListItem: useSerializerOrDefault<\"oListItem\">(\n\t\t\tserializer?.oListItem,\n\t\t\tserializeStandardTag<\"oListItem\">(\"li\", serializer?.oListItem),\n\t\t),\n\t\tlist: useSerializerOrDefault<\"list\">(\n\t\t\tserializer?.list,\n\t\t\tserializeStandardTag<\"list\">(\"ul\", serializer?.list),\n\t\t),\n\t\toList: useSerializerOrDefault<\"oList\">(\n\t\t\tserializer?.oList,\n\t\t\tserializeStandardTag<\"oList\">(\"ol\", serializer?.oList),\n\t\t),\n\t\timage: useSerializerOrDefault<\"image\">(\n\t\t\tserializer?.image,\n\t\t\tserializeImage(linkResolver, serializer?.image),\n\t\t),\n\t\tembed: useSerializerOrDefault<\"embed\">(\n\t\t\tserializer?.embed,\n\t\t\tserializeEmbed(serializer?.embed),\n\t\t),\n\t\thyperlink: useSerializerOrDefault<\"hyperlink\">(\n\t\t\tserializer?.hyperlink,\n\t\t\tserializeHyperlink(linkResolver, serializer?.hyperlink),\n\t\t),\n\t\tlabel: useSerializerOrDefault<\"label\">(\n\t\t\tserializer?.label,\n\t\t\tserializeStandardTag<\"label\">(\"span\", serializer?.label),\n\t\t),\n\t\tspan: useSerializerOrDefault<\"span\">(serializer?.span, serializeSpan()),\n\t};\n\n\treturn wrapMapSerializerWithStringChildren(mapSerializer);\n};\n\n/**\n * Wraps a map serializer into a regular function serializer. The given map\n * serializer should accept children as a string, not as an array of strings\n * like `@prismicio/client/richtext`'s `wrapMapSerializer`.\n *\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nconst wrapMapSerializerWithStringChildren = (\n\tmapSerializer: HTMLStrictRichTextMapSerializer,\n): RichTextFunctionSerializer<string> => {\n\tconst modifiedMapSerializer = {} as RichTextMapSerializer<string>;\n\n\tfor (const tag in mapSerializer) {\n\t\tconst tagSerializer = mapSerializer[tag as keyof typeof mapSerializer];\n\n\t\tif (tagSerializer) {\n\t\t\tmodifiedMapSerializer[tag as keyof typeof mapSerializer] = (payload) => {\n\t\t\t\treturn tagSerializer({\n\t\t\t\t\t...payload,\n\t\t\t\t\t// @ts-expect-error - merging blockSerializer types causes TS to bail to a never type\n\t\t\t\t\tchildren: payload.children.join(\"\"),\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t}\n\n\treturn wrapMapSerializer(modifiedMapSerializer);\n};\n\n/**\n * Configuration that determines the output of `asHTML()`.\n */\ntype AsHTMLConfig = {\n\t/**\n\t * An optional link resolver function to resolve links. Without it you're\n\t * expected to use the `routes` options from the API.\n\t */\n\tlinkResolver?: LinkResolverFunction | null;\n\n\t/**\n\t * An optional rich text serializer, unhandled cases will fallback to the\n\t * default serializer\n\t */\n\tserializer?: HTMLRichTextSerializer | null;\n};\n\n// TODO: Remove when we remove support for deprecated tuple-style configuration.\n/**\n * @deprecated Use object-style configuration instead.\n */\ntype AsHTMLDeprecatedTupleConfig = [\n\tlinkResolver?: LinkResolverFunction | null,\n\tserializer?: HTMLRichTextSerializer | null,\n];\n\n/**\n * The return type of `asHTML()`.\n */\ntype AsHTMLReturnType<Field extends RichTextField | null | undefined> =\n\tField extends RichTextField ? string : null;\n\n// TODO: Remove overload when we remove support for deprecated tuple-style configuration.\nexport const asHTML: {\n\t/**\n\t * Serializes a rich text or title field to an HTML string.\n\t *\n\t * @param richTextField - A rich text or title field from Prismic\n\t * @param config - Configuration that determines the output of `asHTML()`\n\t *\n\t * @returns HTML equivalent of the provided rich text or title field\n\t *\n\t * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\tconfig?: AsHTMLConfig,\n\t): AsHTMLReturnType<Field>;\n\n\t/**\n\t * Serializes a rich text or title field to an HTML string.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @param richTextField - A rich text or title field from Prismic\n\t * @param linkResolver - An optional link resolver function to resolve links,\n\t *   without it you're expected to use the `routes` options from the API\n\t * @param serializer - An optional rich text serializer, unhandled cases will\n\t *   fallback to the default serializer\n\t *\n\t * @returns HTML equivalent of the provided rich text or title field\n\t *\n\t * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\t...config: AsHTMLDeprecatedTupleConfig\n\t): AsHTMLReturnType<Field>;\n} = <Field extends RichTextField | null | undefined>(\n\trichTextField: Field,\n\t// TODO: Rename to `config` when we remove support for deprecated tuple-style configuration.\n\t...configObjectOrTuple: [config?: AsHTMLConfig] | AsHTMLDeprecatedTupleConfig\n): AsHTMLReturnType<Field> => {\n\tif (richTextField) {\n\t\t// TODO: Remove when we remove support for deprecated tuple-style configuration.\n\t\tconst [configObjectOrLinkResolver, maybeSerializer] = configObjectOrTuple;\n\t\tlet config: AsHTMLConfig;\n\t\tif (\n\t\t\ttypeof configObjectOrLinkResolver === \"function\" ||\n\t\t\tconfigObjectOrLinkResolver == null\n\t\t) {\n\t\t\tconfig = {\n\t\t\t\tlinkResolver: configObjectOrLinkResolver,\n\t\t\t\tserializer: maybeSerializer,\n\t\t\t};\n\t\t} else {\n\t\t\tconfig = { ...configObjectOrLinkResolver };\n\t\t}\n\n\t\tlet serializer: RichTextFunctionSerializer<string>;\n\t\tif (config.serializer) {\n\t\t\tif (typeof config.serializer === \"function\") {\n\t\t\t\tserializer = composeSerializers(\n\t\t\t\t\t(type, node, text, children, key) =>\n\t\t\t\t\t\t// TypeScript doesn't narrow the type correctly here since it is now in a callback function, so we have to cast it here.\n\t\t\t\t\t\t(config.serializer as HTMLRichTextFunctionSerializer)(\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t\tchildren.join(\"\"),\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t),\n\t\t\t\t\tcreateHTMLRichTextSerializer(config.linkResolver),\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tserializer = createHTMLRichTextSerializer(\n\t\t\t\t\tconfig.linkResolver,\n\t\t\t\t\tconfig.serializer,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tserializer = createHTMLRichTextSerializer(config.linkResolver);\n\t\t}\n\n\t\treturn serialize(richTextField, serializer).join(\n\t\t\t\"\",\n\t\t) as AsHTMLReturnType<Field>;\n\t} else {\n\t\treturn null as AsHTMLReturnType<Field>;\n\t}\n};\n", "import type { ImgixURLParams } from \"./types.generated\";\n\n/**\n * Converts a camel case string to a param case string.\n *\n * @example\n *\n * ```ts\n * camelCaseToParamCase(\"fooBar\");\n * // => 'foo-bar'\n * ```\n *\n * @param input - Camel case string to convert.\n *\n * @returns Param case version of `input`.\n */\nconst camelCaseToParamCase = (input: string): string => {\n\treturn input.replace(/[A-Z]/g, (match) => {\n\t\treturn `-${match.toLowerCase()}`;\n\t});\n};\n\n/**\n * Builds a URL to an Imgix image with Imgix URL API parameters.\n *\n * The given URL must be a full absolute URL containing the protocol and domain.\n *\n * URL parameters already applied to the image will be retained. To remove\n * existing parameters, set the parameter to `undefined` in the `params`\n * argument.\n *\n * @example\n *\n * ```ts\n * const url = buildURL(\"https://example.imgix.net/image.png\", {\n * \twidth: 400,\n * });\n * // => https://example.imgix.net/image.png?width=400\n * ```\n *\n * @example\n *\n * ```ts\n * const url = buildURL(\"https://example.imgix.net/image.png?width=400\", {\n * \theight: 300,\n * });\n * // => https://example.imgix.net/image.png?width=400&height=300\n * ```\n *\n * @param url - Full absolute URL to the Imgix image.\n * @param params - An object of Imgix URL API parameters.\n *\n * @returns `url` with the given Imgix URL API parameters applied.\n *\n * @see Imgix URL API reference: https://docs.imgix.com/apis/rendering\n */\nexport const buildURL = (url: string, params: ImgixURLParams): string => {\n\tconst instance = new URL(url);\n\n\tfor (const camelCasedParamKey in params) {\n\t\tconst paramKey = camelCaseToParamCase(camelCasedParamKey);\n\t\tconst paramValue = params[camelCasedParamKey as keyof typeof params];\n\n\t\tif (paramValue === undefined) {\n\t\t\tinstance.searchParams.delete(paramKey);\n\t\t} else if (Array.isArray(paramValue)) {\n\t\t\tinstance.searchParams.set(paramKey, paramValue.join(\",\"));\n\t\t} else {\n\t\t\tinstance.searchParams.set(paramKey, `${paramValue}`);\n\t\t}\n\t}\n\n\t// Ensure the `s` parameter is the last parameter, if it exists.\n\t// @see https://github.com/imgix/imgix-blueprint#securing-urls\n\tconst s = instance.searchParams.get(\"s\");\n\tif (s) {\n\t\tinstance.searchParams.delete(\"s\");\n\t\tinstance.searchParams.append(\"s\", s);\n\t}\n\n\treturn instance.toString();\n};\n", "import type { ImgixURLParams } from \"./types.generated\";\nimport { buildURL } from \"./buildURL\";\n\n/**\n * Parameters for `buildPixelDensitySrcSet`.\n */\nexport type BuildPixelDensitySrcSetParams = Omit<ImgixURLParams, \"dpr\"> & {\n\t/**\n\t * The pixel densities to include in the resulting `srcset` value.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * [1, 2, 3];\n\t * ```\n\t */\n\tpixelDensities: number[];\n};\n\n/**\n * Builds an `<img>` `srcset` attribute value for a given set of pixel\n * densities. It can also optinally apply Imgix URL API parameters to the URLs.\n *\n * The `dpr` URL parameter will be applied for each `srcset` entry. If a `dpr`\n * parameter is provided to the `params` parameter, it will be ignored.\n *\n * @example\n *\n * ```ts\n * const srcset = buildPixelDensitySrcSet(\n * \t\"https://example.imgix.net/image.png\",\n * \t{ pixelDensities: [1, 2, 3] },\n * );\n * // => https://example.imgix.net/image.png?dpr=1 1x,\n * //    https://example.imgix.net/image.png?dpr=2 2x,\n * //    https://example.imgix.net/image.png?dpr=3 3x\n * ```\n *\n * @example\n *\n * ```ts\n * const srcset = buildPixelDensitySrcSet(\n * \t\"https://example.imgix.net/image.png\",\n * \t{\n * \t\tpixelDensities: [1, 2, 3],\n * \t\tsat: -100,\n * \t},\n * );\n * // => https://example.imgix.net/image.png?dpr=1&sat=-100 1x,\n * //    https://example.imgix.net/image.png?dpr=2&sat=-100 2x,\n * //    https://example.imgix.net/image.png?dpr=3&sat=-100 3x\n * ```\n *\n * @param url - Full absolute URL to the Imgix image.\n * @param params - An object of Imgix URL API parameters. The `pixelDensities`\n *   parameter defines the resulting `srcset` widths.\n *\n * @returns A `srcset` attribute value for `url` with the given Imgix URL API\n *   parameters applied.\n */\nexport const buildPixelDensitySrcSet = (\n\turl: string,\n\t{ pixelDensities, ...params }: BuildPixelDensitySrcSetParams,\n): string => {\n\treturn pixelDensities\n\t\t.map((dpr) => {\n\t\t\treturn `${buildURL(url, { ...params, dpr })} ${dpr}x`;\n\t\t})\n\t\t.join(\", \");\n};\n", "import type { ImgixURLParams } from \"./types.generated\";\nimport { buildURL } from \"./buildURL\";\n\n/**\n * Parameters for `buildWidthSrcSet`.\n */\nexport type BuildWidthSrcSetParams = Omit<ImgixURLParams, \"width\" | \"w\"> & {\n\t/**\n\t * The pixel widths to include in the resulting `srcset` value.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * [400, 800, 1600];\n\t * ```\n\t */\n\twidths: number[];\n};\n\n/**\n * Builds an `<img>` `srcset` attribute value for a given set of widths. It can\n * also optinally apply Imgix URL API parameters to the URLs.\n *\n * The `width` URL parameter will be applied for each `srcset` entry. If a\n * `width` or `w` parameter is provided to the `params` parameter, it will be\n * ignored.\n *\n * @example\n *\n * ```ts\n * const srcset = buildWidthSrcSet(\"https://example.imgix.net/image.png\", {\n * \twidths: [400, 800, 1600],\n * });\n * // => https://example.imgix.net/image.png?width=400 400w,\n * //    https://example.imgix.net/image.png?width=800 800w,\n * //    https://example.imgix.net/image.png?width=1600 1600w\n * ```\n *\n * @example\n *\n * ```ts\n * const srcset = buildWidthSrcSet(\"https://example.imgix.net/image.png\", {\n * \twidths: [400, 800, 1600],\n * \tsat: -100,\n * });\n * // => https://example.imgix.net/image.png?width=400&sat=-100 400w,\n * //    https://example.imgix.net/image.png?width=800&sat=-100 800w,\n * //    https://example.imgix.net/image.png?width=1600&sat=-100 1600w\n * ```\n *\n * @param url - Full absolute URL to the Imgix image.\n * @param params - An object of Imgix URL API parameters. The `widths` parameter\n *   defines the resulting `srcset` widths.\n *\n * @returns A `srcset` attribute value for `url` with the given Imgix URL API\n *   parameters applied.\n */\nexport const buildWidthSrcSet = (\n\turl: string,\n\t{ widths, ...params }: BuildWidthSrcSetParams,\n): string => {\n\treturn widths\n\t\t.map((width) => {\n\t\t\treturn `${buildURL(url, { ...params, w: undefined, width })} ${width}w`;\n\t\t})\n\t\t.join(\", \");\n};\n", "import type { BuildPixelDensitySrcSetParams } from \"./buildPixelDensitySrcSet\";\nimport type { BuildWidthSrcSetParams } from \"./buildWidthSrcSet\";\nimport type { ImgixURLParams } from \"./types.generated\";\nimport { buildPixelDensitySrcSet } from \"./buildPixelDensitySrcSet\";\nimport { buildURL } from \"./buildURL\";\nimport { buildWidthSrcSet } from \"./buildWidthSrcSet\";\n\n/**\n * Options to instantiate a new client.\n */\nexport type ClientOptions = {\n\t/**\n\t * The base URL used to construct image URLs from a path. The base URL must\n\t * include the protocol, domain, and optionally a path.\n\t *\n\t * @example `https://example.imgix.net`\n\t *\n\t * @example `https://example.imgix.net/folder`\n\t */\n\tbaseURL: string;\n};\n\n/**\n * An Imgix Rendering API client. A client is paired to a single Imgix domain.\n */\nexport class Client {\n\tbaseURL: string;\n\n\t/**\n\t * Creates a new `Client` instance for an Imgix domain.\n\t *\n\t * @param options - Options to instantiate a new client.\n\t *\n\t * @returns A `Client` instance for the given Imgix domain.\n\t */\n\tconstructor(options: ClientOptions) {\n\t\tthis.baseURL = options.baseURL;\n\t}\n\n\t/**\n\t * Builds a URL to an Imgix image with Imgix URL API parameters for the\n\t * client's base URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({ baseURL: \"https://example.imgix.net\" });\n\t * const url = client.buildURLForPath(\"/image.png\", { width: 400 });\n\t * // => https://example.imgix.net/image.png?width=400\n\t * ```\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({\n\t * \tbaseURL: \"https://example.imgix.net/folder\",\n\t * });\n\t * const url = client.buildURLForPath(\"./image.png\", { width: 400 });\n\t * // => https://example.imgix.net/folder/image.png?width=400\n\t * ```\n\t *\n\t * @param path - Path to the image relative to the client's base URL.\n\t * @param params - An object of Imgix URL API parameters.\n\t *\n\t * @returns The full absolute URL to the image with the given Imgix URL API\n\t *   parameters applied.\n\t */\n\tbuildURLForPath(path: string, params: ImgixURLParams = {}) {\n\t\treturn buildURL(`${new URL(path, this.baseURL)}`, params);\n\t}\n\n\t/**\n\t * Builds an `<img>` `srcset` attribute value for a given set of widths for\n\t * the client's base URL. It can also optinally apply Imgix URL API parameters\n\t * to the URLs.\n\t *\n\t * The `width` URL parameter will be applied for each `srcset` entry. If a\n\t * `width` or `w` parameter is provided to the `params` parameter, it will be\n\t * ignored.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({ baseURL: \"https://example.imgix.net\" });\n\t * const srcset = client.buildWidthSrcSetForPath(\"/image.png\", {\n\t * \twidths: [400, 800, 1600],\n\t * });\n\t * // => https://example.imgix.net/image.png?width=400 400w,\n\t * //    https://example.imgix.net/image.png?width=800 800w,\n\t * //    https://example.imgix.net/image.png?width=1600 1600w\n\t * ```\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({\n\t * \tbaseURL: \"https://example.imgix.net\",\n\t * });\n\t * const srcset = client.buildWidthSrcSetForPath(\"/image.png\", {\n\t * \twidths: [400, 800, 1600],\n\t * \tsat: -100,\n\t * });\n\t * // => https://example.imgix.net/image.png?width=400&sat=-100 400w,\n\t * //    https://example.imgix.net/image.png?width=800&sat=-100 800w,\n\t * //    https://example.imgix.net/image.png?width=1600&sat=-100 1600w\n\t * ```\n\t *\n\t * @param path - Path to the image relative to the client's base URL.\n\t * @param params - An object of Imgix URL API parameters. The `widths`\n\t *   parameter defines the resulting `srcset` widths.\n\t *\n\t * @returns A `srcset` attribute value for `url` with the given Imgix URL API\n\t *   parameters applied.\n\t */\n\tbuildWidthSrcSetForPath(path: string, params: BuildWidthSrcSetParams) {\n\t\treturn buildWidthSrcSet(`${new URL(path, this.baseURL)}`, params);\n\t}\n\n\t/**\n\t * Builds an `<img>` `srcset` attribute value for a given set of pixel\n\t * densities for the client's base URL. It can also optinally apply Imgix URL\n\t * API parameters to the URLs.\n\t *\n\t * The `dpr` URL parameter will be applied for each `srcset` entry. If a `dpr`\n\t * parameter is provided to the `params` parameter, it will be ignored.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({ baseURL: \"https://example.imgix.net\" });\n\t * const srcset = client.buildPixelDensitySrcSetForPath(\"/image.png\", {\n\t * \tpixelDensities: [1, 2, 3],\n\t * });\n\t * // => https://example.imgix.net/image.png?dpr=1 1x,\n\t * //    https://example.imgix.net/image.png?dpr=2 2x,\n\t * //    https://example.imgix.net/image.png?dpr=3 3x\n\t * ```\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({ baseURL: \"https://example.imgix.net\" });\n\t * const srcset = client.buildPixelDensitySrcSetForPath(\"/image.png\", {\n\t * \tpixelDensities: [1, 2, 3],\n\t * \tsat: -100,\n\t * });\n\t * // => https://example.imgix.net/image.png?dpr=1&sat=-100 1x,\n\t * //    https://example.imgix.net/image.png?dpr=2&sat=-100 2x,\n\t * //    https://example.imgix.net/image.png?dpr=3&sat=-100 3x\n\t * ```\n\t *\n\t * @param path - Path to the image relative to the client's base URL.\n\t * @param params - An object of Imgix URL API parameters. The `pixelDensities`\n\t *   parameter defines the resulting `srcset` widths.\n\t *\n\t * @returns A `srcset` attribute value for `url` with the given Imgix URL API\n\t *   parameters applied.\n\t */\n\tbuildPixelDensitySrcSetForPath(\n\t\tpath: string,\n\t\tparams: BuildPixelDensitySrcSetParams,\n\t) {\n\t\treturn buildPixelDensitySrcSet(`${new URL(path, this.baseURL)}`, params);\n\t}\n}\n", "import { ImgixURLParams, buildURL } from \"imgix-url-builder\";\n\nimport type { ImageFieldImage } from \"../types/value/image\";\n\nimport { imageThumbnail as isImageThumbnailFilled } from \"./isFilled\";\n\n/**\n * The return type of `asImageSrc()`.\n */\ntype AsImageSrcReturnType<Field extends ImageFieldImage | null | undefined> =\n\tField extends ImageFieldImage<\"filled\"> ? string : null;\n\n/**\n * Returns the URL of an image field with optional image transformations (via\n * Imgix URL parameters).\n *\n * @example\n *\n * ```ts\n * const src = asImageSrc(document.data.imageField, { sat: -100 });\n * // => https://images.prismic.io/repo/image.png?sat=-100\n * ```\n *\n * @param field - Image field (or one of its responsive views) from which to get\n *   an image URL.\n * @param config - An object of Imgix URL API parameters to transform the image.\n *\n * @returns The image field's image URL with transformations applied (if given).\n *   If the image field is empty, `null` is returned.\n *\n * @see Imgix URL parameters reference: https://docs.imgix.com/apis/rendering\n */\nexport const asImageSrc = <Field extends ImageFieldImage | null | undefined>(\n\tfield: Field,\n\tconfig: ImgixURLParams = {},\n): AsImageSrcReturnType<Field> => {\n\tif (field && isImageThumbnailFilled(field)) {\n\t\treturn buildURL(field.url, config) as AsImageSrcReturnType<Field>;\n\t} else {\n\t\treturn null as AsImageSrcReturnType<Field>;\n\t}\n};\n", "import {\n\tBuildWidthSrcSetParams,\n\tbuildURL,\n\tbuildWidthSrcSet,\n} from \"imgix-url-builder\";\n\nimport type { ImageFieldImage } from \"../types/value/image\";\n\nimport * as isFilled from \"./isFilled\";\n\n/**\n * The default widths used to generate a `srcset` value.\n */\nconst DEFAULT_WIDTHS = [640, 828, 1200, 2048, 3840];\n\n/**\n * The return type of `asImageWidthSrcSet()`.\n */\ntype AsImageWidthSrcSetReturnType<\n\tField extends ImageFieldImage | null | undefined,\n> = Field extends ImageFieldImage<\"filled\">\n\t? {\n\t\t\t/**\n\t\t\t * The image field's image URL with Imgix URL parameters (if given).\n\t\t\t */\n\t\t\tsrc: string;\n\n\t\t\t/**\n\t\t\t * A width-based `srcset` attribute value for the image field's image with\n\t\t\t * Imgix URL parameters (if given).\n\t\t\t */\n\t\t\tsrcset: string;\n\t  }\n\t: null;\n\n/**\n * Configuration for `asImageWidthSrcSet()`.\n */\ntype AsImageWidthSrcSetConfig = Omit<BuildWidthSrcSetParams, \"widths\"> & {\n\twidths?: \"thumbnails\" | BuildWidthSrcSetParams[\"widths\"];\n};\n\n/**\n * Creates a width-based `srcset` from an image field with optional image\n * transformations (via Imgix URL parameters).\n *\n * If a `widths` parameter is not given, the following widths will be used by\n * default: 640, 750, 828, 1080, 1200, 1920, 2048, 3840.\n *\n * If the image field contains responsive views, each responsive view can be\n * used as a width in the resulting `srcset` by passing `\"thumbnails\"` as the\n * `widths` parameter.\n *\n * @example\n *\n * ```ts\n * const srcset = asImageWidthSrcSet(document.data.imageField, {\n * \twidths: [400, 800, 1600],\n * \tsat: -100,\n * });\n * // => {\n * //   src:    'https://images.prismic.io/repo/image.png?sat=-100',\n * //   srcset: 'https://images.prismic.io/repo/image.png?sat=-100&width=400 400w, ' +\n * //           'https://images.prismic.io/repo/image.png?sat=-100&width=800 800w,' +\n * //           'https://images.prismic.io/repo/image.png?sat=-100&width=1600 1600w'\n * // }\n * ```\n *\n * @param field - Image field (or one of its responsive views) from which to get\n *   an image URL.\n * @param config - An object of Imgix URL API parameters. The `widths` parameter\n *   defines the resulting `srcset` widths. Pass `\"thumbnails\"` to automatically\n *   use the field's responsive views.\n *\n * @returns A `srcset` attribute value for the image field with Imgix URL\n *   parameters (if given). If the image field is empty, `null` is returned.\n *\n * @see Imgix URL parameters reference: https://docs.imgix.com/apis/rendering\n */\nexport const asImageWidthSrcSet = <\n\tField extends ImageFieldImage | null | undefined,\n>(\n\tfield: Field,\n\tconfig: AsImageWidthSrcSetConfig = {},\n): AsImageWidthSrcSetReturnType<Field> => {\n\tif (field && isFilled.imageThumbnail(field)) {\n\t\t// We are using destructuring to omit `widths` from the object\n\t\t// we will pass to `buildURL()`.\n\t\tlet {\n\t\t\twidths = DEFAULT_WIDTHS,\n\t\t\t// eslint-disable-next-line prefer-const\n\t\t\t...imgixParams\n\t\t} = config;\n\t\tconst {\n\t\t\turl,\n\t\t\tdimensions,\n\t\t\tid: _id,\n\t\t\talt: _alt,\n\t\t\tcopyright: _copyright,\n\t\t\tedit: _edit,\n\t\t\t...responsiveViews\n\t\t} = field;\n\n\t\t// The Prismic Rest API will always return thumbnail values if\n\t\t// the base size is filled.\n\t\tconst responsiveViewObjects: ImageFieldImage<\"filled\">[] =\n\t\t\tObject.values(responsiveViews);\n\n\t\t// If this `asImageWidthSrcSet()` call is configured to use\n\t\t// thumbnail widths, but the field does not have thumbnails, we\n\t\t// fall back to the default set of widths.\n\t\tif (widths === \"thumbnails\" && responsiveViewObjects.length < 1) {\n\t\t\twidths = DEFAULT_WIDTHS;\n\t\t}\n\n\t\treturn {\n\t\t\tsrc: buildURL(url, imgixParams),\n\t\t\tsrcset:\n\t\t\t\t// By this point, we know `widths` can only be\n\t\t\t\t// `\"thubmanils\"` if the field has thumbnails.\n\t\t\t\twidths === \"thumbnails\"\n\t\t\t\t\t? [\n\t\t\t\t\t\t\tbuildWidthSrcSet(url, {\n\t\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\t\twidths: [dimensions.width],\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t...responsiveViewObjects.map((thumbnail) => {\n\t\t\t\t\t\t\t\treturn buildWidthSrcSet(thumbnail.url, {\n\t\t\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\t\t\twidths: [thumbnail.dimensions.width],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t  ].join(\", \")\n\t\t\t\t\t: buildWidthSrcSet(field.url, {\n\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\twidths,\n\t\t\t\t\t  }),\n\t\t} as AsImageWidthSrcSetReturnType<Field>;\n\t} else {\n\t\treturn null as AsImageWidthSrcSetReturnType<Field>;\n\t}\n};\n", "import {\n\tBuildPixelDensitySrcSetParams,\n\tbuildPixelDensitySrcSet,\n\tbuildURL,\n} from \"imgix-url-builder\";\n\nimport type { ImageFieldImage } from \"../types/value/image\";\n\nimport { imageThumbnail as isImageThumbnailFilled } from \"./isFilled\";\n\n/**\n * The default pixel densities used to generate a `srcset` value.\n */\nconst DEFAULT_PIXEL_DENSITIES = [1, 2, 3];\n\n/**\n * Configuration for `asImagePixelDensitySrcSet()`.\n */\ntype AsImagePixelDensitySrcSetConfig = Omit<\n\tBuildPixelDensitySrcSetParams,\n\t\"pixelDensities\"\n> &\n\tPartial<Pick<BuildPixelDensitySrcSetParams, \"pixelDensities\">>;\n\n/**\n * The return type of `asImagePixelDensitySrcSet()`.\n */\ntype AsImagePixelDensitySrcSetReturnType<\n\tField extends ImageFieldImage | null | undefined,\n> = Field extends ImageFieldImage<\"filled\">\n\t? {\n\t\t\t/**\n\t\t\t * The image field's image URL with Imgix URL parameters (if given).\n\t\t\t */\n\t\t\tsrc: string;\n\n\t\t\t/**\n\t\t\t * A pixel-densitye-based `srcset` attribute value for the image field's\n\t\t\t * image with Imgix URL parameters (if given).\n\t\t\t */\n\t\t\tsrcset: string;\n\t  }\n\t: null;\n\n/**\n * Creates a pixel-density-based `srcset` from an image field with optional\n * image transformations (via Imgix URL parameters).\n *\n * If a `pixelDensities` parameter is not given, the following pixel densities\n * will be used by default: 1, 2, 3.\n *\n * @example\n *\n * ```ts\n * const srcset = asImagePixelDensitySrcSet(document.data.imageField, {\n * \tpixelDensities: [1, 2],\n * \tsat: -100,\n * });\n * // => {\n * //   src:    'https://images.prismic.io/repo/image.png?sat=-100',\n * //   srcset: 'https://images.prismic.io/repo/image.png?sat=-100&dpr=1 1x, ' +\n * //           'https://images.prismic.io/repo/image.png?sat=-100&dpr=2 2x'\n * // }\n * ```\n *\n * @param field - Image field (or one of its responsive views) from which to get\n *   an image URL.\n * @param config - An object of Imgix URL API parameters. The `pixelDensities`\n *   parameter defines the resulting `srcset` widths.\n *\n * @returns A `srcset` attribute value for the image field with Imgix URL\n *   parameters (if given). If the image field is empty, `null` is returned.\n *\n * @see Imgix URL parameters reference: https://docs.imgix.com/apis/rendering\n */\nexport const asImagePixelDensitySrcSet = <\n\tField extends ImageFieldImage | null | undefined,\n>(\n\tfield: Field,\n\tconfig: AsImagePixelDensitySrcSetConfig = {},\n): AsImagePixelDensitySrcSetReturnType<Field> => {\n\tif (field && isImageThumbnailFilled(field)) {\n\t\t// We are using destructuring to omit `pixelDensities` from the\n\t\t// object we will pass to `buildURL()`.\n\t\tconst { pixelDensities = DEFAULT_PIXEL_DENSITIES, ...imgixParams } = config;\n\n\t\treturn {\n\t\t\tsrc: buildURL(field.url, imgixParams),\n\t\t\tsrcset: buildPixelDensitySrcSet(field.url, {\n\t\t\t\t...imgixParams,\n\t\t\t\tpixelDensities,\n\t\t\t}),\n\t\t} as AsImagePixelDensitySrcSetReturnType<Field>;\n\t} else {\n\t\treturn null as AsImagePixelDensitySrcSetReturnType<Field>;\n\t}\n};\n", "import type { EmptyObjectField, FieldState } from \"./types\";\n\n/**\n * oEmbed 1.0 possible types.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport const OEmbedType = {\n\tPhoto: \"photo\",\n\tVideo: \"video\",\n\tLink: \"link\",\n\tRich: \"rich\",\n} as const;\n\n/**\n * oEmbed response base fields. Those are every mandatory fields an oEmbed\n * response must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\ntype OEmbedBase<TType extends (typeof OEmbedType)[keyof typeof OEmbedType]> = {\n\t/**\n\t * oEmbed resource type.\n\t */\n\ttype: TType;\n\n\t/**\n\t * oEmbed version number, this must be \"1.0\".\n\t */\n\tversion: string;\n};\n\n/**\n * oEmbed response extra fields. Those are every non-mandatory and unknown\n * fields an oEmbed response can feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type OEmbedExtra = {\n\t/**\n\t * oEmbed text title, describing the resource.\n\t */\n\ttitle?: string | null;\n\n\t/**\n\t * oEmbed resource author/owner name.\n\t */\n\tauthor_name?: string | null;\n\n\t/**\n\t * oEmbed resource author/owner URL.\n\t */\n\tauthor_url?: string | null;\n\n\t/**\n\t * oEmbed resource provider name.\n\t */\n\tprovider_name?: string | null;\n\n\t/**\n\t * oEmbed resource provider URL.\n\t */\n\tprovider_url?: string | null;\n\n\t/**\n\t * oEmbed suggested cache lifetime for the resource, in seconds.\n\t */\n\tcache_age?: number | null;\n\n\t/**\n\t * oEmbed resource thumbnail URL.\n\t */\n\tthumbnail_url?: string | null;\n\n\t/**\n\t * oEmbed resource thumbnail width.\n\t */\n\tthumbnail_width?: number | null;\n\n\t/**\n\t * oEmbed resource thumbnail height.\n\t */\n\tthumbnail_height?: number | null;\n\n\t/**\n\t * Providers may optionally include any parameters not specified in this\n\t * document (so long as they use the same key-value format) and consumers may\n\t * choose to ignore these. Consumers must ignore parameters they do not\n\t * understand.\n\t *\n\t * @see oEmbed specification: {@link https://oembed.com}\n\t */\n\t[key: string]: unknown | null;\n};\n\n/**\n * oEmbed photo type. Those are every mandatory fields an oEmbed photo response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type PhotoOEmbed = OEmbedBase<typeof OEmbedType.Photo> & {\n\t/**\n\t * oEmbed source URL of the image.\n\t */\n\turl: string;\n\n\t/**\n\t * oEmbed width in pixels of the image.\n\t */\n\twidth: number;\n\n\t/**\n\t * oEmbed height in pixels of the image.\n\t */\n\theight: number;\n};\n\n/**\n * oEmbed video type. Those are every mandatory fields an oEmbed video response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type VideoOEmbed = OEmbedBase<typeof OEmbedType.Video> & {\n\t/**\n\t * oEmbed HTML required to embed a video player.\n\t */\n\thtml: string;\n\n\t/**\n\t * oEmbed width in pixels required to display the HTML.\n\t */\n\twidth: number;\n\n\t/**\n\t * oEmbed height in pixels required to display the HTML.\n\t */\n\theight: number;\n};\n\n/**\n * oEmbed link type. Those are every mandatory fields an oEmbed link response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type LinkOEmbed = OEmbedBase<typeof OEmbedType.Link>;\n\n/**\n * oEmbed rich type. Those are every mandatory fields an oEmbed rich response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type RichOEmbed = OEmbedBase<typeof OEmbedType.Rich> & {\n\t/**\n\t * oEmbed HTML required to display the resource.\n\t */\n\thtml: string;\n\n\t/**\n\t * oEmbed width in pixels required to display the HTML.\n\t */\n\twidth: number;\n\n\t/**\n\t * oEmbed height in pixels required to display the HTML.\n\t */\n\theight: number;\n};\n\n/**\n * Any of the possible types of oEmbed response. Those contains only mandatory\n * fields their respective oEmbed response type must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type AnyOEmbed = PhotoOEmbed | VideoOEmbed | LinkOEmbed | RichOEmbed;\n\n/**\n * An embed field.\n *\n * @typeParam Data - Data provided by the URL's oEmbed provider.\n * @typeParam State - State of the field which determines its shape.\n *\n * @see More details: {@link https://prismic.io/docs/embed}\n */\nexport type EmbedField<\n\tData extends AnyOEmbed = AnyOEmbed & OEmbedExtra,\n\tState extends FieldState = FieldState,\n> = State extends \"empty\"\n\t? EmptyObjectField\n\t: Data & {\n\t\t\tembed_url: string;\n\t\t\thtml: string | null;\n\t  };\n", "import type { CustomTypeModelBooleanField } from \"./boolean\";\nimport type { CustomTypeModelColorField } from \"./color\";\nimport type { CustomTypeModelContentRelationshipField } from \"./contentRelationship\";\nimport type { CustomTypeModelDateField } from \"./date\";\nimport type { CustomTypeModelEmbedField } from \"./embed\";\nimport type { CustomTypeModelGeoPointField } from \"./geoPoint\";\nimport type {\n\tCustomTypeModelGroupField,\n\tCustomTypeModelNestedGroupField,\n} from \"./group\";\nimport type { CustomTypeModelImageField } from \"./image\";\nimport type { CustomTypeModelIntegrationField } from \"./integration\";\nimport type { CustomTypeModelKeyTextField } from \"./keyText\";\nimport type { CustomTypeModelLinkField } from \"./link\";\nimport type { CustomTypeModelLinkToMediaField } from \"./linkToMedia\";\nimport type { CustomTypeModelNumberField } from \"./number\";\nimport type { CustomTypeModelRangeField } from \"./range\";\nimport type { CustomTypeModelRichTextField } from \"./richText\";\nimport type { CustomTypeModelSelectField } from \"./select\";\nimport type { CustomTypeModelSeparatorField } from \"./separator\";\nimport type { CustomTypeModelSliceZoneField } from \"./sliceZone\";\nimport type { CustomTypeModelTimestampField } from \"./timestamp\";\nimport type { CustomTypeModelTitleField } from \"./title\";\nimport type { CustomTypeModelUIDField } from \"./uid\";\n\n/**\n * Type identifier for a custom type field.\n */\nexport const CustomTypeModelFieldType = {\n\tBoolean: \"Boolean\",\n\tColor: \"Color\",\n\tDate: \"Date\",\n\tEmbed: \"Embed\",\n\tGeoPoint: \"GeoPoint\",\n\tGroup: \"Group\",\n\tImage: \"Image\",\n\tIntegration: \"IntegrationFields\",\n\tLink: \"Link\",\n\tNumber: \"Number\",\n\tSelect: \"Select\",\n\tSlices: \"Slices\",\n\tStructuredText: \"StructuredText\",\n\tText: \"Text\",\n\tTimestamp: \"Timestamp\",\n\tUID: \"UID\",\n\t/**\n\t * @deprecated - Renamed to `Integration`.\n\t */\n\tIntegrationFields: \"IntegrationFields\",\n\t/**\n\t * @deprecated - Legacy field type. Use `Number` instead.\n\t */\n\tRange: \"Range\",\n\t/**\n\t * @deprecated - Legacy field type. Do not use.\n\t */\n\tSeparator: \"Separator\",\n\t/**\n\t * @deprecated - Legacy field type. Use `Slices` instead.\n\t */\n\tLegacySlices: \"Choice\",\n} as const;\n\n/**\n * A custom type field.\n */\nexport type CustomTypeModelField =\n\t| CustomTypeModelUIDField\n\t| CustomTypeModelGroupField\n\t| CustomTypeModelSliceZoneField\n\t| CustomTypeModelFieldForNestedGroup;\n\n/**\n * Any custom type field that is valid for a slice's primary section.\n */\nexport type CustomTypeModelFieldForSlicePrimary =\n\t| CustomTypeModelGroupField\n\t| CustomTypeModelFieldForNestedGroup;\n\n/**\n * Any custom type field that is valid for a group field.\n */\nexport type CustomTypeModelFieldForGroup =\n\t| CustomTypeModelNestedGroupField\n\t| CustomTypeModelFieldForNestedGroup;\n\n/**\n * Any custom type field that is valid for a nested group field.\n */\nexport type CustomTypeModelFieldForNestedGroup =\n\t| CustomTypeModelBooleanField\n\t| CustomTypeModelColorField\n\t| CustomTypeModelDateField\n\t| CustomTypeModelEmbedField\n\t| CustomTypeModelGeoPointField\n\t| CustomTypeModelImageField\n\t| CustomTypeModelIntegrationField\n\t| CustomTypeModelContentRelationshipField\n\t| CustomTypeModelLinkField\n\t| CustomTypeModelLinkToMediaField\n\t| CustomTypeModelNumberField\n\t| CustomTypeModelRangeField\n\t| CustomTypeModelSelectField\n\t| CustomTypeModelRichTextField\n\t| CustomTypeModelTitleField\n\t| CustomTypeModelKeyTextField\n\t| CustomTypeModelTimestampField\n\t| CustomTypeModelSeparatorField;\n", "import type { CustomTypeModelFieldType } from \"./types\";\n\n/**\n * A link custom type field.\n *\n * More details: {@link https://prismic.io/docs/link}\n */\nexport interface CustomTypeModelLinkField {\n\ttype: typeof CustomTypeModelFieldType.Link;\n\tconfig?: {\n\t\tlabel?: string | null;\n\t\tplaceholder?: string;\n\t\tselect?:\n\t\t\t| null\n\t\t\t| (typeof CustomTypeModelLinkSelectType)[keyof typeof CustomTypeModelLinkSelectType];\n\t\tallowTargetBlank?: boolean;\n\t};\n}\n\n/**\n * Type of a link custom type field.\n *\n * More details: {@link https://prismic.io/docs/link}\n */\nexport const CustomTypeModelLinkSelectType = {\n\tDocument: \"document\",\n\tMedia: \"media\",\n\tWeb: \"web\",\n} as const;\n", "import type { CustomTypeModelFieldType } from \"./types\";\n\nimport type { CustomTypeModelLegacySlice, CustomTypeModelSlice } from \"./slice\";\n\n/**\n * A Slice Zone custom type field.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport interface CustomTypeModelSliceZoneField<\n\tSlices extends Record<\n\t\tstring,\n\t\t| CustomTypeModelSlice\n\t\t| CustomTypeModelSharedSlice\n\t\t| CustomTypeModelLegacySlice\n\t> = Record<\n\t\tstring,\n\t\t| CustomTypeModelSlice\n\t\t| CustomTypeModelSharedSlice\n\t\t| CustomTypeModelLegacySlice\n\t>,\n> {\n\ttype:\n\t\t| typeof CustomTypeModelFieldType.Slices\n\t\t| typeof CustomTypeModelFieldType.LegacySlices;\n\tfieldset?: string | null;\n\tconfig?: {\n\t\tlabels?: Record<string, readonly CustomTypeModelSliceLabel[]> | null;\n\t\tchoices?: Slices;\n\t};\n}\n\n/**\n * Label for a Slice.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport interface CustomTypeModelSliceLabel {\n\tname: string;\n\tdisplay?: string;\n}\n\n/**\n * Type identifier for a Slice.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport const CustomTypeModelSliceType = {\n\tSlice: \"Slice\",\n\tSharedSlice: \"SharedSlice\",\n} as const;\n\n/**\n * A shared Slice for a custom type.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport interface CustomTypeModelSharedSlice {\n\ttype: typeof CustomTypeModelSliceType.SharedSlice;\n}\n", "import type { CustomTypeModelFieldForNestedGroup } from \"./types\";\n\nimport type { CustomTypeModelNestedGroupField } from \"./group\";\nimport type { CustomTypeModelSliceType } from \"./sliceZone\";\n\n/**\n * A Slice for a custom type.\n *\n * More details: {@link https://prismic.io/docs/slice}\n *\n * @typeParam NonRepeatFields - A record of fields that cannnot be repeated.\n * @typeParam RepeatFields - A record of fields that can be repeated.\n */\nexport interface CustomTypeModelSlice<\n\tNonRepeatFields extends Record<\n\t\tstring,\n\t\tCustomTypeModelFieldForNestedGroup\n\t> = Record<string, CustomTypeModelFieldForNestedGroup>,\n\tRepeatFields extends Record<\n\t\tstring,\n\t\tCustomTypeModelFieldForNestedGroup\n\t> = Record<string, CustomTypeModelFieldForNestedGroup>,\n> {\n\ttype: typeof CustomTypeModelSliceType.Slice;\n\tfieldset?: string | null;\n\tdescription?: string;\n\ticon?: string;\n\tdisplay?:\n\t\t| (typeof CustomTypeModelSliceDisplay)[keyof typeof CustomTypeModelSliceDisplay]\n\t\t| string;\n\t\"non-repeat\"?: NonRepeatFields;\n\trepeat?: RepeatFields;\n}\n\n/**\n * Display type for a Slice.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport const CustomTypeModelSliceDisplay = {\n\tList: \"list\",\n\tGrid: \"grid\",\n} as const;\n\n/**\n * @deprecated - Legacy slice type. Do not use.\n */\nexport type CustomTypeModelLegacySlice =\n\t| CustomTypeModelNestedGroupField\n\t| CustomTypeModelFieldForNestedGroup;\n", "import { WebhookBodyAPIUpdate } from \"./apiUpdate\";\nimport { WebhookBodyTestTrigger } from \"./testTrigger\";\n\nexport type WebhookBody = WebhookBodyAPIUpdate | WebhookBodyTestTrigger;\n\n/**\n * Types of Prismic Webhooks.\n *\n * @see More details: {@link https://prismic.io/docs/webhooks}\n */\nexport const WebhookType = {\n\tAPIUpdate: \"api-update\",\n\tTestTrigger: \"test-trigger\",\n} as const;\n\nexport interface WebhookBodyBase {\n\ttype: (typeof WebhookType)[keyof typeof WebhookType];\n\tdomain: string;\n\tapiUrl: string;\n\tsecret: string | null;\n}\n", "// Imports are used for deprecations.\nimport type { CustomTypeModelIntegrationField } from \"./types/model/integration\";\nimport type { IntegrationField } from \"./types/value/integration\";\nimport { RichTextNodeType } from \"./types/value/richText\";\n\nimport type {\n\tHTMLRichTextFunctionSerializer,\n\tHTMLRichTextMapSerializer,\n} from \"./helpers/asHTML\";\nimport { mapSliceZone } from \"./helpers/mapSliceZone\";\n\nimport { filter } from \"./filter\";\n\n//=============================================================================\n// Client - Query content from Prismic.\n//=============================================================================\n\n// Primary Client API.\nexport { createClient, Client } from \"./createClient\";\n\n// API endpoint helpers.\nexport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\";\nexport { getRepositoryName } from \"./getRepositoryName\";\nexport { getGraphQLEndpoint } from \"./getGraphQLEndpoint\";\nexport { isRepositoryName } from \"./isRepositoryName\";\nexport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\";\nexport { buildQueryURL } from \"./buildQueryURL\";\n\n// Toolbar helpers.\nexport { getToolbarSrc } from \"./getToolbarSrc\";\n\n// Query filters API.\n/**\n * @deprecated Renamed to `filter`\n */\n// TODO: Remove when we remove support for deprecated `predicate` export.\nconst predicate = filter;\nexport { filter, predicate };\n\n// A collection of well-known cookie names shared between Prismic libraries and systems.\nexport * as cookie from \"./cookie\";\n\n// General types used to query content from Prismic. These are made public to allow users to better type their projects.\nexport type {\n\tAbortSignalLike,\n\tClientConfig,\n\tCreateClient,\n\tFetchLike,\n\tHttpRequestLike,\n\tRequestInitLike,\n\tResponseLike,\n} from \"./createClient\";\nexport type {\n\tBuildQueryURLArgs,\n\tOrdering,\n\tQueryParams,\n\tRoute,\n} from \"./buildQueryURL\";\n\n//=============================================================================\n// Helpers - Manipulate content from Prismic.\n//=============================================================================\n\n// Primary Helpers API.\nexport { asDate } from \"./helpers/asDate\";\nexport { asLink } from \"./helpers/asLink\";\nexport { asLinkAttrs } from \"./helpers/asLinkAttrs\";\nexport { asText } from \"./helpers/asText\";\nexport { asHTML } from \"./helpers/asHTML\";\nexport { asImageSrc } from \"./helpers/asImageSrc\";\nexport { asImageWidthSrcSet } from \"./helpers/asImageWidthSrcSet\";\nexport { asImagePixelDensitySrcSet } from \"./helpers/asImagePixelDensitySrcSet\";\nexport * as isFilled from \"./helpers/isFilled\";\n\n/**\n * @deprecated Renamed to `mapSliceZone`\n */\nconst unstable_mapSliceZone = mapSliceZone;\nexport { mapSliceZone, unstable_mapSliceZone };\n\n// Conversion helper.\nexport { documentToLinkField } from \"./helpers/documentToLinkField\";\n\nexport type { LinkResolverFunction } from \"./helpers/asLink\";\nexport type { AsLinkAttrsConfig } from \"./helpers/asLinkAttrs\";\nexport type { SliceMapper } from \"./helpers/mapSliceZone\";\n\n/**\n * @deprecated Renamed to `HTMLRichTextMapSerializer`\n */\ntype HTMLMapSerializer = HTMLRichTextMapSerializer;\n/**\n * @deprecated Renamed to `HTMLRichTextFunctionSerializer`\n */\ntype HTMLFunctionSerializer = HTMLRichTextFunctionSerializer;\nexport type {\n\tHTMLRichTextMapSerializer,\n\tHTMLRichTextFunctionSerializer,\n\tHTMLMapSerializer,\n\tHTMLFunctionSerializer,\n};\nexport type { HTMLRichTextSerializer } from \"./helpers/asHTML\";\n\n//=============================================================================\n// Errors - Custom errors for Prismic APIs.\n//=============================================================================\n\nexport { PrismicError } from \"./errors/PrismicError\";\nexport { ForbiddenError } from \"./errors/ForbiddenError\";\nexport { NotFoundError } from \"./errors/NotFoundError\";\nexport { RefNotFoundError } from \"./errors/RefNotFoundError\";\nexport { RefExpiredError } from \"./errors/RefExpiredError\";\nexport { PreviewTokenExpiredError } from \"./errors/PreviewTokenExpired\";\nexport { ParsingError } from \"./errors/ParsingError\";\nexport { RepositoryNotFoundError } from \"./errors/RepositoryNotFoundError\";\n\n//=============================================================================\n// Types - Types representing Prismic content, models, and API payloads.\n//=============================================================================\n\n// Values - Types representing Prismic content.\n/**\n * @deprecated Use {@link RichTextNodeType} instead.\n */\n// TODO: Remove in v8.\nconst Element = RichTextNodeType;\nexport { RichTextNodeType, Element };\nexport { LinkType } from \"./types/value/link\";\nexport { OEmbedType } from \"./types/value/embed\";\n\nexport type {\n\tPrismicDocument,\n\tPrismicDocumentWithUID,\n\tPrismicDocumentWithoutUID,\n\tPrismicDocumentHeader,\n\tAlternateLanguage,\n} from \"./types/value/document\";\n\nexport type {\n\t// RichText & Title\n\tRichTextField,\n\t// RichText & Title (block nodes)\n\tRTTextNodeBase,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTListItemNode,\n\tRTOListItemNode,\n\t// RichText & Title (span nodes)\n\tRTSpanNodeBase,\n\tRTStrongNode,\n\tRTEmNode,\n\tRTLabelNode,\n\t// RichText & Title (media nodes)\n\tRTImageNode,\n\tRTEmbedNode,\n\t// RichText & Title (link nodes)\n\tRTLinkNode,\n\t// RichText & Title (serialization related nodes)\n\tRTListNode,\n\tRTOListNode,\n\tRTSpanNode,\n\t// RichText & Title (helpers)\n\tRTNode,\n\tRTTextNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTAnyNode,\n} from \"./types/value/richText\";\nexport type { TitleField } from \"./types/value/title\";\n\nexport type {\n\tImageField,\n\tImageFieldImage,\n\tFilledImageFieldImage,\n\tEmptyImageFieldImage,\n} from \"./types/value/image\";\n\nexport type {\n\tEmptyLinkField,\n\tLinkField,\n\tFilledLinkToWebField,\n} from \"./types/value/link\";\nexport type {\n\tContentRelationshipField,\n\tFilledContentRelationshipField,\n} from \"./types/value/contentRelationship\";\nexport type {\n\tLinkToMediaField,\n\tFilledLinkToMediaField,\n} from \"./types/value/linkToMedia\";\n\nexport type {\n\tOEmbedExtra,\n\tPhotoOEmbed,\n\tVideoOEmbed,\n\tLinkOEmbed,\n\tRichOEmbed,\n\tAnyOEmbed,\n\tEmbedField,\n} from \"./types/value/embed\";\n\nexport type { BooleanField } from \"./types/value/boolean\";\nexport type { ColorField } from \"./types/value/color\";\nexport type { DateField } from \"./types/value/date\";\nexport type { KeyTextField } from \"./types/value/keyText\";\nexport type { NumberField } from \"./types/value/number\";\nexport type { SelectField } from \"./types/value/select\";\nexport type { TimestampField } from \"./types/value/timestamp\";\nexport type { GeoPointField } from \"./types/value/geoPoint\";\n\n/**\n * @deprecated Renamed to `IntegrationField`\n */\n// TODO: Remove when we remove support for deprecated `IntegrationFields` export.\ntype IntegrationFields = IntegrationField;\nexport { IntegrationField, IntegrationFields };\n\nexport type { GroupField, NestedGroupField } from \"./types/value/group\";\n\nexport type { SliceZone } from \"./types/value/sliceZone\";\nexport type { Slice } from \"./types/value/slice\";\nexport type { SharedSlice } from \"./types/value/sharedSlice\";\nexport type { SharedSliceVariation } from \"./types/value/sharedSliceVariation\";\n\nexport type {\n\tFieldState,\n\tAnyRegularField,\n\tAnySlicePrimaryField,\n} from \"./types/value/types\";\n\n// Models - Types representing Prismic content models.\nexport { CustomTypeModelFieldType } from \"./types/model/types\";\nexport { CustomTypeModelLinkSelectType } from \"./types/model/link\";\nexport { CustomTypeModelSliceType } from \"./types/model/sliceZone\";\nexport { CustomTypeModelSliceDisplay } from \"./types/model/slice\";\n\nexport type {\n\tCustomTypeModel,\n\tCustomTypeModelDefinition,\n\tCustomTypeModelTab,\n} from \"./types/model/customType\";\n\nexport type {\n\tCustomTypeModelRichTextField,\n\tCustomTypeModelRichTextMultiField,\n\tCustomTypeModelRichTextSingleField,\n} from \"./types/model/richText\";\nexport type { CustomTypeModelTitleField } from \"./types/model/title\";\n\nexport type {\n\tCustomTypeModelImageField,\n\tCustomTypeModelImageConstraint,\n\tCustomTypeModelImageThumbnail,\n} from \"./types/model/image\";\n\nexport type { CustomTypeModelContentRelationshipField } from \"./types/model/contentRelationship\";\nexport type { CustomTypeModelLinkField } from \"./types/model/link\";\nexport type { CustomTypeModelLinkToMediaField } from \"./types/model/linkToMedia\";\n\nexport type { CustomTypeModelEmbedField } from \"./types/model/embed\";\n\nexport type { CustomTypeModelBooleanField } from \"./types/model/boolean\";\nexport type { CustomTypeModelColorField } from \"./types/model/color\";\nexport type { CustomTypeModelDateField } from \"./types/model/date\";\nexport type { CustomTypeModelKeyTextField } from \"./types/model/keyText\";\nexport type { CustomTypeModelNumberField } from \"./types/model/number\";\nexport type { CustomTypeModelSelectField } from \"./types/model/select\";\nexport type { CustomTypeModelTimestampField } from \"./types/model/timestamp\";\nexport type { CustomTypeModelGeoPointField } from \"./types/model/geoPoint\";\n\n/**\n * @deprecated Renamed to `CustomTypeModelIntegrationField`.\n */\n// TODO: Remove when we remove support for deprecated `CustomTypeModelIntegrationField` export.\ntype CustomTypeModelIntegrationFieldsField = CustomTypeModelIntegrationField;\nexport {\n\tCustomTypeModelIntegrationField,\n\tCustomTypeModelIntegrationFieldsField,\n};\nexport type {\n\tCustomTypeModelGroupField,\n\tCustomTypeModelNestedGroupField,\n} from \"./types/model/group\";\nexport type {\n\tCustomTypeModelSliceZoneField,\n\tCustomTypeModelSliceLabel,\n\tCustomTypeModelSharedSlice,\n} from \"./types/model/sliceZone\";\nexport type {\n\tCustomTypeModelSlice,\n\tCustomTypeModelLegacySlice,\n} from \"./types/model/slice\";\nexport type { SharedSliceModel } from \"./types/model/sharedSlice\";\nexport type { SharedSliceModelVariation } from \"./types/model/sharedSliceVariation\";\n\nexport type { CustomTypeModelUIDField } from \"./types/model/uid\";\n\nexport type { CustomTypeModelRangeField } from \"./types/model/range\";\nexport type { CustomTypeModelSeparatorField } from \"./types/model/separator\";\n\nexport type {\n\tCustomTypeModelField,\n\tCustomTypeModelFieldForGroup,\n\tCustomTypeModelFieldForNestedGroup,\n\tCustomTypeModelFieldForSlicePrimary,\n} from \"./types/model/types\";\n\n// API - Types representing Prismic Rest API V2 responses.\nexport type { Query } from \"./types/api/query\";\n\nexport type { Ref } from \"./types/api/ref\";\n\nexport type { Release } from \"./types/api/release\";\n\nexport type {\n\tRepository,\n\tLanguage,\n\tForm,\n\tFormField,\n} from \"./types/api/repository\";\n\nexport type { Tags } from \"./types/api/tags\";\n\n// Webhook - Types representing Prismic webhooks.\nexport { WebhookType } from \"./types/webhook/types\";\n\nexport type { WebhookBody } from \"./types/webhook/types\";\n\nexport type { WebhookBodyAPIUpdate } from \"./types/webhook/apiUpdate\";\n\nexport type { WebhookBodyTestTrigger } from \"./types/webhook/testTrigger\";\n"],
  "mappings": "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",
  "names": ["sliceZone", "filter", "ref", "previewCookieName", "filter", "predicate", "RefStateMode", "__publicField", "res", "group", "isFilledLink", "asText", "baseAsText", "isImageThumbnailFilled", "isFilled.imageThumbnail", "isImageThumbnailFilled"]
}
