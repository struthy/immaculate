"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const types = require('./../_node_modules/@prismicio/client/dist/types/model/types.cjs');
const commonTags = require("common-tags");
const addLine = require("./addLine.cjs");
const addSection = require("./addSection.cjs");
const buildFieldDocs = require("./buildFieldDocs.cjs");
const buildTypeName = require("./buildTypeName.cjs");
const buildUnion = require("./buildUnion.cjs");
const getHumanReadablePath = require("./getHumanReadablePath.cjs");
function buildFieldProperty(args) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  let code = buildFieldDocs.buildFieldDocs({
    name: args.name,
    field: args.field,
    path: args.path,
    tabName: args.tabName
  });
  const auxiliaryTypes = [];
  const contentTypeNames = [];
  const name = args.name.includes("-") || args.name.includes(":") || /^[0-9]/.test(args.name) ? `"${args.name}"` : args.name;
  switch (args.field.type) {
    case "UID": {
      break;
    }
    case "Boolean": {
      code = addLine.addLine(`${name}: prismic.BooleanField;`, code);
      break;
    }
    case "Color": {
      code = addLine.addLine(`${name}: prismic.ColorField;`, code);
      break;
    }
    case "Date": {
      code = addLine.addLine(`${name}: prismic.DateField;`, code);
      break;
    }
    case "Embed": {
      const providerTypes = [];
      if ((_a = args.fieldConfigs.embed) == null ? void 0 : _a.providerTypes) {
        for (const providerType in (_b = args.fieldConfigs.embed) == null ? void 0 : _b.providerTypes) {
          const configuredProviderType = (_c = args.fieldConfigs.embed) == null ? void 0 : _c.providerTypes[providerType];
          providerTypes.push(`({ provider_name: "${providerType}" } & ${configuredProviderType})`);
        }
      }
      const providerTypesUnion = buildUnion.buildUnion(providerTypes);
      code = providerTypes.length > 0 ? addLine.addLine(`${name}: prismic.EmbedField<prismic.AnyOEmbed & prismic.OEmbedExtra & (${providerTypesUnion})>`, code) : addLine.addLine(`${name}: prismic.EmbedField`, code);
      break;
    }
    case "GeoPoint": {
      code = addLine.addLine(`${name}: prismic.GeoPointField;`, code);
      break;
    }
    case "Image": {
      if (((_d = args.field.config) == null ? void 0 : _d.thumbnails) && args.field.config.thumbnails.length > 0) {
        const thumbnailNames = buildUnion.buildUnion(args.field.config.thumbnails.map((thumb) => `"${thumb.name}"`));
        code = addLine.addLine(`${name}: prismic.ImageField<${thumbnailNames}>;`, code);
      } else {
        code = addLine.addLine(`${name}: prismic.ImageField<never>;`, code);
      }
      break;
    }
    case "IntegrationFields": {
      const catalogType = ((_e = args.field.config) == null ? void 0 : _e.catalog) ? (_g = (_f = args.fieldConfigs.integrationFields) == null ? void 0 : _f.catalogTypes) == null ? void 0 : _g[args.field.config.catalog] : void 0;
      if (catalogType) {
        code = addLine.addLine(`${name}: prismic.IntegrationField<${catalogType}>;`, code);
      } else {
        code = addLine.addLine(`${name}: prismic.IntegrationField;`, code);
      }
      break;
    }
    case "Link": {
      switch ((_h = args.field.config) == null ? void 0 : _h.select) {
        case "document": {
          if ("customtypes" in args.field.config && args.field.config.customtypes && args.field.config.customtypes.length > 0) {
            const customTypeIDsUnion = buildUnion.buildUnion(args.field.config.customtypes.map((type) => `"${type}"`));
            code = addLine.addLine(`${name}: prismic.ContentRelationshipField<${customTypeIDsUnion}>;`, code);
          } else {
            code = addLine.addLine(`${name}: prismic.ContentRelationshipField;`, code);
          }
          break;
        }
        case "media": {
          code = addLine.addLine(`${name}: prismic.LinkToMediaField;`, code);
          break;
        }
        default: {
          code = addLine.addLine(`${name}: prismic.LinkField;`, code);
        }
      }
      break;
    }
    case "Number": {
      code = addLine.addLine(`${name}: prismic.NumberField;`, code);
      break;
    }
    case "StructuredText": {
      const isTitleField = args.field.config && "single" in args.field.config && args.field.config.single && args.field.config.single.split(",").every((blockType) => /heading/.test(blockType));
      if (isTitleField) {
        code = addLine.addLine(`${name}: prismic.TitleField;`, code);
      } else {
        code = addLine.addLine(`${name}: prismic.RichTextField;`, code);
      }
      break;
    }
    case "Select": {
      const options = ((_j = (_i = args.field.config) == null ? void 0 : _i.options) == null ? void 0 : _j.map((option) => `"${option}"`)) || [];
      const optionsType = options.length ? buildUnion.buildUnion(options) : "string";
      const hasDefault = Boolean((_k = args.field.config) == null ? void 0 : _k.default_value);
      if (hasDefault) {
        code = addLine.addLine(`${name}: prismic.SelectField<${optionsType}, "filled">;`, code);
      } else {
        code = addLine.addLine(`${name}: prismic.SelectField${options.length > 0 ? `<${optionsType}>` : ""};`, code);
      }
      break;
    }
    case "Text": {
      code = addLine.addLine(`${name}: prismic.KeyTextField;`, code);
      break;
    }
    case "Timestamp": {
      code = addLine.addLine(`${name}: prismic.TimestampField;`, code);
      break;
    }
    case "Group": {
      const groupPathParts = args.path.filter((part) => part.model !== void 0 && "type" in part.model && part.model.type === types.CustomTypeModelFieldType.Group);
      const isNestedGroup = groupPathParts.length > 0;
      let itemName;
      if (args.path[0].model && "type" in args.path[0].model && args.path[0].model.type === "SharedSlice") {
        const [slicePathPart, variationPathPart, zonePathPart] = args.path;
        itemName = buildTypeName.buildTypeName(slicePathPart.name, "Slice", variationPathPart.name, zonePathPart.name, ...groupPathParts.map((part) => part.name), args.name, "Item");
      } else {
        itemName = buildTypeName.buildTypeName(args.path[0].name, "Document", "Data", ...groupPathParts.map((part) => part.name), args.name, "Item");
      }
      const path = [
        ...args.path,
        {
          name,
          model: args.field
        }
      ];
      const humanReadablePath = getHumanReadablePath.getHumanReadablePath({ path });
      const itemFieldProperties = buildFieldProperties({
        fields: ((_l = args.field.config) == null ? void 0 : _l.fields) || {},
        fieldConfigs: args.fieldConfigs,
        path
      });
      auxiliaryTypes.push(...itemFieldProperties.auxiliaryTypes);
      contentTypeNames.push(...itemFieldProperties.contentTypeNames);
      auxiliaryTypes.push({
        name: itemName,
        code: commonTags.source`
					/**
					 * Item in *${humanReadablePath}*
					 */
					export interface ${itemName} {
						${itemFieldProperties.code}
					}
				`
      });
      contentTypeNames.push(itemName);
      if (isNestedGroup) {
        code = addLine.addLine(`${name}: prismic.NestedGroupField<Simplify<${itemName}>>;`, code);
      } else {
        code = addLine.addLine(`${name}: prismic.GroupField<Simplify<${itemName}>>;`, code);
      }
      break;
    }
    case "Slices": {
      const choiceNames = [];
      if ((_m = args.field.config) == null ? void 0 : _m.choices) {
        for (const choiceID in args.field.config.choices) {
          const choice = args.field.config.choices[choiceID];
          if (choice.type === "SharedSlice") {
            choiceNames.push(buildTypeName.buildTypeName(choiceID, "Slice"));
          } else if (choice.type === "Slice") {
            const sliceName = buildTypeName.buildTypeName(args.path[0].name, "Document", "Data", args.name, choiceID, "Slice");
            let primaryInterfaceName;
            if (choice["non-repeat"] && Object.keys(choice["non-repeat"]).length > 0) {
              primaryInterfaceName = buildTypeName.buildTypeName(sliceName, "Primary");
              const path = [
                ...args.path,
                {
                  name: args.name,
                  model: args.field
                },
                {
                  name: choiceID,
                  model: choice
                },
                {
                  name: "primary",
                  label: "Primary"
                }
              ];
              const humanReadablePath = getHumanReadablePath.getHumanReadablePath({ path });
              const primaryFieldProperties = buildFieldProperties({
                fields: choice["non-repeat"],
                fieldConfigs: args.fieldConfigs,
                path
              });
              auxiliaryTypes.push(...primaryFieldProperties.auxiliaryTypes);
              contentTypeNames.push(...primaryFieldProperties.contentTypeNames);
              let primaryCode = commonTags.stripIndent`
								/**
								 * Primary content in *${humanReadablePath}*
								 */
							`;
              primaryCode = primaryFieldProperties.code ? addLine.addLine(commonTags.source`
											export interface ${primaryInterfaceName} {
												${primaryFieldProperties.code}
											}
										`, primaryCode) : addLine.addLine(`export interface ${primaryInterfaceName} {}`, primaryCode);
              auxiliaryTypes.push({
                name: primaryInterfaceName,
                code: primaryCode
              });
              contentTypeNames.push(primaryInterfaceName);
            }
            let itemInterfaceName;
            if (choice.repeat && Object.keys(choice.repeat).length > 0) {
              itemInterfaceName = buildTypeName.buildTypeName(sliceName, "Item");
              const path = [
                ...args.path,
                {
                  name: args.name,
                  model: args.field
                },
                {
                  name: choiceID,
                  model: choice
                },
                {
                  name: "items",
                  label: "Items"
                }
              ];
              const humanReadablePath = getHumanReadablePath.getHumanReadablePath({ path });
              const itemFieldProperties = buildFieldProperties({
                fields: choice.repeat,
                fieldConfigs: args.fieldConfigs,
                path
              });
              auxiliaryTypes.push(...itemFieldProperties.auxiliaryTypes);
              contentTypeNames.push(...itemFieldProperties.contentTypeNames);
              let itemCode = commonTags.stripIndent`
								/**
								 * Item content in *${humanReadablePath}*
								 */
							`;
              itemCode = itemFieldProperties.code ? addLine.addLine(commonTags.source`
											export interface ${itemInterfaceName} {
												${itemFieldProperties.code}
											}
										`, itemCode) : addLine.addLine(`export interface ${itemInterfaceName} {}`, itemCode);
              auxiliaryTypes.push({
                name: itemInterfaceName,
                code: itemCode
              });
              contentTypeNames.push(itemInterfaceName);
            }
            auxiliaryTypes.push({
              name: sliceName,
              code: commonTags.stripIndent`
								/**
								 * Slice for *${getHumanReadablePath.getHumanReadablePath({
                path: [
                  ...args.path,
                  {
                    name: args.name,
                    model: args.field
                  }
                ]
              })}*
								 */
								export type ${sliceName} = prismic.Slice<"${choiceID}", ${primaryInterfaceName ? `Simplify<${primaryInterfaceName}>` : `Record<string, never>`}, ${itemInterfaceName ? `Simplify<${itemInterfaceName}>` : `never`}>
							`
            });
            choiceNames.push(sliceName);
          }
        }
      }
      const choiceUnionName = buildTypeName.buildTypeName(args.path[0].name, "Document", "Data", args.name, "Slice");
      const choiceUnion = buildUnion.buildUnion(choiceNames);
      auxiliaryTypes.push({
        name: choiceUnionName,
        code: `type ${choiceUnionName} = ${choiceUnion}`
      });
      contentTypeNames.push(choiceUnionName);
      code = addLine.addLine(`${name}: prismic.SliceZone<${choiceUnionName}>;`, code);
      break;
    }
    default: {
      code = addLine.addLine(`${name}: unknown;`, code);
    }
  }
  return {
    code,
    auxiliaryTypes,
    contentTypeNames
  };
}
function buildFieldProperties(args) {
  let code = "";
  const auxiliaryTypes = [];
  const contentTypeNames = [];
  for (const name in args.fields) {
    const field = args.fields[name];
    const fieldProperty = buildFieldProperty({
      name,
      field,
      path: args.path,
      fieldConfigs: args.fieldConfigs,
      tabName: args.tabName
    });
    code = addSection.addSection(fieldProperty.code, code);
    auxiliaryTypes.push(...fieldProperty.auxiliaryTypes);
    contentTypeNames.push(...fieldProperty.contentTypeNames);
  }
  return {
    code,
    auxiliaryTypes,
    contentTypeNames
  };
}
exports.buildFieldProperties = buildFieldProperties;
//# sourceMappingURL=buildFieldProperties.cjs.map
