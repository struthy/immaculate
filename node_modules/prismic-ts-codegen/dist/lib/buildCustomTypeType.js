import { source } from "common-tags";
import { CUSTOM_TYPES_DOCUMENTATION_URL } from "../constants.js";
import { addSection } from "./addSection.js";
import { buildCustomTypeDataType } from "./buildCustomTypeDataType.js";
import { buildTypeName } from "./buildTypeName.js";
import { buildUnion } from "./buildUnion.js";
import { checkHasUIDField } from "./checkHasUIDFIeld.js";
import { getCacheKey } from "./getCacheKey.js";
import { getHumanReadableModelName } from "./getHumanReadableModelName.js";
function buildCustomTypeType(args) {
  if (args.cache) {
    const key = getCacheKey(args.model);
    const cached = args.cache.get(key);
    if (cached) {
      return cached;
    }
  }
  let code = "";
  const auxiliaryTypes = [];
  const contentTypeNames = [];
  const name = buildTypeName(args.model.id, "Document");
  const langDefault = args.localeIDs && args.localeIDs.length > 0 ? buildUnion(args.localeIDs.map((localeID) => `"${localeID}"`)) : "string";
  const baseDocumentType = checkHasUIDField(args.model) ? "PrismicDocumentWithUID" : "PrismicDocumentWithoutUID";
  const humanReadableName = getHumanReadableModelName({
    name: args.model.id,
    model: args.model
  });
  const dataType = buildCustomTypeDataType({
    model: args.model,
    fieldConfigs: args.fieldConfigs
  });
  auxiliaryTypes.push(...dataType.auxiliaryTypes);
  contentTypeNames.push(dataType.name);
  contentTypeNames.push(...dataType.contentTypeNames);
  code = addSection(dataType.code, code);
  code = addSection(source`
			/**
			 * ${humanReadableName} document from Prismic
			 *
			 * - **API ID**: \`${args.model.id}\`
			 * - **Repeatable**: \`${args.model.repeatable.toString()}\`
			 * - **Documentation**: ${CUSTOM_TYPES_DOCUMENTATION_URL}
			 *
			 * @typeParam Lang - Language API ID of the document.
			 */
			export type ${name}<Lang extends string = ${langDefault}> = prismic.${baseDocumentType}<Simplify<${dataType.name}>, "${args.model.id}", Lang>;
		`, code);
  const result = {
    name,
    code,
    auxiliaryTypes,
    contentTypeNames
  };
  if (args.cache) {
    const key = getCacheKey(args.model);
    args.cache.set(key, result);
  }
  return result;
}
export {
  buildCustomTypeType
};
//# sourceMappingURL=buildCustomTypeType.js.map
