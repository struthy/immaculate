"use strict";
const commonTags = require("common-tags");
const fs = require("fs");
const index = require('./_node_modules/meow/source/index.cjs');
const path = require("path");
const generateTypes = require("./generateTypes.cjs");
const detectTypesProvider = require("./detectTypesProvider.cjs");
const configSchema = require("./cli/configSchema.cjs");
const constants = require("./cli/constants.cjs");
const loadConfig = require("./cli/loadConfig.cjs");
const loadLocaleIDs = require("./cli/loadLocaleIDs.cjs");
const loadModels = require("./cli/loadModels.cjs");
const cli = index(`
	Usage:
	    prismic-ts-codegen [options...]
	    prismic-ts-codegen init [options...]

	Commands:
	    init [options]

	Options:
	    -c, --config <path>  Path to a prismic-ts-codegen configuration file.
	`, {
  importMeta: { url: typeof document === "undefined" ? require("url").pathToFileURL(__filename).href : document.currentScript && document.currentScript.src || new URL("cli.cjs", document.baseURI).href },
  flags: {
    config: {
      type: "string",
      shortFlag: "c",
      isRequired: false
    }
  }
});
const main = async () => {
  var _a, _b, _c, _d, _e;
  if (cli.input[0] === "init") {
    const configPath = cli.flags.config || "prismicCodegen.config.ts";
    if (fs.existsSync(configPath)) {
      console.info(`
${configPath} already exists.`);
    } else {
      let contents = "";
      if (fs.existsSync("slicemachine.config.json") || fs.existsSync("sm.json")) {
        contents = commonTags.stripIndent`
					import type { Config } from "prismic-ts-codegen";

					const config: Config = {
					  output: "./types.generated.ts",
					  models: ["./customtypes/**/index.json", "./slices/**/model.json"],
					};

					export default config;
				`;
      } else {
        contents = commonTags.stripIndent`
					import type { Config } from "prismic-ts-codegen";

					const config: Config = {
					  output: "./types.generated.ts",
					};

					export default config;
				`;
      }
      fs.writeFileSync(configPath, contents);
      console.info(`
Created prismic-ts-codegen config file: ${configPath}`);
    }
  } else {
    const unvalidatedConfig = loadConfig.loadConfig({ path: cli.flags.config });
    const { value: config, error } = configSchema.configSchema.validate(unvalidatedConfig);
    if (config && !error) {
      const { customTypeModels, sharedSliceModels } = await loadModels.loadModels({
        localPaths: Array.isArray(config.models) ? config.models : (_a = config.models) == null ? void 0 : _a.files,
        repositoryName: config.repositoryName,
        customTypesAPIToken: config.customTypesAPIToken,
        fetchFromRepository: config.models && "fetchFromRepository" in config.models && config.models.fetchFromRepository
      });
      const localeIDs = await loadLocaleIDs.loadLocaleIDs({
        localeIDs: Array.isArray(config.locales) ? config.locales : (_b = config.locales) == null ? void 0 : _b.ids,
        repositoryName: config.repositoryName,
        accessToken: config.accessToken,
        fetchFromRepository: config.locales && "fetchFromRepository" in config.locales && config.locales.fetchFromRepository
      });
      const typesProvider = config.typesProvider || await detectTypesProvider.detectTypesProvider();
      const hasCustomTypeModels = customTypeModels.length > 0;
      if (((_c = config.clientIntegration) == null ? void 0 : _c.includeCreateClientInterface) && !hasCustomTypeModels) {
        console.info("[INFO]: prismic-ts-codegen was configured to automatically integrate with `@prismicio/client`, but the integration was not generated because no Custom Type models were found. Automatic integration requires at least one Custom Type model.");
      }
      const types = generateTypes.generateTypes({
        customTypeModels,
        sharedSliceModels,
        localeIDs,
        fieldConfigs: config.fields,
        clientIntegration: {
          includeCreateClientInterface: hasCustomTypeModels ? ((_d = config.clientIntegration) == null ? void 0 : _d.includeCreateClientInterface) ?? true : false,
          includeContentNamespace: ((_e = config.clientIntegration) == null ? void 0 : _e.includeContentNamespace) ?? true
        },
        typesProvider
      });
      const fileContents = `${constants.NON_EDITABLE_FILE_HEADER}

${types}`;
      if (config.output) {
        fs.writeFileSync(path.resolve(config.output), fileContents);
        console.info(`
Generated types in: ${config.output}`);
      } else {
        process.stdout.write(types + "\n");
      }
    } else {
      if (error) {
        console.error(error.message);
        process.exit(1);
      }
    }
  }
};
main().catch((error) => {
  console.error(error);
  process.exit(1);
});
//# sourceMappingURL=cli.cjs.map
