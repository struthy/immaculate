{"version":3,"file":"createClient.js","sources":["../../../../../node_modules/@prismicio/client/dist/createClient.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { appendFilters } from \"./lib/appendFilters.js\";\nimport { castThunk } from \"./lib/castThunk.js\";\nimport { devMsg } from \"./lib/devMsg.js\";\nimport { everyTagFilter } from \"./lib/everyTagFilter.js\";\nimport { findMasterRef } from \"./lib/findMasterRef.js\";\nimport { findRefByID } from \"./lib/findRefByID.js\";\nimport { findRefByLabel } from \"./lib/findRefByLabel.js\";\nimport { getPreviewCookie } from \"./lib/getPreviewCookie.js\";\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery.js\";\nimport { someTagsFilter } from \"./lib/someTagsFilter.js\";\nimport { typeFilter } from \"./lib/typeFilter.js\";\nimport { ForbiddenError } from \"./errors/ForbiddenError.js\";\nimport { NotFoundError } from \"./errors/NotFoundError.js\";\nimport { ParsingError } from \"./errors/ParsingError.js\";\nimport { PreviewTokenExpiredError } from \"./errors/PreviewTokenExpired.js\";\nimport { PrismicError } from \"./errors/PrismicError.js\";\nimport { RefExpiredError } from \"./errors/RefExpiredError.js\";\nimport { RefNotFoundError } from \"./errors/RefNotFoundError.js\";\nimport { RepositoryNotFoundError } from \"./errors/RepositoryNotFoundError.js\";\nimport { asLink } from \"./helpers/asLink.js\";\nimport { buildQueryURL } from \"./buildQueryURL.js\";\nimport { filter } from \"./filter.js\";\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint.js\";\nimport { getRepositoryName } from \"./getRepositoryName.js\";\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint.js\";\nconst MAX_PAGE_SIZE = 100;\nconst REPOSITORY_CACHE_TTL = 5e3;\nconst GET_ALL_QUERY_DELAY = 500;\nconst DEFUALT_RETRY_AFTER_MS = 1e3;\nvar RefStateMode;\n(function(RefStateMode2) {\n  RefStateMode2[\"Master\"] = \"Master\";\n  RefStateMode2[\"ReleaseID\"] = \"ReleaseID\";\n  RefStateMode2[\"ReleaseLabel\"] = \"ReleaseLabel\";\n  RefStateMode2[\"Manual\"] = \"Manual\";\n})(RefStateMode || (RefStateMode = {}));\nconst createClient = (repositoryNameOrEndpoint, options) => new Client(repositoryNameOrEndpoint, options);\nclass Client {\n  /**\n   * Creates a Prismic client that can be used to query a repository.\n   *\n   * If used in an environment where a global `fetch` function is unavailable,\n   * such as Node.js, the `fetch` option must be provided as part of the\n   * `options` parameter.\n   *\n   * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n   *   API V2 endpoint for the repository.\n   * @param options - Configuration that determines how content will be queried\n   *   from the Prismic repository.\n   *\n   * @returns A client that can query content from the repository.\n   */\n  constructor(repositoryNameOrEndpoint, options = {}) {\n    /**\n     * The Prismic REST API V2 endpoint for the repository (use\n     * `prismic.getRepositoryEndpoint` for the default endpoint).\n     */\n    __publicField(this, \"endpoint\");\n    /**\n     * The secure token for accessing the API (only needed if your repository is\n     * set to private).\n     *\n     * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n     */\n    __publicField(this, \"accessToken\");\n    /**\n     * A list of route resolver objects that define how a document's `url` field\n     * is resolved.\n     *\n     * {@link https://prismic.io/docs/route-resolver}\n     */\n    __publicField(this, \"routes\");\n    /**\n     * The `brokenRoute` option allows you to define the route populated in the\n     * `url` property for broken link or content relationship fields. A broken\n     * link is a link or content relationship field whose linked document has been\n     * unpublished or deleted.\n     *\n     * {@link https://prismic.io/docs/route-resolver}\n     */\n    __publicField(this, \"brokenRoute\");\n    /**\n     * The function used to make network requests to the Prismic REST API. In\n     * environments where a global `fetch` function does not exist, such as\n     * Node.js, this function must be provided.\n     */\n    __publicField(this, \"fetchFn\");\n    __publicField(this, \"fetchOptions\");\n    /**\n     * Default parameters that will be sent with each query. These parameters can\n     * be overridden on each query if needed.\n     */\n    __publicField(this, \"defaultParams\");\n    /**\n     * The client's ref mode state. This determines which ref is used during\n     * queries.\n     */\n    __publicField(this, \"refState\", {\n      mode: RefStateMode.Master,\n      autoPreviewsEnabled: true\n    });\n    /**\n     * Cached repository value.\n     */\n    __publicField(this, \"cachedRepository\");\n    /**\n     * Timestamp at which the cached repository data is considered stale.\n     */\n    __publicField(this, \"cachedRepositoryExpiration\", 0);\n    /**\n     * Active `fetch()` jobs keyed by URL and AbortSignal (if it exists).\n     */\n    __publicField(this, \"fetchJobs\", {});\n    if (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n      if (process.env.NODE_ENV === \"development\") {\n        if (/\\.prismic\\.io\\/(?!api\\/v2\\/?)/i.test(repositoryNameOrEndpoint)) {\n          throw new PrismicError(\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\", void 0, void 0);\n        }\n        const hostname = new URL(repositoryNameOrEndpoint).hostname.toLowerCase();\n        if (hostname.endsWith(\".prismic.io\") && !hostname.endsWith(\".cdn.prismic.io\")) {\n          const repositoryName = getRepositoryName(repositoryNameOrEndpoint);\n          const dotCDNEndpoint = getRepositoryEndpoint(repositoryName);\n          console.warn(`[@prismicio/client] A non-.cdn endpoint was provided to create a client with (\\`${repositoryNameOrEndpoint}\\`). Non-.cdn endpoints can have unexpected side-effects and cause performance issues when querying Prismic. Please convert it to the \\`.cdn\\` alternative (\\`${dotCDNEndpoint}\\`) or use the repository name directly instead (\\`${repositoryName}\\`). For more details, see ${devMsg(\"endpoint-must-use-cdn\")}`);\n        }\n      }\n      this.endpoint = repositoryNameOrEndpoint;\n    } else {\n      this.endpoint = getRepositoryEndpoint(repositoryNameOrEndpoint);\n    }\n    this.accessToken = options.accessToken;\n    this.routes = options.routes;\n    this.brokenRoute = options.brokenRoute;\n    this.fetchOptions = options.fetchOptions;\n    this.defaultParams = options.defaultParams;\n    if (options.ref) {\n      this.queryContentFromRef(options.ref);\n    }\n    if (typeof options.fetch === \"function\") {\n      this.fetchFn = options.fetch;\n    } else if (typeof globalThis.fetch === \"function\") {\n      this.fetchFn = globalThis.fetch;\n    } else {\n      throw new PrismicError(\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\", void 0, void 0);\n    }\n    if (this.fetchFn === globalThis.fetch) {\n      this.fetchFn = this.fetchFn.bind(globalThis);\n    }\n    this.graphQLFetch = this.graphQLFetch.bind(this);\n  }\n  /**\n   * Enables the client to automatically query content from a preview session if\n   * one is active in browser environments. This is enabled by default in the\n   * browser.\n   *\n   * For server environments, use `enableAutoPreviewsFromReq`.\n   *\n   * @example\n   *\n   * ```ts\n   * client.enableAutoPreviews();\n   * ```\n   *\n   * @see enableAutoPreviewsFromReq\n   */\n  enableAutoPreviews() {\n    this.refState.autoPreviewsEnabled = true;\n  }\n  /**\n   * Enables the client to automatically query content from a preview session if\n   * one is active in server environments. This is disabled by default on the\n   * server.\n   *\n   * For browser environments, use `enableAutoPreviews`.\n   *\n   * @example\n   *\n   * ```ts\n   * // In an express app\n   * app.get(\"/\", function (req, res) {\n   * \tclient.enableAutoPreviewsFromReq(req);\n   * });\n   * ```\n   *\n   * @param req - An HTTP server request object containing the request's\n   *   cookies.\n   */\n  enableAutoPreviewsFromReq(req) {\n    this.refState.httpRequest = req;\n    this.refState.autoPreviewsEnabled = true;\n  }\n  /**\n   * Disables the client from automatically querying content from a preview\n   * session if one is active.\n   *\n   * Automatic preview content querying is enabled by default unless this method\n   * is called.\n   *\n   * @example\n   *\n   * ```ts\n   * client.disableAutoPreviews();\n   * ```\n   */\n  disableAutoPreviews() {\n    this.refState.autoPreviewsEnabled = false;\n  }\n  /**\n   * Queries content from the Prismic repository.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.get();\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param params - Parameters to filter, sort, and paginate results.\n   *\n   * @returns A paginated response containing the result of the query.\n   */\n  async get(params) {\n    const url = await this.buildQueryURL(params);\n    return await this.fetch(url, params);\n  }\n  /**\n   * Queries content from the Prismic repository and returns only the first\n   * result, if any.\n   *\n   * @example\n   *\n   * ```ts\n   * const document = await client.getFirst();\n   * ```\n   *\n   * @typeParam TDocument - Type of the Prismic document returned.\n   *\n   * @param params - Parameters to filter, sort, and paginate results. @returns\n   *   The first result of the query, if any.\n   */\n  async getFirst(params) {\n    var _a;\n    const actualParams = { ...params };\n    if (!(params && params.page) && !(params == null ? void 0 : params.pageSize)) {\n      actualParams.pageSize = ((_a = this.defaultParams) == null ? void 0 : _a.pageSize) ?? 1;\n    }\n    const url = await this.buildQueryURL(actualParams);\n    const result = await this.fetch(url, params);\n    const firstResult = result.results[0];\n    if (firstResult) {\n      return firstResult;\n    }\n    throw new NotFoundError(\"No documents were returned\", url, void 0);\n  }\n  /**\n   * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n   * require more resources than other methods. Prefer using other methods that\n   * filter by filters such as `getAllByType`.\n   *\n   * Queries content from the Prismic repository and returns all matching\n   * content. If no filters are provided, all documents will be fetched.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.dangerouslyGetAll();\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param params - Parameters to filter, sort, and paginate results.\n   *\n   * @returns A list of documents matching the query.\n   */\n  async dangerouslyGetAll(params = {}) {\n    var _a;\n    const { limit = Infinity, ...actualParams } = params;\n    const resolvedParams = {\n      ...actualParams,\n      pageSize: Math.min(limit, actualParams.pageSize || ((_a = this.defaultParams) == null ? void 0 : _a.pageSize) || MAX_PAGE_SIZE)\n    };\n    const documents = [];\n    let latestResult;\n    while ((!latestResult || latestResult.next_page) && documents.length < limit) {\n      const page = latestResult ? latestResult.page + 1 : void 0;\n      latestResult = await this.get({ ...resolvedParams, page });\n      documents.push(...latestResult.results);\n      if (latestResult.next_page) {\n        await new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));\n      }\n    }\n    return documents.slice(0, limit);\n  }\n  /**\n   * Queries a document from the Prismic repository with a specific ID.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n   * ```\n   *\n   * @typeParam TDocument- Type of the Prismic document returned.\n   *\n   * @param id - ID of the document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns The document with an ID matching the `id` parameter, if a matching\n   *   document exists.\n   */\n  async getByID(id, params) {\n    return await this.getFirst(appendFilters(params, filter.at(\"document.id\", id)));\n  }\n  /**\n   * Queries documents from the Prismic repository with specific IDs.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByIDs([\n   * \t\"WW4bKScAAMAqmluX\",\n   * \t\"U1kTRgEAAC8A5ldS\",\n   * ]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param ids - A list of document IDs.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents with IDs matching the\n   *   `ids` parameter.\n   */\n  async getByIDs(ids, params) {\n    return await this.get(appendFilters(params, filter.in(\"document.id\", ids)));\n  }\n  /**\n   * Queries all documents from the Prismic repository with specific IDs.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getAllByIDs([\n   * \t\"WW4bKScAAMAqmluX\",\n   * \t\"U1kTRgEAAC8A5ldS\",\n   * ]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param ids - A list of document IDs.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of documents with IDs matching the `ids` parameter.\n   */\n  async getAllByIDs(ids, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, filter.in(\"document.id\", ids)));\n  }\n  /**\n   * Queries a document from the Prismic repository with a specific UID and\n   * custom type.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const document = await client.getByUID(\"blog_post\", \"my-first-post\");\n   * ```\n   *\n   * @typeParam TDocument - Type of the Prismic document returned.\n   *\n   * @param documentType - The API ID of the document's custom type.\n   * @param uid - UID of the document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns The document with a UID matching the `uid` parameter, if a\n   *   matching document exists.\n   */\n  async getByUID(documentType, uid, params) {\n    return await this.getFirst(appendFilters(params, [\n      typeFilter(documentType),\n      filter.at(`my.${documentType}.uid`, uid)\n    ]));\n  }\n  /**\n   * Queries document from the Prismic repository with specific UIDs and Custom\n   * Type.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const document = await client.getByUIDs(\"blog_post\", [\n   * \t\"my-first-post\",\n   * \t\"my-second-post\",\n   * ]);\n   * ```\n   *\n   * @typeParam TDocument - Type of the Prismic document returned.\n   *\n   * @param documentType - The API ID of the document's custom type.\n   * @param uids - A list of document UIDs.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents with UIDs matching the\n   *   `uids` parameter.\n   */\n  async getByUIDs(documentType, uids, params) {\n    return await this.get(appendFilters(params, [\n      typeFilter(documentType),\n      filter.in(`my.${documentType}.uid`, uids)\n    ]));\n  }\n  /**\n   * Queries all documents from the Prismic repository with specific UIDs and\n   * custom type.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getAllByUIDs([\n   * \t\"my-first-post\",\n   * \t\"my-second-post\",\n   * ]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param documentType - The API ID of the document's custom type.\n   * @param uids - A list of document UIDs.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of documents with UIDs matching the `uids` parameter.\n   */\n  async getAllByUIDs(documentType, uids, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, [\n      typeFilter(documentType),\n      filter.in(`my.${documentType}.uid`, uids)\n    ]));\n  }\n  /**\n   * Queries a singleton document from the Prismic repository for a specific\n   * custom type.\n   *\n   * @remarks\n   * A singleton document is one that is configured in Prismic to only allow one\n   * instance. For example, a repository may be configured to contain just one\n   * Settings document. This is in contrast to a repeatable custom type which\n   * allows multiple instances of itself.\n   *\n   * @example\n   *\n   * ```ts\n   * const document = await client.getSingle(\"settings\");\n   * ```\n   *\n   * @typeParam TDocument - Type of the Prismic document returned.\n   *\n   * @param documentType - The API ID of the singleton custom type.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns The singleton document for the custom type, if a matching document\n   *   exists.\n   */\n  async getSingle(documentType, params) {\n    return await this.getFirst(appendFilters(params, typeFilter(documentType)));\n  }\n  /**\n   * Queries documents from the Prismic repository for a specific custom type.\n   *\n   * Use `getAllByType` instead if you need to query all documents for a\n   * specific custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByType(\"blog_post\");\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param documentType - The API ID of the custom type.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents of the custom type.\n   */\n  async getByType(documentType, params) {\n    return await this.get(appendFilters(params, typeFilter(documentType)));\n  }\n  /**\n   * Queries all documents from the Prismic repository for a specific Custom\n   * Type.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByType(\"blog_post\");\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param documentType - The API ID of the custom type.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of all documents of the custom type.\n   */\n  async getAllByType(documentType, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, typeFilter(documentType)));\n  }\n  /**\n   * Queries documents from the Prismic repository with a specific tag.\n   *\n   * Use `getAllByTag` instead if you need to query all documents with a\n   * specific tag.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByTag(\"food\");\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tag - The tag that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents with the tag.\n   */\n  async getByTag(tag, params) {\n    return await this.get(appendFilters(params, someTagsFilter(tag)));\n  }\n  /**\n   * Queries all documents from the Prismic repository with a specific tag.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getAllByTag(\"food\");\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tag - The tag that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of all documents with the tag.\n   */\n  async getAllByTag(tag, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, someTagsFilter(tag)));\n  }\n  /**\n   * Queries documents from the Prismic repository with specific tags. A\n   * document must be tagged with all of the queried tags to be included.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tags - A list of tags that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents with the tags.\n   */\n  async getByEveryTag(tags, params) {\n    return await this.get(appendFilters(params, everyTagFilter(tags)));\n  }\n  /**\n   * Queries documents from the Prismic repository with specific tags. A\n   * document must be tagged with all of the queried tags to be included.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tags - A list of tags that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of all documents with the tags.\n   */\n  async getAllByEveryTag(tags, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, everyTagFilter(tags)));\n  }\n  /**\n   * Queries documents from the Prismic repository with specific tags. A\n   * document must be tagged with at least one of the queried tags to be\n   * included.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tags - A list of tags that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents with at least one of the\n   *   tags.\n   */\n  async getBySomeTags(tags, params) {\n    return await this.get(appendFilters(params, someTagsFilter(tags)));\n  }\n  /**\n   * Queries documents from the Prismic repository with specific tags. A\n   * document must be tagged with at least one of the queried tags to be\n   * included.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getAllBySomeTags([\"food\", \"fruit\"]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tags - A list of tags that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of all documents with at least one of the tags.\n   */\n  async getAllBySomeTags(tags, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, someTagsFilter(tags)));\n  }\n  /**\n   * Returns metadata about the Prismic repository, such as its refs, releases,\n   * and custom types.\n   *\n   * @returns Repository metadata.\n   */\n  async getRepository(params) {\n    const url = new URL(this.endpoint);\n    if (this.accessToken) {\n      url.searchParams.set(\"access_token\", this.accessToken);\n    }\n    return await this.fetch(url.toString(), params);\n  }\n  /**\n   * Returns a list of all refs for the Prismic repository.\n   *\n   * Refs are used to identify which version of the repository's content should\n   * be queried. All repositories will have at least one ref pointing to the\n   * latest published content called the \"master ref\".\n   *\n   * @returns A list of all refs for the Prismic repository.\n   */\n  async getRefs(params) {\n    const repository = await this.getRepository(params);\n    return repository.refs;\n  }\n  /**\n   * Returns a ref for the Prismic repository with a matching ID.\n   *\n   * @param id - ID of the ref.\n   *\n   * @returns The ref with a matching ID, if it exists.\n   */\n  async getRefByID(id, params) {\n    const refs = await this.getRefs(params);\n    return findRefByID(refs, id);\n  }\n  /**\n   * Returns a ref for the Prismic repository with a matching label.\n   *\n   * @param label - Label of the ref.\n   *\n   * @returns The ref with a matching label, if it exists.\n   */\n  async getRefByLabel(label, params) {\n    const refs = await this.getRefs(params);\n    return findRefByLabel(refs, label);\n  }\n  /**\n   * Returns the master ref for the Prismic repository. The master ref points to\n   * the repository's latest published content.\n   *\n   * @returns The repository's master ref.\n   */\n  async getMasterRef(params) {\n    const refs = await this.getRefs(params);\n    return findMasterRef(refs);\n  }\n  /**\n   * Returns a list of all Releases for the Prismic repository. Releases are\n   * used to group content changes before publishing.\n   *\n   * @returns A list of all Releases for the Prismic repository.\n   */\n  async getReleases(params) {\n    const refs = await this.getRefs(params);\n    return refs.filter((ref) => !ref.isMasterRef);\n  }\n  /**\n   * Returns a Release for the Prismic repository with a matching ID.\n   *\n   * @param id - ID of the Release.\n   *\n   * @returns The Release with a matching ID, if it exists.\n   */\n  async getReleaseByID(id, params) {\n    const releases = await this.getReleases(params);\n    return findRefByID(releases, id);\n  }\n  /**\n   * Returns a Release for the Prismic repository with a matching label.\n   *\n   * @param label - Label of the ref.\n   *\n   * @returns The ref with a matching label, if it exists.\n   */\n  async getReleaseByLabel(label, params) {\n    const releases = await this.getReleases(params);\n    return findRefByLabel(releases, label);\n  }\n  /**\n   * Returns a list of all tags used in the Prismic repository.\n   *\n   * @returns A list of all tags used in the repository.\n   */\n  async getTags(params) {\n    try {\n      const tagsForm = await this.getCachedRepositoryForm(\"tags\", params);\n      const url = new URL(tagsForm.action);\n      if (this.accessToken) {\n        url.searchParams.set(\"access_token\", this.accessToken);\n      }\n      return await this.fetch(url.toString(), params);\n    } catch {\n      const repository = await this.getRepository(params);\n      return repository.tags;\n    }\n  }\n  /**\n   * Builds a URL used to query content from the Prismic repository.\n   *\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A URL string that can be requested to query content.\n   */\n  async buildQueryURL({ signal, fetchOptions, ...params } = {}) {\n    const ref = params.ref || await this.getResolvedRefString({ signal, fetchOptions });\n    const integrationFieldsRef = params.integrationFieldsRef || (await this.getCachedRepository({ signal, fetchOptions })).integrationFieldsRef || void 0;\n    return buildQueryURL(this.endpoint, {\n      ...this.defaultParams,\n      ...params,\n      ref,\n      integrationFieldsRef,\n      routes: params.routes || this.routes,\n      brokenRoute: params.brokenRoute || this.brokenRoute,\n      accessToken: params.accessToken || this.accessToken\n    });\n  }\n  /**\n   * Determines the URL for a previewed document during an active preview\n   * session. The result of this method should be used to redirect the user to\n   * the document's URL.\n   *\n   * @example\n   *\n   * ```ts\n   * \tconst url = client.resolvePreviewURL({\n   * \tlinkResolver: (document) => `/${document.uid}`\n   * \tdefaultURL: '/'\n   * \t})\n   * ```\n   *\n   * @param args - Arguments to configure the URL resolving.\n   *\n   * @returns The URL for the previewed document during an active preview\n   *   session. The user should be redirected to this URL.\n   */\n  async resolvePreviewURL(args) {\n    var _a, _b;\n    let documentID = args.documentID;\n    let previewToken = args.previewToken;\n    if (typeof globalThis.location !== \"undefined\") {\n      const searchParams = new URLSearchParams(globalThis.location.search);\n      documentID = documentID || searchParams.get(\"documentId\");\n      previewToken = previewToken || searchParams.get(\"token\");\n    } else if (this.refState.httpRequest) {\n      if (\"query\" in this.refState.httpRequest) {\n        documentID = documentID || ((_a = this.refState.httpRequest.query) == null ? void 0 : _a.documentId);\n        previewToken = previewToken || ((_b = this.refState.httpRequest.query) == null ? void 0 : _b.token);\n      } else if (\"url\" in this.refState.httpRequest && this.refState.httpRequest.url) {\n        const searchParams = new URL(this.refState.httpRequest.url, \"missing-host://\").searchParams;\n        documentID = documentID || searchParams.get(\"documentId\");\n        previewToken = previewToken || searchParams.get(\"token\");\n      }\n    }\n    if (documentID != null && previewToken != null) {\n      const document = await this.getByID(documentID, {\n        ref: previewToken,\n        lang: \"*\",\n        signal: args.signal,\n        fetchOptions: args.fetchOptions\n      });\n      const url = asLink(document, { linkResolver: args.linkResolver });\n      if (typeof url === \"string\") {\n        return url;\n      }\n    }\n    return args.defaultURL;\n  }\n  /**\n   * Configures the client to query the latest published content for all future\n   * queries.\n   *\n   * If the `ref` parameter is provided during a query, it takes priority for\n   * that query.\n   *\n   * @example\n   *\n   * ```ts\n   * await client.queryLatestContent();\n   * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n   * ```\n   */\n  queryLatestContent() {\n    this.refState.mode = RefStateMode.Master;\n  }\n  /**\n   * Configures the client to query content from a specific Release identified\n   * by its ID for all future queries.\n   *\n   * If the `ref` parameter is provided during a query, it takes priority for\n   * that query.\n   *\n   * @example\n   *\n   * ```ts\n   * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\");\n   * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n   * ```\n   *\n   * @param releaseID - The ID of the Release.\n   */\n  queryContentFromReleaseByID(releaseID) {\n    this.refState = {\n      ...this.refState,\n      mode: RefStateMode.ReleaseID,\n      releaseID\n    };\n  }\n  /**\n   * Configures the client to query content from a specific Release identified\n   * by its label for all future queries.\n   *\n   * If the `ref` parameter is provided during a query, it takes priority for\n   * that query.\n   *\n   * @example\n   *\n   * ```ts\n   * await client.queryContentFromReleaseByLabel(\"My Release\");\n   * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n   * ```\n   *\n   * @param releaseLabel - The label of the Release.\n   */\n  queryContentFromReleaseByLabel(releaseLabel) {\n    this.refState = {\n      ...this.refState,\n      mode: RefStateMode.ReleaseLabel,\n      releaseLabel\n    };\n  }\n  /**\n   * Configures the client to query content from a specific ref. The ref can be\n   * provided as a string or a function.\n   *\n   * If a function is provided, the ref is fetched lazily before each query. The\n   * function may also be asynchronous.\n   *\n   * @example\n   *\n   * ```ts\n   * await client.queryContentFromRef(\"my-ref\");\n   * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n   * ```\n   *\n   * @param ref - The ref or a function that returns the ref from which to query\n   *   content.\n   */\n  queryContentFromRef(ref) {\n    this.refState = {\n      ...this.refState,\n      mode: RefStateMode.Manual,\n      ref\n    };\n  }\n  /**\n   * A `fetch()` function to be used with GraphQL clients configured for\n   * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n   * and Authorization headers. Queries will automatically be minified by\n   * removing whitespace where possible.\n   *\n   * @example\n   *\n   * ```ts\n   * const graphQLClient = new ApolloClient({\n   * \tlink: new HttpLink({\n   * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n   * \t\t// Provide `client.graphQLFetch` as the fetch implementation.\n   * \t\tfetch: client.graphQLFetch,\n   * \t\t// Using GET is required.\n   * \t\tuseGETForQueries: true,\n   * \t}),\n   * \tcache: new InMemoryCache(),\n   * });\n   * ```\n   *\n   * @param input - The `fetch()` `input` parameter. Only strings are supported.\n   * @param init - The `fetch()` `init` parameter. Only plain objects are\n   *   supported.\n   *\n   * @returns The `fetch()` Response for the request.\n   *\n   * @experimental\n   */\n  async graphQLFetch(input, init) {\n    const cachedRepository = await this.getCachedRepository();\n    const ref = await this.getResolvedRefString();\n    const unsanitizedHeaders = {\n      \"Prismic-ref\": ref,\n      Authorization: this.accessToken ? `Token ${this.accessToken}` : \"\",\n      // Asserting `init.headers` is a Record since popular GraphQL\n      // libraries pass this as a Record. Header objects as input\n      // are unsupported.\n      ...init ? init.headers : {}\n    };\n    if (cachedRepository.integrationFieldsRef) {\n      unsanitizedHeaders[\"Prismic-integration-field-ref\"] = cachedRepository.integrationFieldsRef;\n    }\n    const headers = {};\n    for (const key in unsanitizedHeaders) {\n      if (unsanitizedHeaders[key]) {\n        headers[key.toLowerCase()] = unsanitizedHeaders[key];\n      }\n    }\n    const url = new URL(\n      // Asserting `input` is a string since popular GraphQL\n      // libraries pass this as a string. Request objects as\n      // input are unsupported.\n      input\n    );\n    url.searchParams.set(\"ref\", ref);\n    const query = url.searchParams.get(\"query\");\n    if (query) {\n      url.searchParams.set(\n        \"query\",\n        // Compress the GraphQL query (if it exists) by\n        // removing whitespace. This is done to\n        // optimize the query size and avoid\n        // hitting the upper limit of GET requests\n        // (2048 characters).\n        minifyGraphQLQuery(query)\n      );\n    }\n    return await this.fetchFn(url.toString(), {\n      ...init,\n      headers\n    });\n  }\n  /**\n   * Returns a cached version of `getRepository` with a TTL.\n   *\n   * @returns Cached repository metadata.\n   */\n  async getCachedRepository(params) {\n    if (!this.cachedRepository || Date.now() >= this.cachedRepositoryExpiration) {\n      this.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;\n      this.cachedRepository = await this.getRepository(params);\n    }\n    return this.cachedRepository;\n  }\n  /**\n   * Returns a cached Prismic repository form. Forms are used to determine API\n   * endpoints for types of repository data.\n   *\n   * @param name - Name of the form.\n   *\n   * @returns The repository form.\n   *\n   * @throws If a matching form cannot be found.\n   */\n  async getCachedRepositoryForm(name, params) {\n    const cachedRepository = await this.getCachedRepository(params);\n    const form = cachedRepository.forms[name];\n    if (!form) {\n      throw new PrismicError(`Form with name \"${name}\" could not be found`, void 0, void 0);\n    }\n    return form;\n  }\n  /**\n   * Returns the ref needed to query based on the client's current state. This\n   * method may make a network request to fetch a ref or resolve the user's ref\n   * thunk.\n   *\n   * If auto previews are enabled, the preview ref takes priority if available.\n   *\n   * The following strategies are used depending on the client's state:\n   *\n   * - If the user called `queryLatestContent`: Use the repository's master ref.\n   *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is\n   *   fetched.\n   * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n   *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n   *   release is fetched.\n   * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n   *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n   *   release is fetched.\n   * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n   *   to the master ref if the ref is not a string.\n   *\n   * @returns The ref to use during a query.\n   */\n  async getResolvedRefString(params) {\n    var _a, _b;\n    if (this.refState.autoPreviewsEnabled) {\n      let previewRef;\n      let cookieJar;\n      if ((_a = this.refState.httpRequest) == null ? void 0 : _a.headers) {\n        if (\"get\" in this.refState.httpRequest.headers && typeof this.refState.httpRequest.headers.get === \"function\") {\n          cookieJar = this.refState.httpRequest.headers.get(\"cookie\");\n        } else if (\"cookie\" in this.refState.httpRequest.headers) {\n          cookieJar = this.refState.httpRequest.headers.cookie;\n        }\n      } else if ((_b = globalThis.document) == null ? void 0 : _b.cookie) {\n        cookieJar = globalThis.document.cookie;\n      }\n      if (cookieJar) {\n        previewRef = getPreviewCookie(cookieJar);\n      }\n      if (previewRef) {\n        return previewRef;\n      }\n    }\n    const cachedRepository = await this.getCachedRepository(params);\n    const refModeType = this.refState.mode;\n    if (refModeType === RefStateMode.ReleaseID) {\n      return findRefByID(cachedRepository.refs, this.refState.releaseID).ref;\n    } else if (refModeType === RefStateMode.ReleaseLabel) {\n      return findRefByLabel(cachedRepository.refs, this.refState.releaseLabel).ref;\n    } else if (refModeType === RefStateMode.Manual) {\n      const res = await castThunk(this.refState.ref)();\n      if (typeof res === \"string\") {\n        return res;\n      }\n    }\n    return findMasterRef(cachedRepository.refs).ref;\n  }\n  /**\n   * Performs a network request using the configured `fetch` function. It\n   * assumes all successful responses will have a JSON content type. It also\n   * normalizes unsuccessful network requests.\n   *\n   * @typeParam T - The JSON response.\n   *\n   * @param url - URL to the resource to fetch.\n   * @param params - Prismic REST API parameters for the network request.\n   *\n   * @returns The JSON response from the network request.\n   */\n  async fetch(url, params = {}) {\n    var _a, _b, _c, _d;\n    const requestInit = {\n      ...this.fetchOptions,\n      ...params.fetchOptions,\n      headers: {\n        ...(_a = this.fetchOptions) == null ? void 0 : _a.headers,\n        ...(_b = params.fetchOptions) == null ? void 0 : _b.headers\n      },\n      signal: ((_c = params.fetchOptions) == null ? void 0 : _c.signal) || params.signal || ((_d = this.fetchOptions) == null ? void 0 : _d.signal)\n    };\n    let job;\n    if (this.fetchJobs[url] && this.fetchJobs[url].has(requestInit.signal)) {\n      job = this.fetchJobs[url].get(requestInit.signal);\n    } else {\n      this.fetchJobs[url] = this.fetchJobs[url] || /* @__PURE__ */ new Map();\n      job = this.fetchFn(url, requestInit).then(async (res2) => {\n        let json = void 0;\n        try {\n          json = await res2.json();\n        } catch {\n        }\n        return {\n          status: res2.status,\n          headers: res2.headers,\n          json\n        };\n      }).finally(() => {\n        this.fetchJobs[url].delete(requestInit.signal);\n        if (this.fetchJobs[url].size === 0) {\n          delete this.fetchJobs[url];\n        }\n      });\n      this.fetchJobs[url].set(requestInit.signal, job);\n    }\n    const res = await job;\n    if (res.status !== 404 && res.json == null) {\n      throw new PrismicError(void 0, url, res.json);\n    }\n    switch (res.status) {\n      case 200: {\n        return res.json;\n      }\n      case 400: {\n        throw new ParsingError(res.json.message, url, res.json);\n      }\n      case 401:\n      case 403: {\n        throw new ForbiddenError(res.json.error || res.json.message, url, res.json);\n      }\n      case 404: {\n        if (res.json === void 0) {\n          throw new RepositoryNotFoundError(`Prismic repository not found. Check that \"${this.endpoint}\" is pointing to the correct repository.`, url, void 0);\n        }\n        if (res.json.type === \"api_notfound_error\") {\n          throw new RefNotFoundError(res.json.message, url, res.json);\n        }\n        if (res.json.type === \"api_security_error\" && /preview token.*expired/i.test(res.json.message)) {\n          throw new PreviewTokenExpiredError(res.json.message, url, res.json);\n        }\n        throw new NotFoundError(res.json.message, url, res.json);\n      }\n      case 410: {\n        throw new RefExpiredError(res.json.message, url, res.json);\n      }\n      case 429: {\n        const parsedRetryAfter = Number(res.headers.get(\"retry-after\"));\n        const delay = Number.isNaN(parsedRetryAfter) ? DEFUALT_RETRY_AFTER_MS : parsedRetryAfter;\n        return await new Promise((resolve, reject) => {\n          setTimeout(async () => {\n            try {\n              resolve(await this.fetch(url, params));\n            } catch (error) {\n              reject(error);\n            }\n          }, delay);\n        });\n      }\n    }\n    throw new PrismicError(void 0, url, res.json);\n  }\n}\nexport {\n  Client,\n  GET_ALL_QUERY_DELAY,\n  REPOSITORY_CACHE_TTL,\n  createClient\n};\n//# sourceMappingURL=createClient.js.map\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}