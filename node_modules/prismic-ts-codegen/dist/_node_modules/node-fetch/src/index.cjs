"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const http = require("node:http");
const https = require("node:https");
const zlib = require("node:zlib");
const Stream = require("node:stream");
const node_buffer = require("node:buffer");
const index$1 = require("../../data-uri-to-buffer/dist/index.cjs");
const body = require("./body.cjs");
const response = require("./response.cjs");
const headers = require("./headers.cjs");
const request = require("./request.cjs");
const fetchError = require("./errors/fetch-error.cjs");
const abortError = require("./errors/abort-error.cjs");
const isRedirect = require("./utils/is-redirect.cjs");
const index = require("../../fetch-blob/index.cjs");
const is = require("./utils/is.cjs");
const referrer = require("./utils/referrer.cjs");
require("node:fs");
require("node:path");
require("../../node-domexception/index.cjs");
const supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
async function fetch(url, options_) {
  return new Promise((resolve, reject) => {
    const request$1 = new request.default(url, options_);
    const { parsedURL, options } = request.getNodeRequestOptions(request$1);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = index$1.dataUriToBuffer(request$1.url);
      const response$12 = new response(data, { headers: { "Content-Type": data.typeFull } });
      resolve(response$12);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? https : http).request;
    const { signal } = request$1;
    let response$1 = null;
    const abort = () => {
      const error = new abortError.AbortError("The operation was aborted.");
      reject(error);
      if (request$1.body && request$1.body instanceof Stream.Readable) {
        request$1.body.destroy(error);
      }
      if (!response$1 || !response$1.body) {
        return;
      }
      response$1.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error) => {
      reject(new fetchError.FetchError(`request to ${request$1.url} failed, reason: ${error.message}`, "system", error));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error) => {
      if (response$1 && response$1.body) {
        response$1.body.destroy(error);
      }
    });
    if (process.version < "v14") {
      request_.on("socket", (s) => {
        let endedWithEventsCount;
        s.prependListener("end", () => {
          endedWithEventsCount = s._eventsCount;
        });
        s.prependListener("close", (hadError) => {
          if (response$1 && endedWithEventsCount < s._eventsCount && !hadError) {
            const error = new Error("Premature close");
            error.code = "ERR_STREAM_PREMATURE_CLOSE";
            response$1.body.emit("error", error);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers$1 = headers.fromRawHeaders(response_.rawHeaders);
      if (isRedirect.isRedirect(response_.statusCode)) {
        const location = headers$1.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request$1.url);
        } catch {
          if (request$1.redirect !== "manual") {
            reject(new fetchError.FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request$1.redirect) {
          case "error":
            reject(new fetchError.FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request$1.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request$1.counter >= request$1.follow) {
              reject(new fetchError.FetchError(`maximum redirect reached at: ${request$1.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new headers.default(request$1.headers),
              follow: request$1.follow,
              counter: request$1.counter + 1,
              agent: request$1.agent,
              compress: request$1.compress,
              method: request$1.method,
              body: body.clone(request$1),
              signal: request$1.signal,
              size: request$1.size,
              referrer: request$1.referrer,
              referrerPolicy: request$1.referrerPolicy
            };
            if (!is.isDomainOrSubdomain(request$1.url, locationURL) || !is.isSameProtocol(request$1.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request$1.body && options_.body instanceof Stream.Readable) {
              reject(new fetchError.FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request$1.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = referrer.parseReferrerPolicyFromHeader(headers$1);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve(fetch(new request.default(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request$1.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body$1 = Stream.pipeline(response_, new Stream.PassThrough(), (error) => {
        if (error) {
          reject(error);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request$1.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers: headers$1,
        size: request$1.size,
        counter: request$1.counter,
        highWaterMark: request$1.highWaterMark
      };
      const codings = headers$1.get("Content-Encoding");
      if (!request$1.compress || request$1.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response$1 = new response(body$1, responseOptions);
        resolve(response$1);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body$1 = Stream.pipeline(body$1, zlib.createGunzip(zlibOptions), (error) => {
          if (error) {
            reject(error);
          }
        });
        response$1 = new response(body$1, responseOptions);
        resolve(response$1);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = Stream.pipeline(response_, new Stream.PassThrough(), (error) => {
          if (error) {
            reject(error);
          }
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body$1 = Stream.pipeline(body$1, zlib.createInflate(), (error) => {
              if (error) {
                reject(error);
              }
            });
          } else {
            body$1 = Stream.pipeline(body$1, zlib.createInflateRaw(), (error) => {
              if (error) {
                reject(error);
              }
            });
          }
          response$1 = new response(body$1, responseOptions);
          resolve(response$1);
        });
        raw.once("end", () => {
          if (!response$1) {
            response$1 = new response(body$1, responseOptions);
            resolve(response$1);
          }
        });
        return;
      }
      if (codings === "br") {
        body$1 = Stream.pipeline(body$1, zlib.createBrotliDecompress(), (error) => {
          if (error) {
            reject(error);
          }
        });
        response$1 = new response(body$1, responseOptions);
        resolve(response$1);
        return;
      }
      response$1 = new response(body$1, responseOptions);
      resolve(response$1);
    });
    body.writeToStream(request_, request$1).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request2, errorCallback) {
  const LAST_CHUNK = node_buffer.Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request2.on("response", (response2) => {
    const { headers: headers2 } = response2;
    isChunkedTransfer = headers2["transfer-encoding"] === "chunked" && !headers2["content-length"];
  });
  request2.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error);
      }
    };
    const onData = (buf) => {
      properLastChunkReceived = node_buffer.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = node_buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && node_buffer.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    request2.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  });
}
exports.Response = response;
exports.Headers = headers.default;
exports.Request = request.default;
exports.FetchError = fetchError.FetchError;
exports.AbortError = abortError.AbortError;
exports.isRedirect = isRedirect.isRedirect;
exports.Blob = index.default;
exports.default = fetch;
//# sourceMappingURL=index.cjs.map
