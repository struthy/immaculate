import { p as parseUrl$1 } from "./parse-url.js";
const parseUrl = parseUrl$1;
const isGitHubShorthand = (arg) => {
  const firstHash = arg.indexOf("#");
  const firstSlash = arg.indexOf("/");
  const secondSlash = arg.indexOf("/", firstSlash + 1);
  const firstColon = arg.indexOf(":");
  const firstSpace = /\s/.exec(arg);
  const firstAt = arg.indexOf("@");
  const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;
  const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;
  const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;
  const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;
  const hasSlash = firstSlash > 0;
  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== "/" : !arg.endsWith("/");
  const doesNotStartWithDot = !arg.startsWith(".");
  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;
};
var fromUrl = (giturl, opts, { gitHosts, protocols }) => {
  var _a, _b;
  if (!giturl) {
    return;
  }
  const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl;
  const parsed = parseUrl(correctedUrl, protocols);
  if (!parsed) {
    return;
  }
  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith("www.") ? parsed.hostname.slice(4) : parsed.hostname];
  const gitHostName = gitHostShortcut || gitHostDomain;
  if (!gitHostName) {
    return;
  }
  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];
  let auth = null;
  if (((_a = protocols[parsed.protocol]) == null ? void 0 : _a.auth) && (parsed.username || parsed.password)) {
    auth = `${parsed.username}${parsed.password ? ":" + parsed.password : ""}`;
  }
  let committish = null;
  let user = null;
  let project = null;
  let defaultRepresentation = null;
  try {
    if (gitHostShortcut) {
      let pathname = parsed.pathname.startsWith("/") ? parsed.pathname.slice(1) : parsed.pathname;
      const firstAt = pathname.indexOf("@");
      if (firstAt > -1) {
        pathname = pathname.slice(firstAt + 1);
      }
      const lastSlash = pathname.lastIndexOf("/");
      if (lastSlash > -1) {
        user = decodeURIComponent(pathname.slice(0, lastSlash));
        if (!user) {
          user = null;
        }
        project = decodeURIComponent(pathname.slice(lastSlash + 1));
      } else {
        project = decodeURIComponent(pathname);
      }
      if (project.endsWith(".git")) {
        project = project.slice(0, -4);
      }
      if (parsed.hash) {
        committish = decodeURIComponent(parsed.hash.slice(1));
      }
      defaultRepresentation = "shortcut";
    } else {
      if (!gitHostInfo.protocols.includes(parsed.protocol)) {
        return;
      }
      const segments = gitHostInfo.extract(parsed);
      if (!segments) {
        return;
      }
      user = segments.user && decodeURIComponent(segments.user);
      project = decodeURIComponent(segments.project);
      committish = decodeURIComponent(segments.committish);
      defaultRepresentation = ((_b = protocols[parsed.protocol]) == null ? void 0 : _b.name) || parsed.protocol.slice(0, -1);
    }
  } catch (err) {
    if (err instanceof URIError) {
      return;
    } else {
      throw err;
    }
  }
  return [gitHostName, user, auth, project, committish, defaultRepresentation, opts];
};
export {
  fromUrl as f
};
//# sourceMappingURL=from-url.js.map
