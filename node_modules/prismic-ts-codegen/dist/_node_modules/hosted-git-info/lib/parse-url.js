import require$$0 from "url";
const url = require$$0;
const lastIndexOfBefore = (str, char, beforeChar) => {
  const startPosition = str.indexOf(beforeChar);
  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity);
};
const safeUrl = (u) => {
  try {
    return new url.URL(u);
  } catch {
  }
};
const correctProtocol = (arg, protocols) => {
  const firstColon = arg.indexOf(":");
  const proto = arg.slice(0, firstColon + 1);
  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {
    return arg;
  }
  const firstAt = arg.indexOf("@");
  if (firstAt > -1) {
    if (firstAt > firstColon) {
      return `git+ssh://${arg}`;
    } else {
      return arg;
    }
  }
  const doubleSlash = arg.indexOf("//");
  if (doubleSlash === firstColon + 1) {
    return arg;
  }
  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`;
};
const correctUrl = (giturl) => {
  const firstAt = lastIndexOfBefore(giturl, "@", "#");
  const lastColonBeforeHash = lastIndexOfBefore(giturl, ":", "#");
  if (lastColonBeforeHash > firstAt) {
    giturl = giturl.slice(0, lastColonBeforeHash) + "/" + giturl.slice(lastColonBeforeHash + 1);
  }
  if (lastIndexOfBefore(giturl, ":", "#") === -1 && giturl.indexOf("//") === -1) {
    giturl = `git+ssh://${giturl}`;
  }
  return giturl;
};
var parseUrl = (giturl, protocols) => {
  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;
  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol));
};
export {
  parseUrl as p
};
//# sourceMappingURL=parse-url.js.map
