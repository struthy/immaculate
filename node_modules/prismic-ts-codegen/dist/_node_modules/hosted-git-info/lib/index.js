var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _gitHosts, _protocols, _fill, fill_fn;
import { l as lruCache } from "../../lru-cache/index.js";
import { h as hosts_1 } from "./hosts.js";
import { f as fromUrl$1 } from "./from-url.js";
import { p as parseUrl$1 } from "./parse-url.js";
const LRU = lruCache;
const hosts = hosts_1;
const fromUrl = fromUrl$1;
const parseUrl = parseUrl$1;
const cache = new LRU({ max: 1e3 });
const _GitHost = class {
  constructor(type, user, auth, project, committish, defaultRepresentation, opts = {}) {
    __privateAdd(this, _fill);
    Object.assign(this, __privateGet(_GitHost, _gitHosts)[type], {
      type,
      user,
      auth,
      project,
      committish,
      default: defaultRepresentation,
      opts
    });
  }
  static addHost(name, host) {
    __privateGet(_GitHost, _gitHosts)[name] = host;
    __privateGet(_GitHost, _gitHosts).byDomain[host.domain] = name;
    __privateGet(_GitHost, _gitHosts).byShortcut[`${name}:`] = name;
    __privateGet(_GitHost, _protocols)[`${name}:`] = { name };
  }
  static fromUrl(giturl, opts) {
    if (typeof giturl !== "string") {
      return;
    }
    const key = giturl + JSON.stringify(opts || {});
    if (!cache.has(key)) {
      const hostArgs = fromUrl(giturl, opts, {
        gitHosts: __privateGet(_GitHost, _gitHosts),
        protocols: __privateGet(_GitHost, _protocols)
      });
      cache.set(key, hostArgs ? new _GitHost(...hostArgs) : void 0);
    }
    return cache.get(key);
  }
  static parseUrl(url) {
    return parseUrl(url);
  }
  hash() {
    return this.committish ? `#${this.committish}` : "";
  }
  ssh(opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.sshtemplate, opts);
  }
  sshurl(opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.sshurltemplate, opts);
  }
  browse(path, ...args) {
    if (typeof path !== "string") {
      return __privateMethod(this, _fill, fill_fn).call(this, this.browsetemplate, path);
    }
    if (typeof args[0] !== "string") {
      return __privateMethod(this, _fill, fill_fn).call(this, this.browsetreetemplate, { ...args[0], path });
    }
    return __privateMethod(this, _fill, fill_fn).call(this, this.browsetreetemplate, { ...args[1], fragment: args[0], path });
  }
  // If the path is known to be a file, then browseFile should be used. For some hosts
  // the url is the same as browse, but for others like GitHub a file can use both `/tree/`
  // and `/blob/` in the path. When using a default committish of `HEAD` then the `/tree/`
  // path will redirect to a specific commit. Using the `/blob/` path avoids this and
  // does not redirect to a different commit.
  browseFile(path, ...args) {
    if (typeof args[0] !== "string") {
      return __privateMethod(this, _fill, fill_fn).call(this, this.browseblobtemplate, { ...args[0], path });
    }
    return __privateMethod(this, _fill, fill_fn).call(this, this.browseblobtemplate, { ...args[1], fragment: args[0], path });
  }
  docs(opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.docstemplate, opts);
  }
  bugs(opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.bugstemplate, opts);
  }
  https(opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.httpstemplate, opts);
  }
  git(opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.gittemplate, opts);
  }
  shortcut(opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.shortcuttemplate, opts);
  }
  path(opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.pathtemplate, opts);
  }
  tarball(opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.tarballtemplate, { ...opts, noCommittish: false });
  }
  file(path, opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.filetemplate, { ...opts, path });
  }
  edit(path, opts) {
    return __privateMethod(this, _fill, fill_fn).call(this, this.edittemplate, { ...opts, path });
  }
  getDefaultRepresentation() {
    return this.default;
  }
  toString(opts) {
    if (this.default && typeof this[this.default] === "function") {
      return this[this.default](opts);
    }
    return this.sshurl(opts);
  }
};
let GitHost = _GitHost;
_gitHosts = new WeakMap();
_protocols = new WeakMap();
_fill = new WeakSet();
fill_fn = function(template, opts) {
  if (typeof template !== "function") {
    return null;
  }
  const options = { ...this, ...this.opts, ...opts };
  if (!options.path) {
    options.path = "";
  }
  if (options.path.startsWith("/")) {
    options.path = options.path.slice(1);
  }
  if (options.noCommittish) {
    options.committish = null;
  }
  const result = template(options);
  return options.noGitPlus && result.startsWith("git+") ? result.slice(4) : result;
};
__privateAdd(GitHost, _gitHosts, { byShortcut: {}, byDomain: {} });
__privateAdd(GitHost, _protocols, {
  "git+ssh:": { name: "sshurl" },
  "ssh:": { name: "sshurl" },
  "git+https:": { name: "https", auth: true },
  "git:": { auth: true },
  "http:": { auth: true },
  "https:": { auth: true },
  "git+http:": { auth: true }
});
for (const [name, host] of Object.entries(hosts)) {
  GitHost.addHost(name, host);
}
var lib = GitHost;
export {
  lib as l
};
//# sourceMappingURL=index.js.map
