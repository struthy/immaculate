{"version":3,"file":"parse-url.js","sources":["../../../../node_modules/hosted-git-info/lib/parse-url.js"],"sourcesContent":["const url = require('url')\n\nconst lastIndexOfBefore = (str, char, beforeChar) => {\n  const startPosition = str.indexOf(beforeChar)\n  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity)\n}\n\nconst safeUrl = (u) => {\n  try {\n    return new url.URL(u)\n  } catch {\n    // this fn should never throw\n  }\n}\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = (arg, protocols) => {\n  const firstColon = arg.indexOf(':')\n  const proto = arg.slice(0, firstColon + 1)\n  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {\n    return arg\n  }\n\n  const firstAt = arg.indexOf('@')\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`\n    } else {\n      return arg\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//')\n  if (doubleSlash === firstColon + 1) {\n    return arg\n  }\n\n  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`\n}\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = (giturl) => {\n  // ignore @ that come after the first hash since the denotes the start\n  // of a committish which can contain @ characters\n  const firstAt = lastIndexOfBefore(giturl, '@', '#')\n  // ignore colons that come after the hash since that could include colons such as:\n  // git@github.com:user/package-2#semver:^1.0.0\n  const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#')\n\n  if (lastColonBeforeHash > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1)\n  }\n\n  if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    giturl = `git+ssh://${giturl}`\n  }\n\n  return giturl\n}\n\nmodule.exports = (giturl, protocols) => {\n  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl\n  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol))\n}\n"],"names":[],"mappings":";AAAA,MAAM,MAAM;AAEZ,MAAM,oBAAoB,CAAC,KAAK,MAAM,eAAe;AACnD,QAAM,gBAAgB,IAAI,QAAQ,UAAU;AAC5C,SAAO,IAAI,YAAY,MAAM,gBAAgB,KAAK,gBAAgB,QAAQ;AAC5E;AAEA,MAAM,UAAU,CAAC,MAAM;AACrB,MAAI;AACF,WAAO,IAAI,IAAI,IAAI,CAAC;AAAA,EACxB,QAAI;AAAA,EAED;AACH;AAGA,MAAM,kBAAkB,CAAC,KAAK,cAAc;AAC1C,QAAM,aAAa,IAAI,QAAQ,GAAG;AAClC,QAAM,QAAQ,IAAI,MAAM,GAAG,aAAa,CAAC;AACzC,MAAI,OAAO,UAAU,eAAe,KAAK,WAAW,KAAK,GAAG;AAC1D,WAAO;AAAA,EACR;AAED,QAAM,UAAU,IAAI,QAAQ,GAAG;AAC/B,MAAI,UAAU,IAAI;AAChB,QAAI,UAAU,YAAY;AACxB,aAAO,aAAa;AAAA,IAC1B,OAAW;AACL,aAAO;AAAA,IACR;AAAA,EACF;AAED,QAAM,cAAc,IAAI,QAAQ,IAAI;AACpC,MAAI,gBAAgB,aAAa,GAAG;AAClC,WAAO;AAAA,EACR;AAED,SAAO,GAAG,IAAI,MAAM,GAAG,aAAa,CAAC,MAAM,IAAI,MAAM,aAAa,CAAC;AACrE;AAGA,MAAM,aAAa,CAAC,WAAW;AAG7B,QAAM,UAAU,kBAAkB,QAAQ,KAAK,GAAG;AAGlD,QAAM,sBAAsB,kBAAkB,QAAQ,KAAK,GAAG;AAE9D,MAAI,sBAAsB,SAAS;AAWjC,aAAS,OAAO,MAAM,GAAG,mBAAmB,IAAI,MAAM,OAAO,MAAM,sBAAsB,CAAC;AAAA,EAC3F;AAED,MAAI,kBAAkB,QAAQ,KAAK,GAAG,MAAM,MAAM,OAAO,QAAQ,IAAI,MAAM,IAAI;AAK7E,aAAS,aAAa;AAAA,EACvB;AAED,SAAO;AACT;AAEA,IAAA,WAAiB,CAAC,QAAQ,cAAc;AACtC,QAAM,eAAe,YAAY,gBAAgB,QAAQ,SAAS,IAAI;AACtE,SAAO,QAAQ,YAAY,KAAK,QAAQ,WAAW,YAAY,CAAC;AAClE;","x_google_ignoreList":[0]}