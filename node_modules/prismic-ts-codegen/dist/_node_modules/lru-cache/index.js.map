{"version":3,"file":"index.js","sources":["../../../node_modules/lru-cache/index.js"],"sourcesContent":["const perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst hasAbortController = typeof AbortController === 'function'\n\n// minimal backwards-compatibility polyfill\n// this doesn't have nearly all the checks and whatnot that\n// actual AbortController/Signal has, but it's enough for\n// our purposes, and if used properly, behaves the same.\nconst AC = hasAbortController\n  ? AbortController\n  : class AbortController {\n      constructor() {\n        this.signal = new AS()\n      }\n      abort(reason = new Error('This operation was aborted')) {\n        this.signal.reason = this.signal.reason || reason\n        this.signal.aborted = true\n        this.signal.dispatchEvent({\n          type: 'abort',\n          target: this.signal,\n        })\n      }\n    }\n\nconst hasAbortSignal = typeof AbortSignal === 'function'\n// Some polyfills put this on the AC class, not global\nconst hasACAbortSignal = typeof AC.AbortSignal === 'function'\nconst AS = hasAbortSignal\n  ? AbortSignal\n  : hasACAbortSignal\n  ? AC.AbortController\n  : class AbortSignal {\n      constructor() {\n        this.reason = undefined\n        this.aborted = false\n        this._listeners = []\n      }\n      dispatchEvent(e) {\n        if (e.type === 'abort') {\n          this.aborted = true\n          this.onabort(e)\n          this._listeners.forEach(f => f(e), this)\n        }\n      }\n      onabort() {}\n      addEventListener(ev, fn) {\n        if (ev === 'abort') {\n          this._listeners.push(fn)\n        }\n      }\n      removeEventListener(ev, fn) {\n        if (ev === 'abort') {\n          this._listeners = this._listeners.filter(f => f !== fn)\n        }\n      }\n    }\n\nconst warned = new Set()\nconst deprecatedOption = (opt, instead) => {\n  const code = `LRU_CACHE_OPTION_${opt}`\n  if (shouldWarn(code)) {\n    warn(code, `${opt} option`, `options.${instead}`, LRUCache)\n  }\n}\nconst deprecatedMethod = (method, instead) => {\n  const code = `LRU_CACHE_METHOD_${method}`\n  if (shouldWarn(code)) {\n    const { prototype } = LRUCache\n    const { get } = Object.getOwnPropertyDescriptor(prototype, method)\n    warn(code, `${method} method`, `cache.${instead}()`, get)\n  }\n}\nconst deprecatedProperty = (field, instead) => {\n  const code = `LRU_CACHE_PROPERTY_${field}`\n  if (shouldWarn(code)) {\n    const { prototype } = LRUCache\n    const { get } = Object.getOwnPropertyDescriptor(prototype, field)\n    warn(code, `${field} property`, `cache.${instead}`, get)\n  }\n}\n\nconst emitWarning = (...a) => {\n  typeof process === 'object' &&\n  process &&\n  typeof process.emitWarning === 'function'\n    ? process.emitWarning(...a)\n    : console.error(...a)\n}\n\nconst shouldWarn = code => !warned.has(code)\n\nconst warn = (code, what, instead, fn) => {\n  warned.add(code)\n  const msg = `The ${what} is deprecated. Please use ${instead} instead.`\n  emitWarning(msg, 'DeprecationWarning', code, fn)\n}\n\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)\n\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */\nconst getUintArray = max =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size)\n    this.fill(0)\n  }\n}\n\nclass Stack {\n  constructor(max) {\n    if (max === 0) {\n      return []\n    }\n    const UintArray = getUintArray(max)\n    this.heap = new UintArray(max)\n    this.length = 0\n  }\n  push(n) {\n    this.heap[this.length++] = n\n  }\n  pop() {\n    return this.heap[--this.length]\n  }\n}\n\nclass LRUCache {\n  constructor(options = {}) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      fetchContext,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    // deprecated options, don't trigger a warning for getting them if\n    // the thing being passed in is another LRUCache we're copying.\n    const { length, maxAge, stale } =\n      options instanceof LRUCache ? {} : options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.max = max\n    this.maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.maxSize\n    this.sizeCalculation = sizeCalculation || length\n    if (this.sizeCalculation) {\n      if (!this.maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    this.fetchMethod = fetchMethod || null\n    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n\n    this.fetchContext = fetchContext\n    if (!this.fetchMethod && fetchContext !== undefined) {\n      throw new TypeError(\n        'cannot set fetchContext without fetchMethod'\n      )\n    }\n\n    this.keyMap = new Map()\n    this.keyList = new Array(max).fill(null)\n    this.valList = new Array(max).fill(null)\n    this.next = new UintArray(max)\n    this.prev = new UintArray(max)\n    this.head = 0\n    this.tail = 0\n    this.free = new Stack(max)\n    this.initialFill = 1\n    this.size = 0\n\n    if (typeof dispose === 'function') {\n      this.dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.disposeAfter = disposeAfter\n      this.disposed = []\n    } else {\n      this.disposeAfter = null\n      this.disposed = null\n    }\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.maxSize !== 0) {\n        if (!isPosInt(this.maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale || !!stale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || maxAge || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n\n    if (stale) {\n      deprecatedOption('stale', 'allowStale')\n    }\n    if (maxAge) {\n      deprecatedOption('maxAge', 'ttl')\n    }\n    if (length) {\n      deprecatedOption('length', 'sizeCalculation')\n    }\n  }\n\n  getRemainingTTL(key) {\n    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0\n  }\n\n  initializeTTLTracking() {\n    this.ttls = new ZeroArray(this.max)\n    this.starts = new ZeroArray(this.max)\n\n    this.setItemTTL = (index, ttl, start = perf.now()) => {\n      this.starts[index] = ttl !== 0 ? start : 0\n      this.ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.isStale(index)) {\n            this.delete(this.keyList[index])\n          }\n        }, ttl + 1)\n        /* istanbul ignore else - unref() not supported on all platforms */\n        if (t.unref) {\n          t.unref()\n        }\n      }\n    }\n\n    this.updateItemAge = index => {\n      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.statusTTL = (status, index) => {\n      if (status) {\n        status.ttl = this.ttls[index]\n        status.start = this.starts[index]\n        status.now = cachedNow || getNow()\n        status.remainingTTL = status.now + status.ttl - status.start\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        /* istanbul ignore else - not available on all platforms */\n        if (t.unref) {\n          t.unref()\n        }\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      return this.ttls[index] === 0 || this.starts[index] === 0\n        ? Infinity\n        : this.starts[index] +\n            this.ttls[index] -\n            (cachedNow || getNow())\n    }\n\n    this.isStale = index => {\n      return (\n        this.ttls[index] !== 0 &&\n        this.starts[index] !== 0 &&\n        (cachedNow || getNow()) - this.starts[index] >\n          this.ttls[index]\n      )\n    }\n  }\n  updateItemAge(_index) {}\n  statusTTL(_status, _index) {}\n  setItemTTL(_index, _ttl, _start) {}\n  isStale(_index) {\n    return false\n  }\n\n  initializeSizeTracking() {\n    this.calculatedSize = 0\n    this.sizes = new ZeroArray(this.max)\n    this.removeItemSize = index => {\n      this.calculatedSize -= this.sizes[index]\n      this.sizes[index] = 0\n    }\n    this.requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation or size ' +\n              'must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.addItemSize = (index, size, status) => {\n      this.sizes[index] = size\n      if (this.maxSize) {\n        const maxSize = this.maxSize - this.sizes[index]\n        while (this.calculatedSize > maxSize) {\n          this.evict(true)\n        }\n      }\n      this.calculatedSize += this.sizes[index]\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.calculatedSize\n      }\n    }\n  }\n  removeItemSize(_index) {}\n  addItemSize(_index, _size) {}\n  requireSize(_k, _v, size, sizeCalculation) {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n  }\n\n  *indexes({ allowStale = this.allowStale } = {}) {\n    if (this.size) {\n      for (let i = this.tail; true; ) {\n        if (!this.isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.isStale(i)) {\n          yield i\n        }\n        if (i === this.head) {\n          break\n        } else {\n          i = this.prev[i]\n        }\n      }\n    }\n  }\n\n  *rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.size) {\n      for (let i = this.head; true; ) {\n        if (!this.isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.isStale(i)) {\n          yield i\n        }\n        if (i === this.tail) {\n          break\n        } else {\n          i = this.next[i]\n        }\n      }\n    }\n  }\n\n  isValidIndex(index) {\n    return (\n      index !== undefined &&\n      this.keyMap.get(this.keyList[index]) === index\n    )\n  }\n\n  *entries() {\n    for (const i of this.indexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield [this.keyList[i], this.valList[i]]\n      }\n    }\n  }\n  *rentries() {\n    for (const i of this.rindexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield [this.keyList[i], this.valList[i]]\n      }\n    }\n  }\n\n  *keys() {\n    for (const i of this.indexes()) {\n      if (\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.keyList[i]\n      }\n    }\n  }\n  *rkeys() {\n    for (const i of this.rindexes()) {\n      if (\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.keyList[i]\n      }\n    }\n  }\n\n  *values() {\n    for (const i of this.indexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.valList[i]\n      }\n    }\n  }\n  *rvalues() {\n    for (const i of this.rindexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.valList[i]\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  find(fn, getOptions) {\n    for (const i of this.indexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.keyList[i], this)) {\n        return this.get(this.keyList[i], getOptions)\n      }\n    }\n  }\n\n  forEach(fn, thisp = this) {\n    for (const i of this.indexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.keyList[i], this)\n    }\n  }\n\n  rforEach(fn, thisp = this) {\n    for (const i of this.rindexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.keyList[i], this)\n    }\n  }\n\n  get prune() {\n    deprecatedMethod('prune', 'purgeStale')\n    return this.purgeStale\n  }\n\n  purgeStale() {\n    let deleted = false\n    for (const i of this.rindexes({ allowStale: true })) {\n      if (this.isStale(i)) {\n        this.delete(this.keyList[i])\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  dump() {\n    const arr = []\n    for (const i of this.indexes({ allowStale: true })) {\n      const key = this.keyList[i]\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      const entry = { value }\n      if (this.ttls) {\n        entry.ttl = this.ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - this.starts[i]\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.sizes) {\n        entry.size = this.sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  load(arr) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset.\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  dispose(_v, _k, _reason) {}\n\n  set(\n    k,\n    v,\n    {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      status,\n    } = {}\n  ) {\n    size = this.requireSize(k, v, size, sizeCalculation)\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case a background fetch is there already.\n      // in non-async cases, this is a no-op\n      this.delete(k)\n      return this\n    }\n    let index = this.size === 0 ? undefined : this.keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = this.newIndex()\n      this.keyList[index] = k\n      this.valList[index] = v\n      this.keyMap.set(k, index)\n      this.next[this.tail] = index\n      this.prev[index] = this.tail\n      this.tail = index\n      this.size++\n      this.addItemSize(index, size, status)\n      if (status) {\n        status.set = 'add'\n      }\n      noUpdateTTL = false\n    } else {\n      // update\n      this.moveToTail(index)\n      const oldVal = this.valList[index]\n      if (v !== oldVal) {\n        if (this.isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n        } else {\n          if (!noDisposeOnSet) {\n            this.dispose(oldVal, k, 'set')\n            if (this.disposeAfter) {\n              this.disposed.push([oldVal, k, 'set'])\n            }\n          }\n        }\n        this.removeItemSize(index)\n        this.valList[index] = v\n        this.addItemSize(index, size, status)\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n      this.initializeTTLTracking()\n    }\n    if (!noUpdateTTL) {\n      this.setItemTTL(index, ttl, start)\n    }\n    this.statusTTL(status, index)\n    if (this.disposeAfter) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n    return this\n  }\n\n  newIndex() {\n    if (this.size === 0) {\n      return this.tail\n    }\n    if (this.size === this.max && this.max !== 0) {\n      return this.evict(false)\n    }\n    if (this.free.length !== 0) {\n      return this.free.pop()\n    }\n    // initial fill, just keep writing down the list\n    return this.initialFill++\n  }\n\n  pop() {\n    if (this.size) {\n      const val = this.valList[this.head]\n      this.evict(true)\n      return val\n    }\n  }\n\n  evict(free) {\n    const head = this.head\n    const k = this.keyList[head]\n    const v = this.valList[head]\n    if (this.isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else {\n      this.dispose(v, k, 'evict')\n      if (this.disposeAfter) {\n        this.disposed.push([v, k, 'evict'])\n      }\n    }\n    this.removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.keyList[head] = null\n      this.valList[head] = null\n      this.free.push(head)\n    }\n    this.head = this.next[head]\n    this.keyMap.delete(k)\n    this.size--\n    return head\n  }\n\n  has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined) {\n      if (!this.isStale(index)) {\n        if (updateAgeOnHas) {\n          this.updateItemAge(index)\n        }\n        if (status) status.has = 'hit'\n        this.statusTTL(status, index)\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  // like get(), but without any LRU updating or TTL expiration\n  peek(k, { allowStale = this.allowStale } = {}) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined && (allowStale || !this.isStale(index))) {\n      const v = this.valList[index]\n      // either stale and allowed, or forcing a refresh of non-stale value\n      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v\n    }\n  }\n\n  backgroundFetch(k, index, options, context) {\n    const v = index === undefined ? undefined : this.valList[index]\n    if (this.isBackgroundFetch(v)) {\n      return v\n    }\n    const ac = new AC()\n    if (options.signal) {\n      options.signal.addEventListener('abort', () =>\n        ac.abort(options.signal.reason)\n      )\n    }\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n    const cb = (v, updateCache = false) => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      if (this.valList[index] === p) {\n        if (v === undefined) {\n          if (p.__staleWhileFetching) {\n            this.valList[index] = p.__staleWhileFetching\n          } else {\n            this.delete(k)\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n    const eb = er => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n    const fetchFail = er => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      if (this.valList[index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || p.__staleWhileFetching === undefined\n        if (del) {\n          this.delete(k)\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.valList[index] = p.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && p.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return p.__staleWhileFetching\n      } else if (p.__returned === p) {\n        throw er\n      }\n    }\n    const pcall = (res, rej) => {\n      this.fetchMethod(k, v, fetchOpts).then(v => res(v), rej)\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res()\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    p.__abortController = ac\n    p.__staleWhileFetching = v\n    p.__returned = null\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, p, { ...fetchOpts.options, status: undefined })\n      index = this.keyMap.get(k)\n    } else {\n      this.valList[index] = p\n    }\n    return p\n  }\n\n  isBackgroundFetch(p) {\n    return (\n      p &&\n      typeof p === 'object' &&\n      typeof p.then === 'function' &&\n      Object.prototype.hasOwnProperty.call(\n        p,\n        '__staleWhileFetching'\n      ) &&\n      Object.prototype.hasOwnProperty.call(p, '__returned') &&\n      (p.__returned === p || p.__returned === null)\n    )\n  }\n\n  // this takes the union of get() and set() opts, because it does both\n  async fetch(\n    k,\n    {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      fetchContext = this.fetchContext,\n      forceRefresh = false,\n      status,\n      signal,\n    } = {}\n  ) {\n    if (!this.fetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.backgroundFetch(k, index, options, fetchContext)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.valList[index]\n      if (this.isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.moveToTail(index)\n        if (updateAgeOnGet) {\n          this.updateItemAge(index)\n        }\n        this.statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.backgroundFetch(k, index, options, fetchContext)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = hasStale && isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  get(\n    k,\n    {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = {}\n  ) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.valList[index]\n      const fetching = this.isBackgroundFetch(value)\n      this.statusTTL(status, index)\n      if (this.isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k)\n          }\n          if (status) status.returnedStale = allowStale\n          return allowStale ? value : undefined\n        } else {\n          if (status) {\n            status.returnedStale =\n              allowStale && value.__staleWhileFetching !== undefined\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.moveToTail(index)\n        if (updateAgeOnGet) {\n          this.updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  connect(p, n) {\n    this.prev[n] = p\n    this.next[p] = n\n  }\n\n  moveToTail(index) {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.tail) {\n      if (index === this.head) {\n        this.head = this.next[index]\n      } else {\n        this.connect(this.prev[index], this.next[index])\n      }\n      this.connect(this.tail, index)\n      this.tail = index\n    }\n  }\n\n  get del() {\n    deprecatedMethod('del', 'delete')\n    return this.delete\n  }\n\n  delete(k) {\n    let deleted = false\n    if (this.size !== 0) {\n      const index = this.keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.size === 1) {\n          this.clear()\n        } else {\n          this.removeItemSize(index)\n          const v = this.valList[index]\n          if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else {\n            this.dispose(v, k, 'delete')\n            if (this.disposeAfter) {\n              this.disposed.push([v, k, 'delete'])\n            }\n          }\n          this.keyMap.delete(k)\n          this.keyList[index] = null\n          this.valList[index] = null\n          if (index === this.tail) {\n            this.tail = this.prev[index]\n          } else if (index === this.head) {\n            this.head = this.next[index]\n          } else {\n            this.next[this.prev[index]] = this.next[index]\n            this.prev[this.next[index]] = this.prev[index]\n          }\n          this.size--\n          this.free.push(index)\n        }\n      }\n    }\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n    return deleted\n  }\n\n  clear() {\n    for (const index of this.rindexes({ allowStale: true })) {\n      const v = this.valList[index]\n      if (this.isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.keyList[index]\n        this.dispose(v, k, 'delete')\n        if (this.disposeAfter) {\n          this.disposed.push([v, k, 'delete'])\n        }\n      }\n    }\n\n    this.keyMap.clear()\n    this.valList.fill(null)\n    this.keyList.fill(null)\n    if (this.ttls) {\n      this.ttls.fill(0)\n      this.starts.fill(0)\n    }\n    if (this.sizes) {\n      this.sizes.fill(0)\n    }\n    this.head = 0\n    this.tail = 0\n    this.initialFill = 1\n    this.free.length = 0\n    this.calculatedSize = 0\n    this.size = 0\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n  }\n\n  get reset() {\n    deprecatedMethod('reset', 'clear')\n    return this.clear\n  }\n\n  get length() {\n    deprecatedProperty('length', 'size')\n    return this.size\n  }\n\n  static get AbortController() {\n    return AC\n  }\n  static get AbortSignal() {\n    return AS\n  }\n}\n\nmodule.exports = LRUCache\n"],"names":["AbortController","AbortSignal","v"],"mappings":"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","x_google_ignoreList":[0]}