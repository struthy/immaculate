"use strict";
const process = require("node:process");
const index$1 = require("../../yargs-parser/build/lib/index.cjs");
const index$4 = require("../../camelcase-keys/index.cjs");
const index$2 = require("../../trim-newlines/index.cjs");
const index$3 = require("../../redent/index.cjs");
const index = require("../../hard-rejection/index.cjs");
const normalize = require("../../normalize-package-data/lib/normalize.cjs");
const options = require("./options.cjs");
const parser = require("./parser.cjs");
const validate = require("./validate.cjs");
const buildResult = (options2, parserOptions) => {
  const { pkg: package_ } = options2;
  const argv = index$1(options2.argv, parserOptions);
  let help = "";
  if (options2.help) {
    help = index$2.trimNewlines((options2.help || "").replace(/\t+\n*$/, ""));
    if (help.includes("\n")) {
      help = index$3(help, 2);
    }
    help = `
${help}`;
  }
  normalize(package_);
  let { description } = options2;
  if (!description && description !== false) {
    ({ description } = package_);
  }
  description && (description = help ? `
  ${description}
` : `
${description}`);
  help = `${description || ""}${help}
`;
  const showHelp = (code) => {
    console.log(help);
    process.exit(typeof code === "number" ? code : 2);
  };
  const showVersion = () => {
    console.log(typeof options2.version === "string" ? options2.version : package_.version);
    process.exit(0);
  };
  if (argv._.length === 0 && options2.argv.length === 1) {
    if (argv.version === true && options2.autoVersion) {
      showVersion();
    } else if (argv.help === true && options2.autoHelp) {
      showHelp(0);
    }
  }
  const input = argv._;
  delete argv._;
  if (!options2.allowUnknownFlags) {
    validate.checkUnknownFlags(input);
  }
  const flags = index$4(argv, { exclude: ["--", /^\w$/] });
  const unnormalizedFlags = { ...flags };
  validate.validate(flags, options2);
  for (const flagValue of Object.values(options2.flags)) {
    if (Array.isArray(flagValue.aliases)) {
      for (const alias of flagValue.aliases) {
        delete flags[alias];
      }
    }
    delete flags[flagValue.shortFlag];
  }
  validate.checkMissingRequiredFlags(options2.flags, flags, input);
  return {
    input,
    flags,
    unnormalizedFlags,
    pkg: package_,
    help,
    showHelp,
    showVersion
  };
};
const meow = (helpText, options$1 = {}) => {
  const parsedOptions = options.buildOptions(helpText, options$1);
  if (parsedOptions.hardRejection) {
    index();
  }
  const parserOptions = parser.buildParserOptions(parsedOptions);
  const result = buildResult(parsedOptions, parserOptions);
  process.title = result.pkg.bin ? Object.keys(result.pkg.bin).at(0) : result.pkg.name;
  return result;
};
module.exports = meow;
//# sourceMappingURL=index.cjs.map
