{"version":3,"file":"yargs-parser.js","sources":["../../../../../node_modules/yargs-parser/build/lib/yargs-parser.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */\nimport { tokenizeArgString } from './tokenize-arg-string.js';\nimport { DefaultValuesForTypeKey } from './yargs-parser-types.js';\nimport { camelCase, decamelize, looksLikeNumber } from './string-utils.js';\nlet mixin;\nexport class YargsParser {\n    constructor(_mixin) {\n        mixin = _mixin;\n    }\n    parse(argsInput, options) {\n        const opts = Object.assign({\n            alias: undefined,\n            array: undefined,\n            boolean: undefined,\n            config: undefined,\n            configObjects: undefined,\n            configuration: undefined,\n            coerce: undefined,\n            count: undefined,\n            default: undefined,\n            envPrefix: undefined,\n            narg: undefined,\n            normalize: undefined,\n            string: undefined,\n            number: undefined,\n            __: undefined,\n            key: undefined\n        }, options);\n        // allow a string argument to be passed in rather\n        // than an argv array.\n        const args = tokenizeArgString(argsInput);\n        // tokenizeArgString adds extra quotes to args if argsInput is a string\n        // only strip those extra quotes in processValue if argsInput is a string\n        const inputIsString = typeof argsInput === 'string';\n        // aliases might have transitive relationships, normalize this.\n        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n        const configuration = Object.assign({\n            'boolean-negation': true,\n            'camel-case-expansion': true,\n            'combine-arrays': false,\n            'dot-notation': true,\n            'duplicate-arguments-array': true,\n            'flatten-duplicate-arrays': true,\n            'greedy-arrays': true,\n            'halt-at-non-option': false,\n            'nargs-eats-options': false,\n            'negation-prefix': 'no-',\n            'parse-numbers': true,\n            'parse-positional-numbers': true,\n            'populate--': false,\n            'set-placeholder-key': false,\n            'short-option-groups': true,\n            'strip-aliased': false,\n            'strip-dashed': false,\n            'unknown-options-as-args': false\n        }, opts.configuration);\n        const defaults = Object.assign(Object.create(null), opts.default);\n        const configObjects = opts.configObjects || [];\n        const envPrefix = opts.envPrefix;\n        const notFlagsOption = configuration['populate--'];\n        const notFlagsArgv = notFlagsOption ? '--' : '_';\n        const newAliases = Object.create(null);\n        const defaulted = Object.create(null);\n        // allow a i18n handler to be passed in, default to a fake one (util.format).\n        const __ = opts.__ || mixin.format;\n        const flags = {\n            aliases: Object.create(null),\n            arrays: Object.create(null),\n            bools: Object.create(null),\n            strings: Object.create(null),\n            numbers: Object.create(null),\n            counts: Object.create(null),\n            normalize: Object.create(null),\n            configs: Object.create(null),\n            nargs: Object.create(null),\n            coercions: Object.create(null),\n            keys: []\n        };\n        const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {\n            const key = typeof opt === 'object' ? opt.key : opt;\n            // assign to flags[bools|strings|numbers]\n            const assignment = Object.keys(opt).map(function (key) {\n                const arrayFlagKeys = {\n                    boolean: 'bools',\n                    string: 'strings',\n                    number: 'numbers'\n                };\n                return arrayFlagKeys[key];\n            }).filter(Boolean).pop();\n            // assign key to be coerced\n            if (assignment) {\n                flags[assignment][key] = true;\n            }\n            flags.arrays[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {\n            flags.bools[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {\n            flags.strings[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {\n            flags.numbers[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {\n            flags.counts[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {\n            flags.normalize[key] = true;\n            flags.keys.push(key);\n        });\n        if (typeof opts.narg === 'object') {\n            Object.entries(opts.narg).forEach(([key, value]) => {\n                if (typeof value === 'number') {\n                    flags.nargs[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.coerce === 'object') {\n            Object.entries(opts.coerce).forEach(([key, value]) => {\n                if (typeof value === 'function') {\n                    flags.coercions[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.config !== 'undefined') {\n            if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n                ;\n                [].concat(opts.config).filter(Boolean).forEach(function (key) {\n                    flags.configs[key] = true;\n                });\n            }\n            else if (typeof opts.config === 'object') {\n                Object.entries(opts.config).forEach(([key, value]) => {\n                    if (typeof value === 'boolean' || typeof value === 'function') {\n                        flags.configs[key] = value;\n                    }\n                });\n            }\n        }\n        // create a lookup table that takes into account all\n        // combinations of aliases: {f: ['foo'], foo: ['f']}\n        extendAliases(opts.key, aliases, opts.default, flags.arrays);\n        // apply default values to all aliases.\n        Object.keys(defaults).forEach(function (key) {\n            (flags.aliases[key] || []).forEach(function (alias) {\n                defaults[alias] = defaults[key];\n            });\n        });\n        let error = null;\n        checkConfiguration();\n        let notFlags = [];\n        const argv = Object.assign(Object.create(null), { _: [] });\n        // TODO(bcoe): for the first pass at removing object prototype  we didn't\n        // remove all prototypes from objects returned by this API, we might want\n        // to gradually move towards doing so.\n        const argvReturn = {};\n        for (let i = 0; i < args.length; i++) {\n            const arg = args[i];\n            const truncatedArg = arg.replace(/^-{3,}/, '---');\n            let broken;\n            let key;\n            let letters;\n            let m;\n            let next;\n            let value;\n            // any unknown option (except for end-of-options, \"--\")\n            if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {\n                pushPositional(arg);\n                // ---, ---=, ----, etc,\n            }\n            else if (truncatedArg.match(/^---+(=|$)/)) {\n                // options without key name are invalid.\n                pushPositional(arg);\n                continue;\n                // -- separated by =\n            }\n            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {\n                // Using [\\s\\S] instead of . because js doesn't support the\n                // 'dotall' regex modifier. See:\n                // http://stackoverflow.com/a/1068308/13216\n                m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n                // arrays format = '--f=a b c'\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    if (checkAllAliases(m[1], flags.arrays)) {\n                        i = eatArray(i, m[1], args, m[2]);\n                    }\n                    else if (checkAllAliases(m[1], flags.nargs) !== false) {\n                        // nargs format = '--f=monkey washing cat'\n                        i = eatNargs(i, m[1], args, m[2]);\n                    }\n                    else {\n                        setArg(m[1], m[2], true);\n                    }\n                }\n            }\n            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n                m = arg.match(negatedBoolean);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);\n                }\n                // -- separated by space.\n            }\n            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {\n                m = arg.match(/^--?(.+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (checkAllAliases(key, flags.arrays)) {\n                        // array format = '--foo a b c'\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        // nargs format = '--foo a b c'\n                        // should be truthy even if: flags.nargs[key] === 0\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!next.match(/^-/) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n                // dot-notation flag separated by '='.\n            }\n            else if (arg.match(/^-.\\..+=/)) {\n                m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    setArg(m[1], m[2]);\n                }\n                // dot-notation flag separated by space.\n            }\n            else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n                next = args[i + 1];\n                m = arg.match(/^-(.\\..+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (next !== undefined && !next.match(/^-/) &&\n                        !checkAllAliases(key, flags.bools) &&\n                        !checkAllAliases(key, flags.counts)) {\n                        setArg(key, next);\n                        i++;\n                    }\n                    else {\n                        setArg(key, defaultValue(key));\n                    }\n                }\n            }\n            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n                letters = arg.slice(1, -1).split('');\n                broken = false;\n                for (let j = 0; j < letters.length; j++) {\n                    next = arg.slice(j + 2);\n                    if (letters[j + 1] && letters[j + 1] === '=') {\n                        value = arg.slice(j + 3);\n                        key = letters[j];\n                        if (checkAllAliases(key, flags.arrays)) {\n                            // array format = '-f=a b c'\n                            i = eatArray(i, key, args, value);\n                        }\n                        else if (checkAllAliases(key, flags.nargs) !== false) {\n                            // nargs format = '-f=monkey washing cat'\n                            i = eatNargs(i, key, args, value);\n                        }\n                        else {\n                            setArg(key, value);\n                        }\n                        broken = true;\n                        break;\n                    }\n                    if (next === '-') {\n                        setArg(letters[j], next);\n                        continue;\n                    }\n                    // current letter is an alphabetic character and next value is a number\n                    if (/[A-Za-z]/.test(letters[j]) &&\n                        /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) &&\n                        checkAllAliases(next, flags.bools) === false) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    else {\n                        setArg(letters[j], defaultValue(letters[j]));\n                    }\n                }\n                key = arg.slice(-1)[0];\n                if (!broken && key !== '-') {\n                    if (checkAllAliases(key, flags.arrays)) {\n                        // array format = '-f a b c'\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        // nargs format = '-f a b c'\n                        // should be truthy even if: flags.nargs[key] === 0\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n            }\n            else if (arg.match(/^-[0-9]$/) &&\n                arg.match(negative) &&\n                checkAllAliases(arg.slice(1), flags.bools)) {\n                // single-digit boolean alias, e.g: xargs -0\n                key = arg.slice(1);\n                setArg(key, defaultValue(key));\n            }\n            else if (arg === '--') {\n                notFlags = args.slice(i + 1);\n                break;\n            }\n            else if (configuration['halt-at-non-option']) {\n                notFlags = args.slice(i);\n                break;\n            }\n            else {\n                pushPositional(arg);\n            }\n        }\n        // order of precedence:\n        // 1. command line arg\n        // 2. value from env var\n        // 3. value from config file\n        // 4. value from config objects\n        // 5. configured default value\n        applyEnvVars(argv, true); // special case: check env vars that point to config file\n        applyEnvVars(argv, false);\n        setConfig(argv);\n        setConfigObjects();\n        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n        applyCoercions(argv);\n        if (configuration['set-placeholder-key'])\n            setPlaceholderKeys(argv);\n        // for any counts either not in args or without an explicit default, set to 0\n        Object.keys(flags.counts).forEach(function (key) {\n            if (!hasKey(argv, key.split('.')))\n                setArg(key, 0);\n        });\n        // '--' defaults to undefined.\n        if (notFlagsOption && notFlags.length)\n            argv[notFlagsArgv] = [];\n        notFlags.forEach(function (key) {\n            argv[notFlagsArgv].push(key);\n        });\n        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n                delete argv[key];\n            });\n        }\n        if (configuration['strip-aliased']) {\n            ;\n            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n                if (configuration['camel-case-expansion'] && alias.includes('-')) {\n                    delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n                }\n                delete argv[alias];\n            });\n        }\n        // Push argument into positional array, applying numeric coercion:\n        function pushPositional(arg) {\n            const maybeCoercedNumber = maybeCoerceNumber('_', arg);\n            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {\n                argv._.push(maybeCoercedNumber);\n            }\n        }\n        // how many arguments should we consume, based\n        // on the nargs option?\n        function eatNargs(i, key, args, argAfterEqualSign) {\n            let ii;\n            let toEat = checkAllAliases(key, flags.nargs);\n            // NaN has a special meaning for the array type, indicating that one or\n            // more values are expected.\n            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;\n            if (toEat === 0) {\n                if (!isUndefined(argAfterEqualSign)) {\n                    error = Error(__('Argument unexpected for: %s', key));\n                }\n                setArg(key, defaultValue(key));\n                return i;\n            }\n            let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n            if (configuration['nargs-eats-options']) {\n                // classic behavior, yargs eats positional and dash arguments.\n                if (args.length - (i + 1) + available < toEat) {\n                    error = Error(__('Not enough arguments following: %s', key));\n                }\n                available = toEat;\n            }\n            else {\n                // nargs will not consume flag arguments, e.g., -abc, --foo,\n                // and terminates when one is observed.\n                for (ii = i + 1; ii < args.length; ii++) {\n                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))\n                        available++;\n                    else\n                        break;\n                }\n                if (available < toEat)\n                    error = Error(__('Not enough arguments following: %s', key));\n            }\n            let consumed = Math.min(available, toEat);\n            if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n                setArg(key, argAfterEqualSign);\n                consumed--;\n            }\n            for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n                setArg(key, args[ii]);\n            }\n            return (i + consumed);\n        }\n        // if an option is an array, eat all non-hyphenated arguments\n        // following it... YUM!\n        // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n        function eatArray(i, key, args, argAfterEqualSign) {\n            let argsToSet = [];\n            let next = argAfterEqualSign || args[i + 1];\n            // If both array and nargs are configured, enforce the nargs count:\n            const nargsCount = checkAllAliases(key, flags.nargs);\n            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\n                argsToSet.push(true);\n            }\n            else if (isUndefined(next) ||\n                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\n                // for keys without value ==> argsToSet remains an empty []\n                // set user default value, if available\n                if (defaults[key] !== undefined) {\n                    const defVal = defaults[key];\n                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n                }\n            }\n            else {\n                // value in --option=value is eaten as is\n                if (!isUndefined(argAfterEqualSign)) {\n                    argsToSet.push(processValue(key, argAfterEqualSign, true));\n                }\n                for (let ii = i + 1; ii < args.length; ii++) {\n                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||\n                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))\n                        break;\n                    next = args[ii];\n                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))\n                        break;\n                    i = ii;\n                    argsToSet.push(processValue(key, next, inputIsString));\n                }\n            }\n            // If both array and nargs are configured, create an error if less than\n            // nargs positionals were found. NaN has special meaning, indicating\n            // that at least one value is required (more are okay).\n            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||\n                (isNaN(nargsCount) && argsToSet.length === 0))) {\n                error = Error(__('Not enough arguments following: %s', key));\n            }\n            setArg(key, argsToSet);\n            return i;\n        }\n        function setArg(key, val, shouldStripQuotes = inputIsString) {\n            if (/-/.test(key) && configuration['camel-case-expansion']) {\n                const alias = key.split('.').map(function (prop) {\n                    return camelCase(prop);\n                }).join('.');\n                addNewAlias(key, alias);\n            }\n            const value = processValue(key, val, shouldStripQuotes);\n            const splitKey = key.split('.');\n            setKey(argv, splitKey, value);\n            // handle populating aliases of the full key\n            if (flags.aliases[key]) {\n                flags.aliases[key].forEach(function (x) {\n                    const keyProperties = x.split('.');\n                    setKey(argv, keyProperties, value);\n                });\n            }\n            // handle populating aliases of the first element of the dot-notation key\n            if (splitKey.length > 1 && configuration['dot-notation']) {\n                ;\n                (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n                    let keyProperties = x.split('.');\n                    // expand alias with nested objects in key\n                    const a = [].concat(splitKey);\n                    a.shift(); // nuke the old key.\n                    keyProperties = keyProperties.concat(a);\n                    // populate alias only if is not already an alias of the full key\n                    // (already populated above)\n                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {\n                        setKey(argv, keyProperties, value);\n                    }\n                });\n            }\n            // Set normalize getter and setter when key is in 'normalize' but isn't an array\n            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n                const keys = [key].concat(flags.aliases[key] || []);\n                keys.forEach(function (key) {\n                    Object.defineProperty(argvReturn, key, {\n                        enumerable: true,\n                        get() {\n                            return val;\n                        },\n                        set(value) {\n                            val = typeof value === 'string' ? mixin.normalize(value) : value;\n                        }\n                    });\n                });\n            }\n        }\n        function addNewAlias(key, alias) {\n            if (!(flags.aliases[key] && flags.aliases[key].length)) {\n                flags.aliases[key] = [alias];\n                newAliases[alias] = true;\n            }\n            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n                addNewAlias(alias, key);\n            }\n        }\n        function processValue(key, val, shouldStripQuotes) {\n            // strings may be quoted, clean this up as we assign values.\n            if (shouldStripQuotes) {\n                val = stripQuotes(val);\n            }\n            // handle parsing boolean arguments --foo=true --bar false.\n            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n                if (typeof val === 'string')\n                    val = val === 'true';\n            }\n            let value = Array.isArray(val)\n                ? val.map(function (v) { return maybeCoerceNumber(key, v); })\n                : maybeCoerceNumber(key, val);\n            // increment a count given as arg (either no value or value parsed as boolean)\n            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n                value = increment();\n            }\n            // Set normalized value when key is in 'normalize' and in 'arrays'\n            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n                if (Array.isArray(val))\n                    value = val.map((val) => { return mixin.normalize(val); });\n                else\n                    value = mixin.normalize(val);\n            }\n            return value;\n        }\n        function maybeCoerceNumber(key, value) {\n            if (!configuration['parse-positional-numbers'] && key === '_')\n                return value;\n            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));\n                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {\n                    value = Number(value);\n                }\n            }\n            return value;\n        }\n        // set args from config.json file, this should be\n        // applied last so that defaults can be applied.\n        function setConfig(argv) {\n            const configLookup = Object.create(null);\n            // expand defaults/aliases, in-case any happen to reference\n            // the config.json file.\n            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n            Object.keys(flags.configs).forEach(function (configKey) {\n                const configPath = argv[configKey] || configLookup[configKey];\n                if (configPath) {\n                    try {\n                        let config = null;\n                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n                        const resolveConfig = flags.configs[configKey];\n                        if (typeof resolveConfig === 'function') {\n                            try {\n                                config = resolveConfig(resolvedConfigPath);\n                            }\n                            catch (e) {\n                                config = e;\n                            }\n                            if (config instanceof Error) {\n                                error = config;\n                                return;\n                            }\n                        }\n                        else {\n                            config = mixin.require(resolvedConfigPath);\n                        }\n                        setConfigObject(config);\n                    }\n                    catch (ex) {\n                        // Deno will receive a PermissionDenied error if an attempt is\n                        // made to load config without the --allow-read flag:\n                        if (ex.name === 'PermissionDenied')\n                            error = ex;\n                        else if (argv[configKey])\n                            error = Error(__('Invalid JSON config file: %s', configPath));\n                    }\n                }\n            });\n        }\n        // set args from config object.\n        // it recursively checks nested objects.\n        function setConfigObject(config, prev) {\n            Object.keys(config).forEach(function (key) {\n                const value = config[key];\n                const fullKey = prev ? prev + '.' + key : key;\n                // if the value is an inner object and we have dot-notation\n                // enabled, treat inner objects in config the same as\n                // heavily nested dot notations (foo.bar.apple).\n                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n                    // if the value is an object but not an array, check nested object\n                    setConfigObject(value, fullKey);\n                }\n                else {\n                    // setting arguments via CLI takes precedence over\n                    // values within the config file.\n                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\n                        setArg(fullKey, value);\n                    }\n                }\n            });\n        }\n        // set all config objects passed in opts\n        function setConfigObjects() {\n            if (typeof configObjects !== 'undefined') {\n                configObjects.forEach(function (configObject) {\n                    setConfigObject(configObject);\n                });\n            }\n        }\n        function applyEnvVars(argv, configOnly) {\n            if (typeof envPrefix === 'undefined')\n                return;\n            const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n            const env = mixin.env();\n            Object.keys(env).forEach(function (envVar) {\n                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n                    // get array of nested keys and convert them to camel case\n                    const keys = envVar.split('__').map(function (key, i) {\n                        if (i === 0) {\n                            key = key.substring(prefix.length);\n                        }\n                        return camelCase(key);\n                    });\n                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\n                        setArg(keys.join('.'), env[envVar]);\n                    }\n                }\n            });\n        }\n        function applyCoercions(argv) {\n            let coerce;\n            const applied = new Set();\n            Object.keys(argv).forEach(function (key) {\n                if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases\n                    coerce = checkAllAliases(key, flags.coercions);\n                    if (typeof coerce === 'function') {\n                        try {\n                            const value = maybeCoerceNumber(key, coerce(argv[key]));\n                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n                                applied.add(ali);\n                                argv[ali] = value;\n                            });\n                        }\n                        catch (err) {\n                            error = err;\n                        }\n                    }\n                }\n            });\n        }\n        function setPlaceholderKeys(argv) {\n            flags.keys.forEach((key) => {\n                // don't set placeholder keys for dot notation options 'foo.bar'.\n                if (~key.indexOf('.'))\n                    return;\n                if (typeof argv[key] === 'undefined')\n                    argv[key] = undefined;\n            });\n            return argv;\n        }\n        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {\n            Object.keys(defaults).forEach(function (key) {\n                if (!hasKey(obj, key.split('.'))) {\n                    setKey(obj, key.split('.'), defaults[key]);\n                    if (canLog)\n                        defaulted[key] = true;\n                    (aliases[key] || []).forEach(function (x) {\n                        if (hasKey(obj, x.split('.')))\n                            return;\n                        setKey(obj, x.split('.'), defaults[key]);\n                    });\n                }\n            });\n        }\n        function hasKey(obj, keys) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                o = (o[key] || {});\n            });\n            const key = keys[keys.length - 1];\n            if (typeof o !== 'object')\n                return false;\n            else\n                return key in o;\n        }\n        function setKey(obj, keys, value) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                // TODO(bcoe): in the next major version of yargs, switch to\n                // Object.create(null) for dot notation:\n                key = sanitizeKey(key);\n                if (typeof o === 'object' && o[key] === undefined) {\n                    o[key] = {};\n                }\n                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n                    // ensure that o[key] is an array, and that the last item is an empty object.\n                    if (Array.isArray(o[key])) {\n                        o[key].push({});\n                    }\n                    else {\n                        o[key] = [o[key], {}];\n                    }\n                    // we want to update the empty object at the end of the o[key] array, so set o to that object\n                    o = o[key][o[key].length - 1];\n                }\n                else {\n                    o = o[key];\n                }\n            });\n            // TODO(bcoe): in the next major version of yargs, switch to\n            // Object.create(null) for dot notation:\n            const key = sanitizeKey(keys[keys.length - 1]);\n            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n            const isValueArray = Array.isArray(value);\n            let duplicate = configuration['duplicate-arguments-array'];\n            // nargs has higher priority than duplicate\n            if (!duplicate && checkAllAliases(key, flags.nargs)) {\n                duplicate = true;\n                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n                    o[key] = undefined;\n                }\n            }\n            if (value === increment()) {\n                o[key] = increment(o[key]);\n            }\n            else if (Array.isArray(o[key])) {\n                if (duplicate && isTypeArray && isValueArray) {\n                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n                }\n                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n                    o[key] = value;\n                }\n                else {\n                    o[key] = o[key].concat([value]);\n                }\n            }\n            else if (o[key] === undefined && isTypeArray) {\n                o[key] = isValueArray ? value : [value];\n            }\n            else if (duplicate && !(o[key] === undefined ||\n                checkAllAliases(key, flags.counts) ||\n                checkAllAliases(key, flags.bools))) {\n                o[key] = [o[key], value];\n            }\n            else {\n                o[key] = value;\n            }\n        }\n        // extend the aliases list with inferred aliases.\n        function extendAliases(...args) {\n            args.forEach(function (obj) {\n                Object.keys(obj || {}).forEach(function (key) {\n                    // short-circuit if we've already added a key\n                    // to the aliases array, for example it might\n                    // exist in both 'opts.default' and 'opts.key'.\n                    if (flags.aliases[key])\n                        return;\n                    flags.aliases[key] = [].concat(aliases[key] || []);\n                    // For \"--option-name\", also set argv.optionName\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (/-/.test(x) && configuration['camel-case-expansion']) {\n                            const c = camelCase(x);\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    // For \"--optionName\", also set argv['option-name']\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n                            const c = decamelize(x, '-');\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    flags.aliases[key].forEach(function (x) {\n                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n                            return x !== y;\n                        }));\n                    });\n                });\n            });\n        }\n        function checkAllAliases(key, flag) {\n            const toCheck = [].concat(flags.aliases[key] || [], key);\n            const keys = Object.keys(flag);\n            const setAlias = toCheck.find(key => keys.includes(key));\n            return setAlias ? flag[setAlias] : false;\n        }\n        function hasAnyFlag(key) {\n            const flagsKeys = Object.keys(flags);\n            const toCheck = [].concat(flagsKeys.map(k => flags[k]));\n            return toCheck.some(function (flag) {\n                return Array.isArray(flag) ? flag.includes(key) : flag[key];\n            });\n        }\n        function hasFlagsMatching(arg, ...patterns) {\n            const toCheck = [].concat(...patterns);\n            return toCheck.some(function (pattern) {\n                const match = arg.match(pattern);\n                return match && hasAnyFlag(match[1]);\n            });\n        }\n        // based on a simplified version of the short flag group parsing logic\n        function hasAllShortFlags(arg) {\n            // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n                return false;\n            }\n            let hasAllFlags = true;\n            let next;\n            const letters = arg.slice(1).split('');\n            for (let j = 0; j < letters.length; j++) {\n                next = arg.slice(j + 2);\n                if (!hasAnyFlag(letters[j])) {\n                    hasAllFlags = false;\n                    break;\n                }\n                if ((letters[j + 1] && letters[j + 1] === '=') ||\n                    next === '-' ||\n                    (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\n                    (letters[j + 1] && letters[j + 1].match(/\\W/))) {\n                    break;\n                }\n            }\n            return hasAllFlags;\n        }\n        function isUnknownOptionAsArg(arg) {\n            return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n        }\n        function isUnknownOption(arg) {\n            arg = arg.replace(/^-{3,}/, '--');\n            // ignore negative numbers\n            if (arg.match(negative)) {\n                return false;\n            }\n            // if this is a short option group and all of them are configured, it isn't unknown\n            if (hasAllShortFlags(arg)) {\n                return false;\n            }\n            // e.g. '--count=2'\n            const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/;\n            // e.g. '-a' or '--arg'\n            const normalFlag = /^-+([^=]+?)$/;\n            // e.g. '-a-'\n            const flagEndingInHyphen = /^-+([^=]+?)-$/;\n            // e.g. '-abc123'\n            const flagEndingInDigits = /^-+([^=]+?\\d+)$/;\n            // e.g. '-a/usr/local'\n            const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/;\n            // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n        }\n        // make a best effort to pick a default value\n        // for an option based on name and type.\n        function defaultValue(key) {\n            if (!checkAllAliases(key, flags.bools) &&\n                !checkAllAliases(key, flags.counts) &&\n                `${key}` in defaults) {\n                return defaults[key];\n            }\n            else {\n                return defaultForType(guessType(key));\n            }\n        }\n        // return a default value, given the type of a flag.,\n        function defaultForType(type) {\n            const def = {\n                [DefaultValuesForTypeKey.BOOLEAN]: true,\n                [DefaultValuesForTypeKey.STRING]: '',\n                [DefaultValuesForTypeKey.NUMBER]: undefined,\n                [DefaultValuesForTypeKey.ARRAY]: []\n            };\n            return def[type];\n        }\n        // given a flag, enforce a default type.\n        function guessType(key) {\n            let type = DefaultValuesForTypeKey.BOOLEAN;\n            if (checkAllAliases(key, flags.strings))\n                type = DefaultValuesForTypeKey.STRING;\n            else if (checkAllAliases(key, flags.numbers))\n                type = DefaultValuesForTypeKey.NUMBER;\n            else if (checkAllAliases(key, flags.bools))\n                type = DefaultValuesForTypeKey.BOOLEAN;\n            else if (checkAllAliases(key, flags.arrays))\n                type = DefaultValuesForTypeKey.ARRAY;\n            return type;\n        }\n        function isUndefined(num) {\n            return num === undefined;\n        }\n        // check user configuration settings for inconsistencies\n        function checkConfiguration() {\n            // count keys should not be set as array/narg\n            Object.keys(flags.counts).find(key => {\n                if (checkAllAliases(key, flags.arrays)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n                    return true;\n                }\n                else if (checkAllAliases(key, flags.nargs)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n                    return true;\n                }\n                return false;\n            });\n        }\n        return {\n            aliases: Object.assign({}, flags.aliases),\n            argv: Object.assign(argvReturn, argv),\n            configuration: configuration,\n            defaulted: Object.assign({}, defaulted),\n            error: error,\n            newAliases: Object.assign({}, newAliases)\n        };\n    }\n}\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases(aliases) {\n    const aliasArrays = [];\n    const combined = Object.create(null);\n    let change = true;\n    // turn alias lookup hash {key: ['alias1', 'alias2']} into\n    // a simple array ['key', 'alias1', 'alias2']\n    Object.keys(aliases).forEach(function (key) {\n        aliasArrays.push([].concat(aliases[key], key));\n    });\n    // combine arrays until zero changes are\n    // made in an iteration.\n    while (change) {\n        change = false;\n        for (let i = 0; i < aliasArrays.length; i++) {\n            for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n                const intersect = aliasArrays[i].filter(function (v) {\n                    return aliasArrays[ii].indexOf(v) !== -1;\n                });\n                if (intersect.length) {\n                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n                    aliasArrays.splice(ii, 1);\n                    change = true;\n                    break;\n                }\n            }\n        }\n    }\n    // map arrays back to the hash-lookup (de-dupe while\n    // we're at it).\n    aliasArrays.forEach(function (aliasArray) {\n        aliasArray = aliasArray.filter(function (v, i, self) {\n            return self.indexOf(v) === i;\n        });\n        const lastAlias = aliasArray.pop();\n        if (lastAlias !== undefined && typeof lastAlias === 'string') {\n            combined[lastAlias] = aliasArray;\n        }\n    });\n    return combined;\n}\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment(orig) {\n    return orig !== undefined ? orig + 1 : 1;\n}\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey(key) {\n    if (key === '__proto__')\n        return '___proto___';\n    return key;\n}\nfunction stripQuotes(val) {\n    return (typeof val === 'string' &&\n        (val[0] === \"'\" || val[0] === '\"') &&\n        val[val.length - 1] === val[0])\n        ? val.substring(1, val.length - 1)\n        : val;\n}\n"],"names":["key","args","value","val","argv","aliases","defaults"],"mappings":"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","x_google_ignoreList":[0]}