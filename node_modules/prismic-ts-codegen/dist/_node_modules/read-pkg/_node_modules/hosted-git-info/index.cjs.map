{"version":3,"file":"index.cjs","sources":["../../../../../node_modules/read-pkg/node_modules/hosted-git-info/index.js"],"sourcesContent":["'use strict'\nconst url = require('url')\nconst gitHosts = require('./git-host-info.js')\nconst GitHost = module.exports = require('./git-host.js')\nconst LRU = require('lru-cache')\nconst cache = new LRU({ max: 1000 })\n\nconst protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1)\n}\n\nconst authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nconst knownProtocols = Object.keys(gitHosts.byShortcut).concat(['http:', 'https:', 'git:', 'git+ssh:', 'git+https:', 'ssh:'])\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') {\n    return\n  }\n\n  const key = giturl + JSON.stringify(opts || {})\n\n  if (!cache.has(key)) {\n    cache.set(key, fromUrl(giturl, opts))\n  }\n\n  return cache.get(key)\n}\n\nfunction fromUrl (giturl, opts) {\n  if (!giturl) {\n    return\n  }\n\n  const url = isGitHubShorthand(giturl) ? 'github:' + giturl : correctProtocol(giturl)\n  const parsed = parseGitUrl(url)\n  if (!parsed) {\n    return parsed\n  }\n\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol]\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.') ? parsed.hostname.slice(4) : parsed.hostname]\n  const gitHostName = gitHostShortcut || gitHostDomain\n  if (!gitHostName) {\n    return\n  }\n\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain]\n  let auth = null\n  if (authProtocols[parsed.protocol] && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`\n  }\n\n  let committish = null\n  let user = null\n  let project = null\n  let defaultRepresentation = null\n\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname\n      const firstAt = pathname.indexOf('@')\n      // we ignore auth for shortcuts, so just trim it out\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1)\n      }\n\n      const lastSlash = pathname.lastIndexOf('/')\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash))\n        // we want nulls only, never empty strings\n        if (!user) {\n          user = null\n        }\n        project = decodeURIComponent(pathname.slice(lastSlash + 1))\n      } else {\n        project = decodeURIComponent(pathname)\n      }\n\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4)\n      }\n\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1))\n      }\n\n      defaultRepresentation = 'shortcut'\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return\n      }\n\n      const segments = gitHostInfo.extract(parsed)\n      if (!segments) {\n        return\n      }\n\n      user = segments.user && decodeURIComponent(segments.user)\n      project = decodeURIComponent(segments.project)\n      committish = decodeURIComponent(segments.committish)\n      defaultRepresentation = protocolToRepresentation(parsed.protocol)\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return\n    } else {\n      throw err\n    }\n  }\n\n  return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n}\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = (arg) => {\n  const firstColon = arg.indexOf(':')\n  const proto = arg.slice(0, firstColon + 1)\n  if (knownProtocols.includes(proto)) {\n    return arg\n  }\n\n  const firstAt = arg.indexOf('@')\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`\n    } else {\n      return arg\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//')\n  if (doubleSlash === firstColon + 1) {\n    return arg\n  }\n\n  return arg.slice(0, firstColon + 1) + '//' + arg.slice(firstColon + 1)\n}\n\n// look for github shorthand inputs, such as npm/cli\nconst isGitHubShorthand = (arg) => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#')\n  const firstSlash = arg.indexOf('/')\n  const secondSlash = arg.indexOf('/', firstSlash + 1)\n  const firstColon = arg.indexOf(':')\n  const firstSpace = /\\s/.exec(arg)\n  const firstAt = arg.indexOf('@')\n\n  const spaceOnlyAfterHash = !firstSpace || (firstHash > -1 && firstSpace.index > firstHash)\n  const atOnlyAfterHash = firstAt === -1 || (firstHash > -1 && firstAt > firstHash)\n  const colonOnlyAfterHash = firstColon === -1 || (firstHash > -1 && firstColon > firstHash)\n  const secondSlashOnlyAfterHash = secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash)\n  const hasSlash = firstSlash > 0\n  // if a # is found, what we really want to know is that the character immediately before # is not a /\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/')\n  const doesNotStartWithDot = !arg.startsWith('.')\n\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash\n}\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = (giturl) => {\n  const firstAt = giturl.indexOf('@')\n  const lastHash = giturl.lastIndexOf('#')\n  let firstColon = giturl.indexOf(':')\n  let lastColon = giturl.lastIndexOf(':', lastHash > -1 ? lastHash : Infinity)\n\n  let corrected\n  if (lastColon > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    corrected = giturl.slice(0, lastColon) + '/' + giturl.slice(lastColon + 1)\n    // // and we find our new : positions\n    firstColon = corrected.indexOf(':')\n    lastColon = corrected.lastIndexOf(':')\n  }\n\n  if (firstColon === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    corrected = `git+ssh://${corrected}`\n  }\n\n  return corrected\n}\n\n// try to parse the url as its given to us, if that throws\n// then we try to clean the url and parse that result instead\n// THIS FUNCTION SHOULD NEVER THROW\nconst parseGitUrl = (giturl) => {\n  let result\n  try {\n    result = new url.URL(giturl)\n  } catch (err) {}\n\n  if (result) {\n    return result\n  }\n\n  const correctedUrl = correctUrl(giturl)\n  try {\n    result = new url.URL(correctedUrl)\n  } catch (err) {}\n\n  return result\n}\n"],"names":["require$$1","hostedGitInfoModule","require$$2","require$$3","url","gitHostInfo"],"mappings":"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","x_google_ignoreList":[0]}