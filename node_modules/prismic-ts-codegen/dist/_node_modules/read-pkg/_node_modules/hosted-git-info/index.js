import { __module as hostedGitInfo } from "../../../../_virtual/index7.js";
import require$$0 from "url";
import { g as gitHostInfo } from "./git-host-info.js";
import { g as gitHost } from "./git-host.js";
import { l as lruCache } from "../lru-cache/index.js";
const url = require$$0;
const gitHosts = gitHostInfo;
const GitHost = hostedGitInfo.exports = gitHost;
const LRU = lruCache;
const cache = new LRU({ max: 1e3 });
const protocolToRepresentationMap = {
  "git+ssh:": "sshurl",
  "git+https:": "https",
  "ssh:": "sshurl",
  "git:": "git"
};
function protocolToRepresentation(protocol) {
  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);
}
const authProtocols = {
  "git:": true,
  "https:": true,
  "git+https:": true,
  "http:": true,
  "git+http:": true
};
const knownProtocols = Object.keys(gitHosts.byShortcut).concat(["http:", "https:", "git:", "git+ssh:", "git+https:", "ssh:"]);
hostedGitInfo.exports.fromUrl = function(giturl, opts) {
  if (typeof giturl !== "string") {
    return;
  }
  const key = giturl + JSON.stringify(opts || {});
  if (!cache.has(key)) {
    cache.set(key, fromUrl(giturl, opts));
  }
  return cache.get(key);
};
function fromUrl(giturl, opts) {
  if (!giturl) {
    return;
  }
  const url2 = isGitHubShorthand(giturl) ? "github:" + giturl : correctProtocol(giturl);
  const parsed = parseGitUrl(url2);
  if (!parsed) {
    return parsed;
  }
  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith("www.") ? parsed.hostname.slice(4) : parsed.hostname];
  const gitHostName = gitHostShortcut || gitHostDomain;
  if (!gitHostName) {
    return;
  }
  const gitHostInfo2 = gitHosts[gitHostShortcut || gitHostDomain];
  let auth = null;
  if (authProtocols[parsed.protocol] && (parsed.username || parsed.password)) {
    auth = `${parsed.username}${parsed.password ? ":" + parsed.password : ""}`;
  }
  let committish = null;
  let user = null;
  let project = null;
  let defaultRepresentation = null;
  try {
    if (gitHostShortcut) {
      let pathname = parsed.pathname.startsWith("/") ? parsed.pathname.slice(1) : parsed.pathname;
      const firstAt = pathname.indexOf("@");
      if (firstAt > -1) {
        pathname = pathname.slice(firstAt + 1);
      }
      const lastSlash = pathname.lastIndexOf("/");
      if (lastSlash > -1) {
        user = decodeURIComponent(pathname.slice(0, lastSlash));
        if (!user) {
          user = null;
        }
        project = decodeURIComponent(pathname.slice(lastSlash + 1));
      } else {
        project = decodeURIComponent(pathname);
      }
      if (project.endsWith(".git")) {
        project = project.slice(0, -4);
      }
      if (parsed.hash) {
        committish = decodeURIComponent(parsed.hash.slice(1));
      }
      defaultRepresentation = "shortcut";
    } else {
      if (!gitHostInfo2.protocols.includes(parsed.protocol)) {
        return;
      }
      const segments = gitHostInfo2.extract(parsed);
      if (!segments) {
        return;
      }
      user = segments.user && decodeURIComponent(segments.user);
      project = decodeURIComponent(segments.project);
      committish = decodeURIComponent(segments.committish);
      defaultRepresentation = protocolToRepresentation(parsed.protocol);
    }
  } catch (err) {
    if (err instanceof URIError) {
      return;
    } else {
      throw err;
    }
  }
  return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);
}
const correctProtocol = (arg) => {
  const firstColon = arg.indexOf(":");
  const proto = arg.slice(0, firstColon + 1);
  if (knownProtocols.includes(proto)) {
    return arg;
  }
  const firstAt = arg.indexOf("@");
  if (firstAt > -1) {
    if (firstAt > firstColon) {
      return `git+ssh://${arg}`;
    } else {
      return arg;
    }
  }
  const doubleSlash = arg.indexOf("//");
  if (doubleSlash === firstColon + 1) {
    return arg;
  }
  return arg.slice(0, firstColon + 1) + "//" + arg.slice(firstColon + 1);
};
const isGitHubShorthand = (arg) => {
  const firstHash = arg.indexOf("#");
  const firstSlash = arg.indexOf("/");
  const secondSlash = arg.indexOf("/", firstSlash + 1);
  const firstColon = arg.indexOf(":");
  const firstSpace = /\s/.exec(arg);
  const firstAt = arg.indexOf("@");
  const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;
  const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;
  const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;
  const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;
  const hasSlash = firstSlash > 0;
  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== "/" : !arg.endsWith("/");
  const doesNotStartWithDot = !arg.startsWith(".");
  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;
};
const correctUrl = (giturl) => {
  const firstAt = giturl.indexOf("@");
  const lastHash = giturl.lastIndexOf("#");
  let firstColon = giturl.indexOf(":");
  let lastColon = giturl.lastIndexOf(":", lastHash > -1 ? lastHash : Infinity);
  let corrected;
  if (lastColon > firstAt) {
    corrected = giturl.slice(0, lastColon) + "/" + giturl.slice(lastColon + 1);
    firstColon = corrected.indexOf(":");
    lastColon = corrected.lastIndexOf(":");
  }
  if (firstColon === -1 && giturl.indexOf("//") === -1) {
    corrected = `git+ssh://${corrected}`;
  }
  return corrected;
};
const parseGitUrl = (giturl) => {
  let result;
  try {
    result = new url.URL(giturl);
  } catch (err) {
  }
  if (result) {
    return result;
  }
  const correctedUrl = correctUrl(giturl);
  try {
    result = new url.URL(correctedUrl);
  } catch (err) {
  }
  return result;
};
var hostedGitInfoExports = hostedGitInfo.exports;
export {
  hostedGitInfoExports as h
};
//# sourceMappingURL=index.js.map
