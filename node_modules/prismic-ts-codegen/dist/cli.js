import { stripIndent } from "common-tags";
import { existsSync, writeFileSync } from "fs";
import meow from './_node_modules/meow/source/index.js';
import { resolve } from "path";
import { generateTypes } from "./generateTypes.js";
import { detectTypesProvider } from "./detectTypesProvider.js";
import { configSchema } from "./cli/configSchema.js";
import { NON_EDITABLE_FILE_HEADER } from "./cli/constants.js";
import { loadConfig } from "./cli/loadConfig.js";
import { loadLocaleIDs } from "./cli/loadLocaleIDs.js";
import { loadModels } from "./cli/loadModels.js";
const cli = meow(`
	Usage:
	    prismic-ts-codegen [options...]
	    prismic-ts-codegen init [options...]

	Commands:
	    init [options]

	Options:
	    -c, --config <path>  Path to a prismic-ts-codegen configuration file.
	`, {
  importMeta: import.meta,
  flags: {
    config: {
      type: "string",
      shortFlag: "c",
      isRequired: false
    }
  }
});
const main = async () => {
  var _a, _b, _c, _d, _e;
  if (cli.input[0] === "init") {
    const configPath = cli.flags.config || "prismicCodegen.config.ts";
    if (existsSync(configPath)) {
      console.info(`
${configPath} already exists.`);
    } else {
      let contents = "";
      if (existsSync("slicemachine.config.json") || existsSync("sm.json")) {
        contents = stripIndent`
					import type { Config } from "prismic-ts-codegen";

					const config: Config = {
					  output: "./types.generated.ts",
					  models: ["./customtypes/**/index.json", "./slices/**/model.json"],
					};

					export default config;
				`;
      } else {
        contents = stripIndent`
					import type { Config } from "prismic-ts-codegen";

					const config: Config = {
					  output: "./types.generated.ts",
					};

					export default config;
				`;
      }
      writeFileSync(configPath, contents);
      console.info(`
Created prismic-ts-codegen config file: ${configPath}`);
    }
  } else {
    const unvalidatedConfig = loadConfig({ path: cli.flags.config });
    const { value: config, error } = configSchema.validate(unvalidatedConfig);
    if (config && !error) {
      const { customTypeModels, sharedSliceModels } = await loadModels({
        localPaths: Array.isArray(config.models) ? config.models : (_a = config.models) == null ? void 0 : _a.files,
        repositoryName: config.repositoryName,
        customTypesAPIToken: config.customTypesAPIToken,
        fetchFromRepository: config.models && "fetchFromRepository" in config.models && config.models.fetchFromRepository
      });
      const localeIDs = await loadLocaleIDs({
        localeIDs: Array.isArray(config.locales) ? config.locales : (_b = config.locales) == null ? void 0 : _b.ids,
        repositoryName: config.repositoryName,
        accessToken: config.accessToken,
        fetchFromRepository: config.locales && "fetchFromRepository" in config.locales && config.locales.fetchFromRepository
      });
      const typesProvider = config.typesProvider || await detectTypesProvider();
      const hasCustomTypeModels = customTypeModels.length > 0;
      if (((_c = config.clientIntegration) == null ? void 0 : _c.includeCreateClientInterface) && !hasCustomTypeModels) {
        console.info("[INFO]: prismic-ts-codegen was configured to automatically integrate with `@prismicio/client`, but the integration was not generated because no Custom Type models were found. Automatic integration requires at least one Custom Type model.");
      }
      const types = generateTypes({
        customTypeModels,
        sharedSliceModels,
        localeIDs,
        fieldConfigs: config.fields,
        clientIntegration: {
          includeCreateClientInterface: hasCustomTypeModels ? ((_d = config.clientIntegration) == null ? void 0 : _d.includeCreateClientInterface) ?? true : false,
          includeContentNamespace: ((_e = config.clientIntegration) == null ? void 0 : _e.includeContentNamespace) ?? true
        },
        typesProvider
      });
      const fileContents = `${NON_EDITABLE_FILE_HEADER}

${types}`;
      if (config.output) {
        writeFileSync(resolve(config.output), fileContents);
        console.info(`
Generated types in: ${config.output}`);
      } else {
        process.stdout.write(types + "\n");
      }
    } else {
      if (error) {
        console.error(error.message);
        process.exit(1);
      }
    }
  }
};
main().catch((error) => {
  console.error(error);
  process.exit(1);
});
//# sourceMappingURL=cli.js.map
